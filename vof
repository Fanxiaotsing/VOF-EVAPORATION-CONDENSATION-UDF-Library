// Normal defined using DEFINE_INIT && DEFINE_EXECUTE_AT_END on 15-12-2012
// Modified S-VEC Definition (04-11-2012). 
// NOTE: Densty is not being updated in densty() subroutine. It is being done in FLUENT calculations itself.


// OBJECTIVE is to get a contour for iphase[c] which matches exactly with C_VOF(c,t_vapour) at every timestep.

// SUCCESS MEANS = TRACKING of interface.



//																				THE BEST UDF TILL DATE (01:00 PM 04-01-2013)

// ONLY ERROR THAT IS COMING IS THAT there is ocurrence of x-momentum divergence after 1st timestep. Possible Reason = Incompatibility of t_vapour, t_liquid threads in moveit subroutine inside Define_Execute_End with Fluent solver. Maybe there is some conflict between code and Fluent solver.
// This Error is now resolved(05:24 PM 04-01-2013). Only error that may arise is ocassional occurrence of INF or IND value being stored in UDM index 2,3 i.e in normx, normy. This is partly because inefficiency of get_len subroutine in some cells. (denerr value becoming zero in some cells which is unwanted and which results in FOR Loop in get_len to stop.)
// It is advised to keep dt(timestep) to be below 1e-05 as erro is coming with 1e-04 value.
//  NOTE: If this error occurres then please try reducing timestep value or try checking values of UDM somewhere INF value may be coming, or try checking mass tranfer rate ....because it may also cause some problem.


// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// This code is Grid geometry dependent. Present geometry is rectangular of width 1.135 mm and height 2.27 mm.
// If Wish to use it for different geometry then please change macros in which BOUNDARY CELLS ARE  CONSIDERED Viz.
//						1). DEFINE_MASS_TRANSFER
//						2). DEFINE_INIT(iterface_profile1)

#include "udf.h"
#include "sg.h"
#include "sg_vof.h"
#include "cxbool.h"

#define max(a,b) ((a>b) ? a:b)
#define min(a,b) ((a<b) ? a:b)
#define VDMNMX(vvvvvv) min((1.0- 0.00000001),max(0.00000001,vvvvvv))
#define SIGMA 0.07*pow(10,-3.0) // coefficient of surface tension
#define ROL 402.4    // liquid density
#define ROG 242.7    // vapour density
#define M_G 9.81     // acceleration due to gravity
#define PSAT 21900000.0     // saturation due to gravity as is used in  " D.K.Aggarwal, S.W.J. Welch, G. Biswas, F. Durst,  Planar Simulation of Bubble Growth in Film Boiling in Near-Critical Water Using a Variant of the VOF method, J. Heat Transfer, June 2001, vol 126, pp- 329 to 338 "
#define TSAT 646.15			// Saturation temperature


/*
--------------------------------------------------- UDM INDEX -------------------------------------------------------------------------------------------------------------------------------------------------------

 C_UDMI(c,t,0)	=  itran(i,j) array used in density() subroutine of FORTRAN CODE.
 C_UDMI(c,t,1)	=  iphase(i,j) array used in moveit() and other subroutine's of FORTRAN CODE. " 1 = Liquid; 2 = Mixture; 3 = Vapour cell respectively " 
							(NOTE: This udm represents interface tracked using G. Biswas Code. If it matrches with actual volume fraction contour then it is success.)
 C_UDMI(c,t,2)	=  normx(i,j) array used in iface() and other subroutine's in FORTRAN CODE.
 C_UDMI(c,t,3)	=  normy(i,j) array used in iface() and other subroutine's in FORTRAN CODE.
 C_UDMI(c,t,4)	=  slen(i,j) array used in get_len() subroutine of FORTRAN CODE.
 C_UDMI(c,t,5)	=  err value in SECANT METHOD LOOP used in get_len() subroutine of FORTRAN CODE for getting correct slen(which is distance between midpoint of interface and the centroid of that cell).

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */

/* ----------------- CELL Thread declaration nomenclature -----------------
	f = front face
	l = left face
	a = after face
	r = right face
*/

/* ----------------- CELL Thread declaration nomenclature -----------------
see my copy named JAYCO - SAMIR BINDING for declaration of neighbour cell threads. 

*/

/*--------- delta function ----------- */
/* This function returns dx and dy for every cells of any kind. Both rectangular as well as axisymmetric grid can be fed into this function. */
// IMPORTANT NOTE: In This Macro Boundary cells are not considered. SO if we are not considering boundary cells then this part becomes grid geometry independent. 
//  But if in future we include boundary cells as well then This part needs to be changed for different geometry.
extern void
delta( cell_t c, Thread *t, real *dx, real *dy )
{
	real xc[ND_ND], xr[ND_ND], xf[ND_ND], xl[ND_ND], xa[ND_ND] ;
	face_t fr, ff, fl, fa;
	Thread *tf, *tfr, *tff, *tfl, *tfa;
	Node *node;
	int n;
	tf = C_FACE_THREAD(c,t,0);

	

		*dx =  0.00227/360.0;
		*dy = 0.001135/180.0 ;
	

}
/*--------- lgvol function ----------- */
/* This function Computes the liquid volume in the rectangle 
      bounded by the four lines xl, xr, ya, and yf 
      (xleft, xright, yaft, yfront)
      The liquid-gas interface plane cuts through the rectangle at
      a distance slen from the point (xc,yc).  slen is measured such
      that slen*(nx,ny) + (xbase,ybase) = (xc,yc).
      The normal to the interface plane (into the liquid phase) 
      is (nx,ny). */
extern void
lgvol_old( cell_t c, Thread *t, real xl, real xr, real ya, real yf, real *voll )
{
	cell_t cr, cf, cl, ca, crf, cra, clf, cla ;
	Thread *tf, *ta, *tr, *tl, *trf, *tra, *tlf, *tla ;

	int n, nvert;
	real xc[ND_ND];
	real xi,  yi;
	real xv1, xv2, yv1, yv2;
	real tx,  ty, eps;
	real xvert[5], yvert[5], slope , slopi;
	real xint1, xint2, yint1, yint2;
	real xtest, ytest, dot_prod;
	real dot_prod_new, dot_prod_old;
	real lenm1;
	real len, nx, ny;
	real voll_old, voll_new;
	real var;
	int iface_int1, iface_int2;
	int iphs;

	/*     iface_int = 1  - bottom edge
                   2  - right edge
                   3  - top edge
                   4  - left edge     */
       iface_int1 = 0;
	   iface_int2 = 0;

       eps = 0.000001;

       
       C_CENTROID(xc,c,t);   

      iphs = C_UDMI(c,t,1); 
	  nx = C_UDMI(c,t,2);
	  ny = C_UDMI(c,t,3);
	  len = C_UDMI(c,t,4);
	  	   
	//  Message(" lgvol c, nx, ny = %u %f %f \n ", c, nx, ny);

	   tx = -ny;
       ty = nx;

	   xi = xc[0] - len * nx;
       yi = xc[1] - len * ny;

	   linseg(  c, t, xl, xr, ya, yf, &xint1, &xint2, &yint1, &yint2, &iface_int1, &iface_int2  );
	if( c == 1795 )
	{
//		Message(" c, t, xl, xr, ya, yf,xint1,xint2,yint1,yint2 = %u %u %.15f %.15f %.15f %.15f %.15f %.15f %.15f %.15f \n", c, t, xl, xr, ya, yf, xint1,xint2,yint1,yint2);
	}
	   
	/*    if( iface_int1 == 0 && iface_int2 == 0 )
		{
			return ;
		}			*/

//		Message(" c, xint1, xint2, yint1, yint2, iface_int1, iface_int2 = %u %f %f %f %f %d %d \n" , c, xint1, xint2, yint1, yint2, iface_int1, iface_int2);
	  
	   /* find cell corners that are vertices */

	   nvert = 0;

	   /* bottom left corner */
	   xtest = xl - xi ;
       ytest = ya - yi ;
       dot_prod = xtest*nx + ytest*ny;
	   
	      if (dot_prod >= 0.0 ) 
          {
				nvert = nvert + 1;
				xvert[nvert-1] = xl;
				yvert[nvert-1] = ya;
		  }

	   /* interface intersects bottom */
		  if      (iface_int1 == 1 )
			{
				nvert = nvert + 1;
				xvert[nvert-1] = xint1;
				yvert[nvert-1] = yint1;
			}
		  else if (iface_int2 == 1 )
			{
				nvert = nvert + 1;
				xvert[nvert-1] = xint2;
				yvert[nvert-1] = yint2;
			}
		/* bottom right corner */
				xtest = xr - xi; 
				ytest = ya - yi;
				dot_prod = xtest*nx + ytest*ny;
       if (dot_prod >= 0.0 ) 
			{
				nvert = nvert + 1;
				xvert[nvert-1] = xr;
				yvert[nvert-1] = ya;
			}

       /* interface intersects right */

       if      (iface_int1 == 2 ) 
	   { 
				nvert = nvert + 1;
				xvert[nvert-1] = xint1;
				yvert[nvert-1] = yint1;
	   }
       else if (iface_int2 == 2 ) 
	   {
			    nvert = nvert + 1;
				xvert[nvert-1] = xint2;
				yvert[nvert-1] = yint2;
	   }

	  /* top right corner */

       xtest = xr - xi ;
       ytest = yf - yi ;
       dot_prod = xtest*nx + ytest*ny;
       if (dot_prod >= 0.0 ) 
	   {
	//	   Message(" dot_prod2 = %f \n" , dot_prod);
				nvert = nvert + 1;
				xvert[nvert-1] = xr;
				yvert[nvert-1] = yf;
	   }

	   /* interface intersects top */

       if      (iface_int1 == 3 )
	   {
				nvert = nvert + 1;
				xvert[nvert-1] = xint1;
				yvert[nvert-1] = yint1;
	   }
       else if (iface_int2 == 3 )
	   {
				nvert = nvert + 1;
				xvert[nvert-1] = xint2;
				yvert[nvert-1] = yint2;
	   }
       

		/* top left corner */

       xtest = xl - xi ;
       ytest = yf - yi;
       dot_prod = xtest*nx + ytest*ny;
       if (dot_prod >= 0.0 ) 
	   {
	//	   Message(" dot_prod3 = %f \n" , dot_prod);
				 nvert = nvert + 1;
				 xvert[nvert-1] = xl;
				 yvert[nvert-1] = yf;
	   }

		/* interface intersects left */

       if      (iface_int1 == 4 ) 
	   {
				nvert = nvert + 1;
				xvert[nvert-1] = xint1;
				yvert[nvert-1] = yint1;
	   }
       else if (iface_int2 == 4 ) 
	   {
			    nvert = nvert + 1;
				xvert[nvert-1] = xint2;
				yvert[nvert-1] = yint2;
	   }

//	   Message("xvert = %.15f %.15f %.15f %.15f %.15f \n", xvert[0], xvert[1], xvert[2], xvert[3], xvert[4] );
//	   Message("yvert = %.15f %.15f %.15f %.15f %.15f \n", yvert[0], yvert[1], yvert[2], yvert[3], yvert[4] );
	  (*voll) = 0.0;
	
	   for( n = 0; n <= nvert; n++)			// ( n = 1; n < nvert; n++)											CHANGE FROM FORTRAN STYLE TO C STYLE.
	   {
          xv1 = xvert[n];
          yv1 = yvert[n];
		  
          if ( n == nvert )
		  {
			  xv2 = xvert[0];
              yv2 = yvert[0];
		  }
          else 
		  {
			  xv2 = xvert[n+1];
              yv2 = yvert[n+1];
		  }
					

//		  Message("nvert, xv1 ,xv2, yv1, yv2 = %d %.20f %.20f %.20f %.20f \n", nvert, xv1 ,xv2, yv1, yv2 );
		  var = (xv1*yv2 - xv2*yv1);

//		  Message(" n , (*voll) , var = %d %f %.30f \n \n \n ", n , (*voll) , var );  
		  (*voll) = (*voll) + xv1*yv2 - xv2*yv1;
		}
	   
	   (*voll) = 0.5*(*voll);
//		Message(" c, voll = %u %g \n ", c, (*voll) );
}

extern void
lgvol( cell_t c, Thread *t, real xl, real xr, real ya, real yf, real *voll )
{
	cell_t cr, cf, cl, ca, crf, cra, clf, cla ;
	Thread *tf, *ta, *tr, *tl, *trf, *tra, *tlf, *tla ;

	int n, nvert;
	real xc[ND_ND];
	real xi,  yi;
	real xv1, xv2, yv1, yv2;
	real tx,  ty, eps;
	real xvert[5], yvert[5], slope , slopi;
	real xint1, xint2, yint1, yint2;
	real xtest, ytest, dot_prod;
	real dot_prod_new, dot_prod_old;
	real lenm1;
	real len, nx, ny;
	real voll_old, voll_new;
	real var;
	int iface_int1, iface_int2;
	int iphs;

	/*     iface_int = 1  - bottom edge
                   2  - right edge
                   3  - top edge
                   4  - left edge     */
       iface_int1 = 0;
	   iface_int2 = 0;

       eps = 0.000001;// any lower value 10-6

       
       C_CENTROID(xc,c,t);   

      iphs = C_UDMI(c,t,1); 
	  nx = C_UDMI(c,t,2);
	  ny = C_UDMI(c,t,3);
	  len = C_UDMI(c,t,4);
	  	   
	//  Message(" lgvol c, nx, ny = %u %f %f \n ", c, nx, ny);

	   tx = -ny;
       ty = nx;

	   xi = xc[0] - len * nx;
       yi = xc[1] - len * ny;

	   linseg(  c, t, xl, xr, ya, yf, &xint1, &xint2, &yint1, &yint2, &iface_int1, &iface_int2  );
	if( c == 1795 )
	{
//		Message(" c, t, xl, xr, ya, yf,xint1,xint2,yint1,yint2 = %u %u %.15f %.15f %.15f %.15f %.15f %.15f %.15f %.15f \n", c, t, xl, xr, ya, yf, xint1,xint2,yint1,yint2);
	}
	   
	/*    if( iface_int1 == 0 && iface_int2 == 0 )
		{
			return ;
		}			*/

//		Message(" c, xint1, xint2, yint1, yint2, iface_int1, iface_int2 = %u %f %f %f %f %d %d \n" , c, xint1, xint2, yint1, yint2, iface_int1, iface_int2);
	  
	   /* find cell corners that are vertices */

	   nvert = 0;

	   /* bottom left corner */
	   xtest = xl - xi ;
       ytest = ya - yi ;
       dot_prod = xtest*nx + ytest*ny;
	   
	      if (dot_prod >= 0.0 ) 
          {
				nvert = nvert + 1;
				xvert[nvert-1] = xl;
				yvert[nvert-1] = ya;
		  }

	   /* interface intersects bottom */
		  if      (iface_int1 == 1 )
			{
				nvert = nvert + 1;
				xvert[nvert-1] = xint1;
				yvert[nvert-1] = yint1;
			}
		  else if (iface_int2 == 1 )
			{
				nvert = nvert + 1;
				xvert[nvert-1] = xint2;
				yvert[nvert-1] = yint2;
			}
		/* bottom right corner */
				xtest = xr - xi; 
				ytest = ya - yi;
				dot_prod = xtest*nx + ytest*ny;
       if (dot_prod >= 0.0 ) 
			{
				nvert = nvert + 1;
				xvert[nvert-1] = xr;
				yvert[nvert-1] = ya;
			}

       /* interface intersects right */

       if      (iface_int1 == 2 ) 
	   { 
				nvert = nvert + 1;
				xvert[nvert-1] = xint1;
				yvert[nvert-1] = yint1;
	   }
       else if (iface_int2 == 2 ) 
	   {
			    nvert = nvert + 1;
				xvert[nvert-1] = xint2;
				yvert[nvert-1] = yint2;
	   }

	  /* top right corner */

       xtest = xr - xi ;
       ytest = yf - yi ;
       dot_prod = xtest*nx + ytest*ny;
       if (dot_prod >= 0.0 ) 
	   {
	//	   Message(" dot_prod2 = %f \n" , dot_prod);
				nvert = nvert + 1;
				xvert[nvert-1] = xr;
				yvert[nvert-1] = yf;
	   }

	   /* interface intersects top */

       if      (iface_int1 == 3 )
	   {
				nvert = nvert + 1;
				xvert[nvert-1] = xint1;
				yvert[nvert-1] = yint1;
	   }
       else if (iface_int2 == 3 )
	   {
				nvert = nvert + 1;
				xvert[nvert-1] = xint2;
				yvert[nvert-1] = yint2;
	   }
       

		/* top left corner */

       xtest = xl - xi ;
       ytest = yf - yi;
       dot_prod = xtest*nx + ytest*ny;
       if (dot_prod >= 0.0 ) 
	   {
	//	   Message(" dot_prod3 = %f \n" , dot_prod);
				 nvert = nvert + 1;
				 xvert[nvert-1] = xl;
				 yvert[nvert-1] = yf;
	   }

		/* interface intersects left */

       if      (iface_int1 == 4 ) 
	   {
				nvert = nvert + 1;
				xvert[nvert-1] = xint1;
				yvert[nvert-1] = yint1;
	   }
       else if (iface_int2 == 4 ) 
	   {
			    nvert = nvert + 1;
				xvert[nvert-1] = xint2;
				yvert[nvert-1] = yint2;
	   }

//	   Message("xvert = %.15f %.15f %.15f %.15f %.15f \n", xvert[0], xvert[1], xvert[2], xvert[3], xvert[4] );
//	   Message("yvert = %.15f %.15f %.15f %.15f %.15f \n", yvert[0], yvert[1], yvert[2], yvert[3], yvert[4] );
	  (*voll) = 0.0;
	
	   for( n = 0; n <= (nvert-1); n++)			// ( n = 1; n < nvert; n++)											CHANGE FROM FORTRAN STYLE TO C STYLE.
	   {
          xv1 = xvert[n];
          yv1 = yvert[n];
		  
          if ( n == (nvert-1) )
		  {
			  xv2 = xvert[0];
              yv2 = yvert[0];
		  }
          else 
		  {
			  xv2 = xvert[n+1];
              yv2 = yvert[n+1];
		  }
					

//		  Message("nvert, xv1 ,xv2, yv1, yv2 = %d %.20f %.20f %.20f %.20f \n", nvert, xv1 ,xv2, yv1, yv2 );
//		  var = (xv1*yv2 - xv2*yv1);// no use

//		  Message(" n , (*voll) , var = %d %f %.30f \n \n \n ", n , (*voll) , var );  
		  (*voll) = (*voll) + xv1*yv2 - xv2*yv1;
		}
	   
	   (*voll) = 0.5*(*voll);  // why multiplied by 0.5?
//		Message(" c, voll = %u %g \n ", c, (*voll) );
	   return;
}


/*--------- get_len function ----------- */
/* This function uses SECANT ITERATIVE METHOD for calculating the value of 
correct len(which is distance between midpoint of interface and the centroid of that cell) in a cell.
Strategy is simple. Just use first two approximate values of len(here diagonals are used) then employe 
SECANT method which should stop once void fraction estimated from this len value is matching with actual void fraction from 
Fluent SOlver.   */

// IMPORTANT NOTE: In This Macro Boundary cells are not considered. SO if we are not considering boundary cells then this part becomes grid geometry independent. 
//  But if in future we include boundary cells as well then This part needs to be changed for different geometry.
extern void
get_len(cell_t c, Thread *t, real nx, real ny )
{
	/* ===========================	DECLARATION  ============================ */

	face_t fr,ff,fl,fa;
	Thread *tfr, *tff, *tfl, *tfa;
	Thread *t_f;
	Node *node;
	int niter,itermx;
	real voll;
	int n, nvert,a;
	real xr, yf, xl, ya, xc[ND_ND], XR[ND_ND], XF[ND_ND], XL[ND_ND], XA[ND_ND];
	real dx,dy;

	real leng , lenp1 , lenm1 , vdfm1 , vdf;
	real ndiag1, ndiag2, mxslen, epslen;
	real lvol, vol ;
	real volume , err, errm1, denerr, void_t;
	real toler;
	real *ptl, *ptr, *pta, *ptf ;
	real xi,  yi;
	real xv1, xv2, yv1, yv2;
	real tx,  ty, eps;
	real xvert[5], yvert[5], slope , slopi;
	real xint1, xint2, yint1, yint2;
	real iface_int1, iface_int2 ;
	real xtest, ytest, dot_prod;
	real len;

//	Message(" c, C_UDMI(c,t,7) = %u %f \n", c, C_UDMI(c,t,7) );

	delta( c, t, &dx, &dy );
//	nmx(c,t, &nx, &ny);
	vol = dx*dy;

	C_CENTROID(xc,c,t);
		
	t_f = C_FACE_THREAD(c,t,0);
	
		if(BOUNDARY_FACE_THREAD_P(t_f))
		{
			/*
			c_node_loop(c,t,a)
	        {
			  node = C_NODE(c,t,a);
 		 
	
				if( NODE_X(node) == 0 )
				{
					fr = C_FACE(c,t,2);
					tfr = C_FACE_THREAD(c,t,2);
					fl = C_FACE(c,t,0);					
					tfl = C_FACE_THREAD(c,t,0);			
					ff = C_FACE(c,t,3);					
					tff = C_FACE_THREAD(c,t,3);
					fa = C_FACE(c,t,1);
					tfa = C_FACE_THREAD(c,t,1);
				}

				if( NODE_X(node)*1000000 == 1135 )
				{
					fr = C_FACE(c,t,0);
					tfr = C_FACE_THREAD(c,t,0);
					fl = C_FACE(c,t,2);					
					tfl = C_FACE_THREAD(c,t,2);			
					ff = C_FACE(c,t,1);					
					tff = C_FACE_THREAD(c,t,1);
					fa = C_FACE(c,t,3);
					tfa = C_FACE_THREAD(c,t,3);
				}

				if( NODE_Y(node) == 0 )
				{
					fr = C_FACE(c,t,1);
					tfr = C_FACE_THREAD(c,t,1);
					fl = C_FACE(c,t,3);					
					tfl = C_FACE_THREAD(c,t,3);			
					ff = C_FACE(c,t,2);					
					tff = C_FACE_THREAD(c,t,2);
					fa = C_FACE(c,t,0);
					tfa = C_FACE_THREAD(c,t,0);
				}

				if( NODE_Y(node)*100000 == 227 )
				{
					fr = C_FACE(c,t,3);
					tfr = C_FACE_THREAD(c,t,3);
					fl = C_FACE(c,t,1);					
					tfl = C_FACE_THREAD(c,t,1);			
					ff = C_FACE(c,t,0);					
					tff = C_FACE_THREAD(c,t,0);
					fa = C_FACE(c,t,2);
					tfa = C_FACE_THREAD(c,t,2);
				}		
			}
			*/
		}
		else
		{
		
					fr = C_FACE(c,t,1);
					tfr = C_FACE_THREAD(c,t,1);
					fl = C_FACE(c,t,3);					/* --------------------- FOR ---------------------- */
					tfl = C_FACE_THREAD(c,t,3);			/* ------------------ INTERIOR -------------------- */ 
					ff = C_FACE(c,t,2);					/* -------------------- CELLS --------------------- */
					tff = C_FACE_THREAD(c,t,2);
					fa = C_FACE(c,t,0);
					tfa = C_FACE_THREAD(c,t,0);

		

					F_CENTROID(XR,fr,tfr);
					F_CENTROID(XF,ff,tff);
					F_CENTROID(XL,fl,tfl);
					F_CENTROID(XA,fa,tfa);

					xr = XR[0] ;
					yf = XF[1] ;
					xl = XL[0] ;
					ya = XA[1] ;
	
					ptl = &xl;
					ptr = &xr;
					pta = &ya;
					ptf = &yf;

		//			Message("nx, ny = %f %f \n", nx, ny);
					ndiag1 = fabs(   dx*(nx) + dy*(ny) );
					ndiag2 = fabs( - dx*(nx) + dy*(ny) );

				// Pick the maximum of these dot products and use half that distance for max slen
					mxslen = 0.5*max( ndiag1, ndiag2 );
		//			Message("dx, dy, mxslen = %g %g %g \n", dx, dy, mxslen);
		//			Message("xc, yc = %g %g \n", xc[0], xc[1]);
					toler  = 0.0001;
					volume = dx*dy;
	
   

					void_t = C_VOF(c,t);
					void_t = VDMNMX(void_t);

		//			Message(" void_t = %f \n " , void_t);

					/* ==================================== use secant method ==================================== */

				  /* =========== first starting value and perturbation length for secant method =========== */
					/* --------------------------------------------------------------------------------- */
					epslen		= 0.05*mxslen;
					lenm1		= epslen;
		//			(*slen)		= lenm1;
					C_UDMI(c,t,4) = lenm1;
		//			Message(" 1st slen = %g \n " , C_UDMI(c,t,4));
					lgvol( c, t, xl, xr, ya, yf, &lvol );
		//			Message(" nx, ny, voll first value = %f %f %g \n " , nx, ny, lvol);
		
					vdfm1 = lvol/vol;
					errm1 = vdfm1 - void_t;
					if (fabs(errm1) < toler) 
					{
						lenp1 = lenm1;
						goto HI;
					}
			
					/* =================== second starting value for secant method ==================== */
					leng		= lenm1 - epslen;
			//		(*slen)		= leng;
					C_UDMI(c,t,4) = leng; 
		//			Message("2nd slen = %g \n " , C_UDMI(c,t,4));
					/* =================== main iteration loop - secant method ======================== */
					itermx = 100;
					for (niter = 1; niter < itermx; niter++)
					{
						lgvol( c, t, xl, xr, ya, yf, &lvol );
						
						vdf    = lvol/vol;
						err    = vdf - void_t;
						denerr = err - errm1;
			//			Message("c, slen, lvol = %u %g %g \n", c, C_UDMI(c,t,4), lvol);

			//			 Message("c, niter, nx, ny,  void_t, vdf = %u %d %f %f  %.15f %.15f \n \n " , c, niter, nx, ny, void_t, vdf);
						 
		/*				 if( vdf > 1.0 )
						 {
							 goto HI;
						 }						*/

				//		Message("denerr %.15f \n", denerr);

						if(fequal(denerr , 0.0))
						{
				//			Message( "bug in iface = niter, c, err, slen, lvol, nx, ny %d %u %g %g %g %f %f \n \n", niter, c, err, C_UDMI(c,t,4), lvol, nx, ny);
							C_UDMI(c,t,5) = fabs(err);
                //            Message(" void_t,vdfm1,vdf = %.10f %.10f %.10f \n ", void_t,vdfm1,vdf );
				//			Message(" err,errm1 = %.10f %.10f \n ", err,errm1 );
				//			Message(" slen = %.15f  \n ", C_UDMI(c,t,4) );
				//			Message(" nx,ny = %.10f %.10f \n \n ", nx,ny );
        		//			return;
				//			denerr = -0.1 ;
							return;
						}

						lenp1  = leng - err*(leng - lenm1)/denerr;

						if (fabs(err) < toler) 
							{
				//				Message(" err = %u %g \n \n ", c, err );
				//				Message("c, slen, lvol, nx, ny = %u %g %g %f %f \n", c, C_UDMI(c,t,4), lvol, nx, ny);
								C_UDMI(c,t,5) = fabs(err);			// udm memory for accessing err value in LVIRA loop.
								goto HI;
							}

	

							  lenm1		= leng;
							  leng		= lenp1;
					//		  (*slen)	= leng;
							  errm1		= err;
							  C_UDMI(c,t,4) = leng; 
					}
		HI: ;
				//	Message( " HI !!! I am in Get_Len. \n " );
					lenp1		= min(mxslen, max(-mxslen,lenp1));
				   
			//		(*slen)		= lenp1;	
					C_UDMI(c,t,4) = lenp1; 
			//		Message("c, slen, void_t, vdf = %u %g %.15f %.15f \n " , c, C_UDMI(c,t,4), void_t, vdf );
	}
HI1:;

	return;
}



/*--------- linseg function ----------- */
/*    Computes the endpoints of the interface (xint,yint) and the
      number of endpoints (nint)
      bounded by the four lines xl, xr, ya, and yf
      (xleft, xright, yaft, yfront)
      The liquid-gas interface plane cuts through the volume at
      a distance sleng from the point (xc,yc).  slen is measured such
      that slen*(nx,ny) + (xbase,ybase) = (xc,yc).
      The normal to the interface plane (into the liquid phase) 
      is (nx,ny).
  */
// GRID GEOMETRY INDEPENDENT PART.
extern void
linseg(  cell_t c, Thread *t, real xl, real xr, real ya, real yf, real *xint1, real *xint2, real *yint1, real *yint2, int *iface_int1, int *iface_int2  )
{
	cell_t cr, cf, cl, ca, crf, cra, clf, cla ;
	Thread *tf, *ta, *tr, *tl, *trf, *tra, *tlf, *tla ;

	Thread *t_liquid;
	face_t fr, ff, fl, fa;
	Thread *tfr, *tff, *tfl, *tfa;
	real xc[ND_ND], XR[ND_ND], XF[ND_ND], XL[ND_ND], XA[ND_ND] ;
	real xi, yi;
	real tx,ty;
	real eps;
	real slope,slopi;
	real xtest, ytest, dot_prod;
	real dot_prod_new, dot_prod_old;
	real len, nx, ny;
	real dx, dy ;

	real xint[ND_ND], yint[ND_ND] ;
	int nint;
	int iphs;
	int iface_int[ND_ND];
/*		iface_int = 1  - bottom edge
					2  - right edge
			        3  - top edge
                    4  - left edge                */
				  
				  
				  iface_int[0] = 0;
				  iface_int[1] = 0;

				  eps = 0.000000001;

				  iphs = C_UDMI(c,t,1); 
				  nx = C_UDMI(c,t,2);
				  ny = C_UDMI(c,t,3);
				  len = C_UDMI(c,t,4);

	//	    Message(" linseg c, nx, ny = %u %f %f \n ", c, nx, ny);

	C_CENTROID(xc,c,t);
	
	delta( c, t, &dx, &dy );

	tx = -ny;
	ty = nx;

	 xi = xc[0] - len * nx;
     yi = xc[1] - len * ny;

//	 Message(" xi = %f \n", xi);

	 nint = 0;
						*xint1			= 0.0;
						*yint1			= 0.0;
						*xint2			= 0.0;
						*yint2			= 0.0;
//	if( c == 1795 )
//	{
//		Message("c, nx, ny, xi, yi, xl, xr, ya, yf = %u %.15f %.15f %.15f %.15f %.15f %.15f %.15f %.15f \n", c, nx, ny, xi, yi, xl, xr, ya, yf);
//	}

	 
	
/* ====== switch to cases depending on slope ====== */

		if( fabs(nx) < eps*dx )
	    {
		   if ( yi > ya  && yi < yf )
		   {
//			   Message("1 \n");
			   			xint[0]			= xl;
						yint[0]			= yi;
						xint[1]			= xr;
						yint[1]			= yi;
						iface_int[0]	= 4;
						iface_int[1]	= 2;
						*xint1			= xint[0];
						*yint1			= yint[0];
						*xint2			= xint[1];
						*yint2			= yint[1];
						*iface_int1		= iface_int[0];
						*iface_int2		= iface_int[1];
						 nint			= 2;
//						 if( c == 1795 )
//						 {
		//					 Message(" LINSEG (1)  %u %.15f %.15f %.15f %.15f \n", c, *xint1,*xint2,*yint1,*yint2 );
//						 }
		   }
	    }
		else if ( fabs(ny) < eps*dy )
	    {
		   if( xi > xl  && xi < xr )
		   {
//			   Message("2 \n");
						xint[0]			= xi;
						yint[0]			= ya;
						xint[1]			= xi;
						yint[1]			= yf;
						iface_int[0]	= 1;
						iface_int[1]	= 3;
						*xint1			= xint[0];
						*yint1			= yint[0];
						*xint2			= xint[1];
						*yint2			= yint[1];
						*iface_int1		= iface_int[0];
						*iface_int2		= iface_int[1];
						nint			= 2;
//						 if( c == 1795 )
//						 {
		//					 Message(" LINSEG (2)  %u %.15f %.15f %.15f %.15f \n", c, *xint1,*xint2,*yint1,*yint2 );
//						 }
		   }
	   }
	   else
	   {
						slope = - nx/ny;
						slopi = - ny/nx;

		/* ====== test top ====== */
				ytest = yf;
				xtest = slopi*( ytest - yi ) + xi;

	//			Message("top iphase, nx, ny, slope, slopi, xc[0], xc[1], len, xi, yi,  ytest, xtest = %u %d %f %f %f %f %f %g %f %f %f %f %f \n ", c,iphs, nx, ny, slope, slopi, xc[0], xc[1], len, xi, yi, ytest, xtest);

				if(  ( xtest >= xl )  &&  ( xtest <= xr )  )
				{
//					Message("3 \n");
						nint					= nint + 1 ;
						xint[nint - 1]			= xtest;
						yint[nint - 1]			= ytest;
						iface_int[nint - 1]		= 3;
						*xint1			= xint[0];
						*yint1			= yint[0];
						*xint2			= xint[1];
						*yint2			= yint[1];
						*iface_int1		= iface_int[0];
						*iface_int2		= iface_int[1];
//						if( c == 1795 )
//						 {
	//						 Message(" LINSEG (3)  %u %.15f %.15f %.15f %.15f \n", c, *xint1,*xint2,*yint1,*yint2 );
//						 }
				}

		/* ====== test bottom ====== */
				ytest = ya;
				xtest = slopi*( ytest - yi ) + xi;
	//			Message("bottom nx, ny, slope, slopi, ytest, xtest = %u %f %f %f %f %f %f \n ", c, nx, ny, slope, slopi, ytest, xtest);
			    if(  ( xtest >= xl )  &&  ( xtest <= xr ) )
				{ 
//					Message("4 \n");
						nint					= nint + 1;
						xint[nint - 1]			= xtest;
						yint[nint - 1]			= ytest;
						iface_int[nint - 1]	= 1;
						*xint1			= xint[0];
						*yint1			= yint[0];
						*xint2			= xint[1];
						*yint2			= yint[1];
						*iface_int1		= iface_int[0];
						*iface_int2		= iface_int[1];
//						if( c == 1795 )
//						 {
	//						 Message(" LINSEG (4)  %u %.15f %.15f %.15f %.15f \n", c, *xint1,*xint2,*yint1,*yint2 );
//						 }
				}



		/* ====== test left ======= */
				if (  nint == 2  ) 
				{
					goto Hello;
				}
				xtest = xl ;
				ytest = slope*( xtest - xi ) + yi;
	//			Message("left nx, ny, slope, slopi, xtest, ytest = %u %f %f %f %f %f %f \n ", c, nx, ny, slope, slopi, xtest, ytest);
				if(  ( ytest >= ya )  &&  ( ytest <= yf  ) )
				{
//					Message("5 \n");
						nint					= nint + 1;
						xint[nint - 1]			= xtest;
						yint[nint - 1]			= ytest;
						iface_int[nint - 1]		= 4;
						*xint1					= xint[0];
						*yint1					= yint[0];
						*xint2					= xint[1];
						*yint2					= yint[1];
						*iface_int1				= iface_int[0];
						*iface_int2				= iface_int[1];
						
//						if( c == 1795 )
//						 {
	//						 Message(" LINSEG (5)  %u %.15f %.15f %.15f %.15f \n", c, *xint1,*xint2,*yint1,*yint2 );
//						 }

						if(  nint  == 2  )
						{
							dot_prod_old = ( (xint[0])- xi )*tx + ( (yint[0])- yi )*ty;
							dot_prod_new = ( xtest  - xi )*tx + ( ytest  - yi )*ty;
							if ( dot_prod_new*dot_prod_old > 0.0 )
							{
								 nint = nint - 1;
							}
						}
				}
		/* ====== test right ====== */
				if (  nint == 2  ) 
				{
					goto Hello;
				}
				xtest = xr ;
				ytest = slope*( xtest - xi ) + yi;
	//			Message(" right nx, ny, slope, slopi, ytest, xtest = %u %f %f %f %f %f %f \n ", c, nx, ny, slope, slopi, xtest, ytest);
				if(  ( ytest >= ya )  &&  ( ytest <= yf ) )
				{
//					Message("6 \n");
					nint					= nint + 1;
					xint[nint - 1]			= xtest;
					yint[nint - 1]			= ytest;
					iface_int[nint - 1]		= 2;
					*xint1					= xint[0];
					*yint1					= yint[0];
					*xint2					= xint[1];
					*yint2					= yint[1];
					*iface_int1				= iface_int[0];
					*iface_int2				= iface_int[1];
//						if( c == 1795 )
//						 {
	//						 Message(" LINSEG (6)  %u %.15f %.15f %.15f %.15f \n", c, *xint1,*xint2,*yint1,*yint2 );
//						 }
				}
		/* ===== end of end-point switch statements ===== */
	   Hello: ;
		}
//		Message(" LINSEG %u %.15f %.15f %.15f %.15f \n", c, *xint1,*xint2,*yint1,*yint2 );

//		Message(" c, (*xint1), (*xint2), (*yint1), (*yint2), len, nx, ny, nint, iface_int[0] , iface_int[1] = %u %.15f %.15f %.15f %.15f %.15f %f %f %d %d %d \n " , c, (*xint1), (*xint2), (*yint1), (*yint2), len, nx, ny, nint, iface_int[0] , iface_int[1] );
//		Message(" c, nint, iface_int[0] , iface_int[1] = %u %d %d %d \n " , c, nint, iface_int[0] , iface_int[1] );
		


}




/*--------- chk_neighb() function ----------- */
/*    This function checks whether for a given cell( i.e c,t)
its neighbours in 3*3 matrix are liquid or vapour. It  retruns TRUE or FALSE value.
  */
// IMPORTANT NOTE: In This Macro Boundary cells are not considered. SO if we are not considering boundary cells then this part becomes grid geometry independent. 
//  But if in future we include boundary cells as well then This part needs to be changed for different geometry.
extern void 
chk_neighb(cell_t c,Thread *t,int iphs,cxboolean *chk_phs )
{
	Thread *t_vapour = THREAD_SUB_THREAD(t,1);
	/* =============== DECLARATION FOR NEIGHBOURING CELL  ================= */
	cell_t cnb;
	cell_t cr, cf, cl, ca, crf, cra, clf, cla ;
	Thread *tf, *ta, *tr, *tl, *trf, *tra, *tlf, *tla ;

	face_t fr,ff,fl,fa,ffr,far,ffl,fal,frp,flp,frm,flm;
	Thread *tfr, *tff, *tfl, *tfa, *tffr, *tfar, *tffl, *tfal, *tfrp, *tflp, *tfrm, *tflm;
	Thread *t_f;
	Thread *t_fr, *t_ff, *t_fl, *t_fa;
	Node *node;
	int rr, cc, N,r,l,f,a, n;
	real toll, tolg;
	cxboolean check_r ;
	cxboolean check_f ;
	cxboolean check_l ;
	cxboolean check_a ;

	check_r = FALSE;
	check_f = FALSE;
	check_l = FALSE;
	check_a = FALSE;
	*chk_phs = TRUE;
	/* ------------------------------------------------------------------------------------ */
	

//	chek_neighb(c, t, iphs) = TRUE;

	/* ============================ NEIGHBOUR SEARCH PROGRAM ============================= */
	
	t_f = C_FACE_THREAD(c,t,0);
	
	if(BOUNDARY_FACE_THREAD_P(t_f))
	{
		/*
			c_node_loop(c,t,n)
	        {
			  node = C_NODE(c,t,n);
 		 
	
				if( NODE_X(node) == 0 )
				{
					fr = C_FACE(c,t,2);
					tfr = C_FACE_THREAD(c,t,2);
					fl = C_FACE(c,t,0);					
					tfl = C_FACE_THREAD(c,t,0);			
					ff = C_FACE(c,t,3);					
					tff = C_FACE_THREAD(c,t,3);
					fa = C_FACE(c,t,1);
					tfa = C_FACE_THREAD(c,t,1);
				}

				if( NODE_X(node)*1000000 == 1135 )
				{
					fr = C_FACE(c,t,0);
					tfr = C_FACE_THREAD(c,t,0);
					fl = C_FACE(c,t,2);					
					tfl = C_FACE_THREAD(c,t,2);			
					ff = C_FACE(c,t,1);					
					tff = C_FACE_THREAD(c,t,1);
					fa = C_FACE(c,t,3);
					tfa = C_FACE_THREAD(c,t,3);
				}

				if( NODE_Y(node) == 0 )
				{
					fr = C_FACE(c,t,1);
					tfr = C_FACE_THREAD(c,t,1);
					fl = C_FACE(c,t,3);					
					tfl = C_FACE_THREAD(c,t,3);			
					ff = C_FACE(c,t,2);					
					tff = C_FACE_THREAD(c,t,2);
					fa = C_FACE(c,t,0);
					tfa = C_FACE_THREAD(c,t,0);
				}

				if( NODE_Y(node)*100000 == 227 )
				{
					fr = C_FACE(c,t,3);
					tfr = C_FACE_THREAD(c,t,3);
					fl = C_FACE(c,t,1);					
					tfl = C_FACE_THREAD(c,t,1);			
					ff = C_FACE(c,t,0);					
					tff = C_FACE_THREAD(c,t,0);
					fa = C_FACE(c,t,2);
					tfa = C_FACE_THREAD(c,t,2);
				}		
			}
			*/
	}
	else
	{
				fr = C_FACE(c,t,1);
				tfr = C_FACE_THREAD(c,t,1);
				fl = C_FACE(c,t,3);					/* --------------------- FOR ---------------------- */
				tfl = C_FACE_THREAD(c,t,3);			/* ------------------ INTERIOR -------------------- */ 
				ff = C_FACE(c,t,2);					/* -------------------- CELLS --------------------- */
				tff = C_FACE_THREAD(c,t,2);
				fa = C_FACE(c,t,0);
				tfa = C_FACE_THREAD(c,t,0);

	
			/* ----------- RIGHT FACE ----------- */

				cr = F_C0(fr,tfr);
				if(cr == c)
				{
					cr = F_C1(fr,tfr);
					tr = F_C1_THREAD(fr,tfr);
				}
				else
				{
					tr = F_C0_THREAD(fr,tfr);
				}   

			/* ----------- LEFT FACE ------------ */

				cl = F_C0(fl,tfl);
				if(cl == c)
				{
					cl = F_C1(fl,tfl);
					tl = F_C1_THREAD(fl,tfl);
				}
				else
				{
					tl = F_C0_THREAD(fl,tfl);
				}

			/* ----------- FRONT FACE ------------ */

				cf = F_C0(ff,tff);
				if(cf == c)
				{
					cf = F_C1(ff,tff);
					tf = F_C1_THREAD(ff,tff);
				}
				else
				{
					tf = F_C0_THREAD(ff,tff);
				}

			/* ------------ AFTER FACE ------------ */

				ca = F_C0(fa,tfa);
				if(ca == c)
				{
					ca = F_C1(fa,tfa);
					ta = F_C1_THREAD(fa,tfa);
				}
				else
				{
					ta = F_C0_THREAD(fa,tfa);
				}
		//		Message(" ca = %u \n ", ca);
		//	}
	
				c_face_loop(cr,tr,N)
				{
					t_fr = C_FACE_THREAD(cr,tr,N);
					if( BOUNDARY_FACE_THREAD_P(t_fr) )
					{
						check_r = TRUE;
					}
				}

				c_face_loop(cf,tf,N)
				{
					t_ff = C_FACE_THREAD(cf,tf,N);
					if( BOUNDARY_FACE_THREAD_P(t_ff) )
					{
						check_f = TRUE;
					}
				}

				c_face_loop(cl,tl,N)
				{
					t_fl = C_FACE_THREAD(cl,tl,N);
					if( BOUNDARY_FACE_THREAD_P(t_fl) )
					{
						check_l = TRUE;
					}
				}

				c_face_loop(ca,ta,N)
				{
					t_fa = C_FACE_THREAD(ca,ta,N);
					if( BOUNDARY_FACE_THREAD_P(t_fa) )
					{
						check_a = TRUE;
					}
				}				

		if( check_r )
		{
//			Message(" BOUNDARY CELL ENCOUNTERED \n ");
			

				ffr = C_FACE(cr,tr,1);
				tffr = C_FACE_THREAD(cr,tr,1);

				far = C_FACE(cr,tr,3);
				tfar = C_FACE_THREAD(cr,tr,3);

				ffl = C_FACE(cl,tl,2);
				tffl = C_FACE_THREAD(cl,tl,2);

				fal = C_FACE(cl,tl,0);
				tfal = C_FACE_THREAD(cl,tl,0);

			/* ======================== (crf,trf) ============================= */

				crf = F_C0(ffr,tffr);
				if(crf == cr)
				{
					crf = F_C1(ffr,tffr);
					trf = F_C1_THREAD(ffr,tffr);
				}
				else
				{
					trf = F_C0_THREAD(ffr,tffr);
				}
	//			Message(" crf = %u \n ", crf);
			/* ======================== (cra,tra) ============================= */

				cra = F_C0(far,tfar);
				if(cra == cr)
				{
					cra = F_C1(far,tfar);
					tra = F_C1_THREAD(far,tfar);
				}
				else
				{
					tra = F_C0_THREAD(far,tfar);
				}
	//			Message(" cra = %u \n ", cra);	
			/* ======================== (clf,tlf) ============================= */

				clf = F_C0(ffl,tffl);
				if(clf == cl)
				{
					clf = F_C1(ffl,tffl);
					tlf = F_C1_THREAD(ffl,tffl);
				}
				else
				{
					tlf = F_C0_THREAD(ffl,tffl);
				}
	//			Message(" clf = %u \n ", clf);
			/* ======================== (cla,tla) ============================= */

				cla = F_C0(fal,tfal);
				if(cla == cl)
				{
					cla = F_C1(fal,tfal);
					tla = F_C1_THREAD(fal,tfal);
				}
				else
				{
					tla = F_C0_THREAD(fal,tfal);
				}
	//			Message(" cla = %u \n ", cla);
		
		}
		else if ( check_f )
		{
			
				frp = C_FACE(cf,tf,3);
				tfrp = C_FACE_THREAD(cf,tf,3);

				flp = C_FACE(cf,tf,1);
				tflp = C_FACE_THREAD(cf,tf,1);

				frm = C_FACE(ca,ta,1);
				tfrm = C_FACE_THREAD(ca,ta,1);

				flm = C_FACE(ca,ta,3);
				tflm = C_FACE_THREAD(ca,ta,3);

			/* ======================== (crf,trf) ============================= */

				crf = F_C0(frp,tfrp);
				if(crf == cr)
				{
					crf = F_C1(frp,tfrp);
					trf = F_C1_THREAD(frp,tfrp);
				}
				else
				{
					trf = F_C0_THREAD(frp,tfrp);
				}

			/* ======================== (clf,tlf) ============================= */

				clf = F_C0(flp,tflp);
				if(clf == cl)
				{
					clf = F_C1(flp,tflp);
					tlf = F_C1_THREAD(flp,tflp);
				}
				else
				{
					tlf = F_C0_THREAD(flp,tflp);
				}

			/* ======================== (cra,tra) ============================= */

				cra = F_C0(frm,tfrm);
				if(cra == cr)
				{
					cra = F_C1(frm,tfrm);
					tra = F_C1_THREAD(frm,tfrm);
				}
				else
				{
					tra = F_C0_THREAD(frm,tfrm);
				}

			/* ======================== (cla,tla) ============================= */

				cla = F_C0(flm,tflm);
				if(cla == cl)
				{
					cla = F_C1(flm,tflm);
					tla = F_C1_THREAD(flm,tflm);
				}
				else
				{
					tla = F_C0_THREAD(flm,tflm);
				}
			
		}
		else if ( check_l ) 
		{
			
				ffl = C_FACE(cl,tl,3);
				tffl = C_FACE_THREAD(cl,tl,3);

				fal = C_FACE(cl,tl,1);
				tfal = C_FACE_THREAD(cl,tl,1);

				ffr = C_FACE(cr,tr,2);
				tffr = C_FACE_THREAD(cr,tr,2);

				far = C_FACE(cr,tr,0);
				tfar = C_FACE_THREAD(cr,tr,0);

			/* ======================== (crf,trf) ============================= */

				crf = F_C0(ffr,tffr);
				if(crf == cr)
				{
					crf = F_C1(ffr,tffr);
					trf = F_C1_THREAD(ffr,tffr);
				}
				else
				{
					trf = F_C0_THREAD(ffr,tffr);
				}
	//			Message(" crf = %u \n ", crf);
			/* ======================== (cra,tra) ============================= */

				cra = F_C0(far,tfar);
				if(cra == cr)
				{
					cra = F_C1(far,tfar);
					tra = F_C1_THREAD(far,tfar);
				}
				else
				{
					tra = F_C0_THREAD(far,tfar);
				}
	//			Message(" cra = %u \n ", cra);	
			/* ======================== (clf,tlf) ============================= */

				clf = F_C0(ffl,tffl);
				if(clf == cl)
				{
					clf = F_C1(ffl,tffl);
					tlf = F_C1_THREAD(ffl,tffl);
				}
				else
				{
					tlf = F_C0_THREAD(ffl,tffl);
				}
	//			Message(" clf = %u \n ", clf);
			/* ======================== (cla,tla) ============================= */

				cla = F_C0(fal,tfal);
				if(cla == cl)
				{
					cla = F_C1(fal,tfal);
					tla = F_C1_THREAD(fal,tfal);
				}
				else
				{
					tla = F_C0_THREAD(fal,tfal);
				}
	//			Message(" cla = %u \n ", cla);
		
			
		}
		else if ( check_a )
		{
			
				frm = C_FACE(ca,ta,1);
				tfrm = C_FACE_THREAD(ca,ta,1);

				flm = C_FACE(ca,ta,3);
				tflm = C_FACE_THREAD(ca,ta,3);

				frp = C_FACE(cf,tf,1);
				tfrp = C_FACE_THREAD(cf,tf,1);

				flp = C_FACE(cf,tf,3);
				tflp = C_FACE_THREAD(cf,tf,3);
			
			/* ======================== (crf,trf) ============================= */

				crf = F_C0(frp,tfrp);
				if(crf == cr)
				{
					crf = F_C1(frp,tfrp);
					trf = F_C1_THREAD(frp,tfrp);
				}
				else
				{
					trf = F_C0_THREAD(frp,tfrp);
				}

			/* ======================== (clf,tlf) ============================= */

				clf = F_C0(flp,tflp);
				if(clf == cl)
				{
					clf = F_C1(flp,tflp);
					tlf = F_C1_THREAD(flp,tflp);
				}
				else
				{
					tlf = F_C0_THREAD(flp,tflp);
				}

			/* ======================== (cra,tra) ============================= */

				cra = F_C0(frm,tfrm);
				if(cra == cr)
				{
					cra = F_C1(frm,tfrm);
					tra = F_C1_THREAD(frm,tfrm);
				}
				else
				{
					tra = F_C0_THREAD(frm,tfrm);
				}

			/* ======================== (cla,tla) ============================= */

				cla = F_C0(flm,tflm);
				if(cla == cl)
				{
					cla = F_C1(flm,tflm);
					tla = F_C1_THREAD(flm,tflm);
				}
				else
				{
					tla = F_C0_THREAD(flm,tflm);
				}
		}
		else
		{
/* ============== DEFINITION OF SECONDARY NEIGHBOURS ============== */

 
			ffr = C_FACE(cr,tr,2);
			tffr = C_FACE_THREAD(cr,tr,2);

			far = C_FACE(cr,tr,0);
			tfar = C_FACE_THREAD(cr,tr,0);

			ffl = C_FACE(cl,tl,2);
			tffl = C_FACE_THREAD(cl,tl,2);

			fal = C_FACE(cl,tl,0);
			tfal = C_FACE_THREAD(cl,tl,0);

//		Message("  far, tfar, ffl, tffl, fal, tfal =  %u %u %u %u %u %u  \n ", far, tfar, ffl, tffl, fal, tfal); 

		

		/* ======================== (crf,trf) ============================= */

			crf = F_C0(ffr,tffr);
			if(crf == cr)
			{
				crf = F_C1(ffr,tffr);
				trf = F_C1_THREAD(ffr,tffr);
			}
			else
			{
				trf = F_C0_THREAD(ffr,tffr);
			}
//			Message(" crf = %u \n ", crf);
		/* ======================== (cra,tra) ============================= */

			cra = F_C0(far,tfar);
			if(cra == cr)
			{
				cra = F_C1(far,tfar);
				tra = F_C1_THREAD(far,tfar);
			}
			else
			{
				tra = F_C0_THREAD(far,tfar);
			}
//			Message(" cra = %u \n ", cra);	
		/* ======================== (clf,tlf) ============================= */

			clf = F_C0(ffl,tffl);
			if(clf == cl)
			{
				clf = F_C1(ffl,tffl);
				tlf = F_C1_THREAD(ffl,tffl);
			}
			else
			{
				tlf = F_C0_THREAD(ffl,tffl);
			}
//			Message(" clf = %u \n ", clf);
		/* ======================== (cla,tla) ============================= */

			cla = F_C0(fal,tfal);
			if(cla == cl)
			{
				cla = F_C1(fal,tfal);
				tla = F_C1_THREAD(fal,tfal);
			}
			else
			{
				tla = F_C0_THREAD(fal,tfal);
			}
//			Message(" cla = %u \n ", cla);
		
		}
	/* ------------------------ END OF NEIGHBOUR SEARCH PROGRAM ------------------------ */

			if (iphs == 3)
			{
				for (rr = -1; rr < 1; rr++)
				for (cc = -1; cc < 1; cc++)
				{
					if( rr == - 1 && cc == -1 )
					{
						cnb = clf;
					}
					else if( rr == - 1 && cc == 0 )
					{	
						cnb = cf;
					}
					else if( rr == - 1 && cc == 1 )
					{
						cnb = crf;
					}
					else if( rr == 0 && cc == -1 )
					{
						cnb = cl;
					}
					else if( rr == 0 && cc == 0 )
					{
					goto chkphs1;
					}
					else if( rr == 0 && cc == 1 )
					{	
						cnb = cr;
					}
					else if( rr ==  1 && cc == -1 )
					{
						cnb = cla;
					}
					else if( rr ==  1 && cc == 0 )
					{
						cnb = ca;
					}
					else if( rr ==  1 && cc == 1 )
					{
						cnb = cra;
					}
				
					if (C_VOF(cnb,t_vapour) < 0.5)
					{
						*chk_phs = FALSE;
						
					}
			
			chkphs1: ;

				}
			}
			else if (iphs == 1)
			{
				for (rr = -1; rr < 1; rr++)
				for (cc = -1; cc < 1; cc++)
				{
					if( rr == - 1 && cc == -1 )
					{
						cnb = clf;
					}
					else if( rr == - 1 && cc == 0 )
					{	
						cnb = cf;
					}
					else if( rr == - 1 && cc == 1 )
					{
						cnb = crf;
					}
					else if( rr == 0 && cc == -1 )
					{
						cnb = cl;
					}
					else if( rr == 0 && cc == 0 )
					{
					goto chkphs2;
					}
					else if( rr == 0 && cc == 1 )
					{	
						cnb = cr;
					}
					else if( rr ==  1 && cc == -1 )
					{
						cnb = cla;
					}
					else if( rr ==  1 && cc == 0 )
					{
						cnb = ca;
					}
					else if( rr ==  1 && cc == 1 )
					{
						cnb = cra;
					}
				
					if (C_VOF(cnb,t_vapour) > 0.5)
					{
						*chk_phs = FALSE;
						
					}
			
			chkphs2: ;

				}
			}
	//		else
	//		{
	//			*chk_phs = TRUE;
	//			return;
	//		}
		return;
	}	
	

}




/*--------- FCT(direction split) algorithm of RUDMAN.   ----------- */
/*
This is used for tracking interface. 
Refer FORTRAN CODE(film.f file) and above mentioned paper for further clarification.
  */

// IMPORTANT NOTE: In This Macro Boundary cells are not considered. SO if we are not considering boundary cells then this part becomes grid geometry independent. 
//  But if in future we include boundary cells as well then This part needs to be changed for different geometry.
DEFINE_EXECUTE_AT_END(density_moveit_MODIFIED)
{
#if !RP_HOST
	Domain *domain = Get_Domain(1);
	Domain *sd = DOMAIN_SUB_DOMAIN(domain , 0); 
	Thread *t;
	cell_t c;
	Thread *t_liquid, *t_vapour;

	/* ----------------------------------------------------- DECLARATION OF densty subroutine ---------------------------------- */

	face_t fa, fr, ff, fl, ffr, far, ffl, fal,frp,flp,frm,flm;
	Thread *tfr, *tff, *tfl, *tfa, *tffr, *tfar, *tffl, *tfal, *tfrp, *tflp, *tfrm, *tflm;
	cell_t cr, cf, cl, ca, crf,cra,clf,cla;
	Thread *tr, *tf, *tl, *ta, *trf,*tra,*tlf,*tla;
	Thread *t_f;
	
	cell_t *cell;
	Thread  *threadf, *threadface;
	Thread *t_fr, *t_ff, *t_fl, *t_fa;

	Node *node;

	real ur,ul,vf,va;
	real flux  , rlflux, rgflux;
	real aflux , afluy ;
	real xflux , yflux , xc , xcflx;
	real lvol  , gvol  , dvol  , vol   , ftol;
	real dx, dy,  len;				//	nx, ny,
	real X[ND_ND], xfr[ND_ND], xff[ND_ND], xfl[ND_ND], xfa[ND_ND];
	real xl, xr, yf, ya;
	int idirex, id1, id2, iphs,n , iphsr, iphsl, iphsf, iphsa, itrn;
	real nx, ny;
	/* ---------------------------------------------- END OF densty subroutine DECLARATION --------------------------------------- */


	/* ----------------------------------------------------- DECLARATION OF moveit subroutine ---------------------------------- */
	int iphas, iphsn, istep, iphasn, itran;
	real toll, tolg;
	cxboolean bulkl, bulkg;
	real dvoid, sourcv, sourcl, tolv , xmax, xmin , rmag, tempn;
	/* ---------------------------------------------- END OF moveit subroutine DECLARATION --------------------------------------- */

	/* ----------------------------------------------------- DECLARATION OF iface(fortran) subroutine ---------------------------------- */

	float XS[3];
	int i,nr,nl,nf,na,N,r,l,f,a,k;
	real XC[ND_ND],xcr[ND_ND];
	
	cxboolean check_r ;
	cxboolean check_f ;
	cxboolean check_l ;
	cxboolean check_a ;
	cxboolean boundary ;
	cxboolean INF;
	real ax, ay;
	real fe,fw,fn,fs;
	real rmag2;

	int niter,itermx,maxiter,ifter;
	real nxy, nyy, sleny;
	real thetay, thetal;
	real Gfunp , Gerr, theta, dtheta, theta_inc;
	real Gfunpr, Gprime, thetar, nxr, nyr;
	real save_len[3][3], save_nx[3][3], save_ny[3][3];
	/* ------------------------------------------------ END OF iface(fortran) subroutine DECLARATION --------------------------------------- */
				   ftol = pow(10., -12);
				   id1 = 1;
				   id2 = 2;
				   tolg = pow(10.,-8);
				   toll = pow(10.,-8);


// densty(id1)
	thread_loop_c(t,domain)
	{
		begin_c_loop(c,t)
		{
		   t_liquid = THREAD_SUB_THREAD(t,0);
		   t_vapour = THREAD_SUB_THREAD(t,1);
		   
		   t_f = C_FACE_THREAD(c,t,0);
		   idirex = id1;

//		 ax =  C_VOF_G(c,t_liquid)[0]/sqrt( (C_VOF_G(c,t_liquid)[0])*(C_VOF_G(c,t_liquid)[0]) + (C_VOF_G(c,t_liquid)[1])*(C_VOF_G(c,t_liquid)[1])  ) ;
//		 ay =  C_VOF_G(c,t_liquid)[1]/sqrt( (C_VOF_G(c,t_liquid)[0])*(C_VOF_G(c,t_liquid)[0]) + (C_VOF_G(c,t_liquid)[1])*(C_VOF_G(c,t_liquid)[1])  ) ;

		   nx = C_UDMI(c,t,2);
		   ny = C_UDMI(c,t,3);
						
	//	   Message(" End c, nx, ny, ax, ay = %u %f %f %f %f \n ", c, nx, ny, ax, ay);

//		   Message("c , slen = %u %.15f \n", c, C_UDMI(c,t,4) );

		   				if(BOUNDARY_FACE_THREAD_P(t_f))
						{
																	// Boundary Cells not considered here. SO This part becomes grid geometry independent.
						}
						else
						{
	
							fr = C_FACE(c,t,1);
							tfr = C_FACE_THREAD(c,t,1);
							fl = C_FACE(c,t,3);					/* --------------------- FOR ---------------------- */
							tfl = C_FACE_THREAD(c,t,3);			/* ------------------ INTERIOR -------------------- */ 
							ff = C_FACE(c,t,2);					/* -------------------- CELLS --------------------- */
							tff = C_FACE_THREAD(c,t,2);
							fa = C_FACE(c,t,0);
							tfa = C_FACE_THREAD(c,t,0);
	
	

							/* ----------- RIGHT FACE ----------- */

							cr = F_C0(fr,tfr);
							if(cr == c)
							{
								cr = F_C1(fr,tfr);
								tr = F_C1_THREAD(fr,tfr);
							}
							else
							{
								tr = F_C0_THREAD(fr,tfr);
							}   

						/* ----------- LEFT FACE ------------ */

							cl = F_C0(fl,tfl);
							if(cl == c)
							{
								cl = F_C1(fl,tfl);
								tl = F_C1_THREAD(fl,tfl);
							}
							else
							{
								tl = F_C0_THREAD(fl,tfl);
							}

						/* ----------- FRONT FACE ------------ */

							cf = F_C0(ff,tff);
							if(cf == c)
							{
								cf = F_C1(ff,tff);
								tf = F_C1_THREAD(ff,tff);
							}
							else
							{
								tf = F_C0_THREAD(ff,tff);
							}



						/* ------------ AFTER FACE ------------ */

							ca = F_C0(fa,tfa);
							if(ca == c)
							{
								ca = F_C1(fa,tfa);
								ta = F_C1_THREAD(fa,tfa);
							}
							else
							{
								ta = F_C0_THREAD(fa,tfa);
							}
	
	

						delta( c, t, &dx, &dy );

						vol = dx*dy;
	
						ur = C_U(c,t);
						ul = F_U(cl,t);
						vf = C_V(c,t);
						va = F_V(ca ,t);
	
					//	Message(" ur = %f \n ", ur);
					//	Message(" ul = %f \n ", ul);
					//	Message(" vf = %f \n ", vf);
					//	Message(" va = %f \n ", va);		
			
								C_CENTROID(X,c,t);
			
								F_CENTROID(xfr,fr,tfr);
								F_CENTROID(xff,ff,tff);
								F_CENTROID(xfl,fl,tfl);
								F_CENTROID(xfa,fa,tfa);

	//		Message(" DENSTY: c,0,1,2,3,4,5 = %u %g %g %g %g %g %g \n", c, C_UDMI(c,t,0), C_UDMI(c,t,1), C_UDMI(c,t,2), C_UDMI(c,t,3), C_UDMI(c,t,4), C_UDMI(c,t,5));
	//		Message("c, xf, xa, ff, fa, tff, tfa = %u %f %f %u %u %u %u \n", c, xff[1], xfa[1], ff, fa, tff, tfa);

								xr = xfr[0] ;
								yf = xff[1] ;
								xl = xfl[0] ;
								ya = xfa[1] ;

						delta( c, t, &dx, &dy );
						iphs = C_UDMI(c,t,1); //iphase[c];;
			//			Message(" ur, iphs, c = %f %d %u \n ", ur, iphs, c );		
//						nx = C_UDMI(c,t,2);
//						ny = C_UDMI(c,t,3);
						
//						Message(" linseg c, nx, ny = %u %f %f \n ", c, nx, ny);

			//			Message(" ur, ul, vf, va = %f %f %f %f \n ", ur, ul, vf, va );

									 /* if u(i,j) >= 0 this cell will flux its material into the next cell */
									 if (ur > 0 )
									 {
								//		 Message(" ur, iphs = %f %d \n ", ur, iphs );
										rlflux = 0.0;
										rgflux = 0.0;

										F_CENTROID(xfr, fr, tr);
										aflux = ur * CURRENT_TIMESTEP;

										xflux = xfr[0] - aflux;

										dvol = aflux*dy;

										if (iphs != 2) //( C_UDSI(c,t,0) != 2)
										{
											flux = C_R_M1(c,t) * dvol;
											if (iphs == 1) //( C_UDSI(c,t,0) == 1 )
											{
												rlflux = flux;
											}
											else
											{
												rgflux = flux;
											}
										goto densty1;
										}
								//		else
								//		{

							//		 get_len(c, t_liquid, nx, ny , &len);
										len =	C_UDMI(c,t,4);		//	-8.48917e-06;
				//					Message("c , slen = %u %.15f \n", c, C_UDMI(c,t,4) );
									 lgvol( c, t_liquid, xflux, xr, ya, yf, &lvol );
				//					 Message(" c, xflux, xr, ya, yf = %u %g %g %g %g  \n", c, xflux, xr, ya, yf );
				//					 Message(" c, ur, len, lvol(ur), dvol,  nx1, ny1, N_ITER= %u %g %g %g %g %g %g %d \n", c, ur, len, lvol, dvol, nx, ny, N_ITER );
									 iphsr = C_UDMI(cr,tr,1);
									 if( lvol == 0 && iphsr == 1 ) 
									 {
										 lvol = dvol;
									 }
									 gvol = dvol - lvol;

									 rlflux = lvol * ROL;                  
									 rgflux = gvol * ROG;

									 if( fabs(rlflux) > ftol  && fabs(rgflux) > ftol )
									 {
				//					    Message(" 1_densty(id1) = %f \n ");
				//						itran[cr] = 1; // C_UDSI(cr,tr,1) = 1;  
										C_UDMI(cr,tr,0) = 1; // itran[cr];
									 }
								//		}

									 densty1:  ;

									 flux = (rlflux + rgflux) / vol;

									 C_R(cr,tr) += flux;
							//		 Message(" C_R(cr,tr) = %f \n ", C_R(cr,tr));
									 C_R(c,t)   -= flux;
									 }

									 /* if u(i-1,j) < 0 this cell will flux its material into the previous cell */

									 if (ul < 0 )
									 {
										rlflux = 0.0;
										rgflux = 0.0;


										aflux = - ul * CURRENT_TIMESTEP;
										xflux  = xfl[0] + aflux;

										dvol = aflux*dy;

										if (iphs != 2) //( C_UDSI(c,t,0) != 2)
										{
											flux = C_R_M1(c,t) * dvol;
											if (iphs == 1) //( C_UDSI(c,t,0) == 1 )
											{
												rlflux = flux;
											}
											else
											{
												rgflux = flux;
											}
										goto densty2;
										}
								//		else
								//		{
						//			 get_len(c, t_liquid, nx, ny , &len);
										len =  C_UDMI(c,t,4);	  //	 -8.48917e-06;
									 lgvol( c, t_liquid, xl, xflux, ya, yf, &lvol );
				//					 Message(" c, xl, xflux, ya, yf = %u %g %g %g %g  \n", c, xl, xflux, ya, yf );
				//					 Message(" c, ul, len, lvol(ul), dvol,  nx1, ny1, N_ITER = %u %g %g %g %g %g %g %d \n", c, ul, len, lvol, dvol, nx, ny, N_ITER);

									 iphsl = C_UDMI(cl,tl,1);
									 if( lvol == 0 && iphsl == 1 )
									 {
										 lvol = dvol;
									 }
									 gvol = dvol - lvol;

									 rlflux = lvol * ROL;                  
									 rgflux = gvol * ROG;

									 if( fabs(rlflux) > ftol  && fabs(rgflux) > ftol )
									 {
				//						 Message(" 2_densty(id1) = %f \n ");
					//					 itran[cl] = 1; // C_UDSI(cl,tl,1) = 1;  
										 C_UDMI(cl,tl,0) = 1; // itran[cl];
									 }
								//		}
									 densty2: ;

									 flux = (rlflux + rgflux) / vol;

									 C_R(cl,tl) += flux;
							//		 Message(" C_R(cl,tl) = %f \n ", C_R(cl,tl));
									 C_R(c,t)   -= flux;
									 }

								
						}
		
		}
		end_c_loop(c,t)
	}						
// moveit()	
	thread_loop_c(t,domain)
	{
		begin_c_loop(c,t)
		{
		   t_liquid = THREAD_SUB_THREAD(t,0);
		   t_vapour = THREAD_SUB_THREAD(t,1);
		   
		   t_f = C_FACE_THREAD(c,t,0);
		  
		   					  iphasn = C_UDMI(c,t,1); // iphas; // C_UDSI_M1(c,t,0);
						itran = C_UDMI(c,t,0);
					//		  if (itran == 1) //(C_UDSI(c,t,1) == 1 )
							if (itran == 1)
							  {
					//			  iphase[c] = 2; //C_UDSI(c,t,0) = 2;
								  C_UDMI(c,t,0) = itran;
								  C_UDMI(c,t,1) = 2;
							  }
	  
								chk_neighb(c,t,3,&bulkg);
        
							  if( bulkg ) 
							  { 
					//			  iphase[c] = 3; // C_UDSI(c,t,0) = 3;
								 C_UDMI(c,t,1) = 3;
							  }

							  chk_neighb(c,t,1, &bulkl );
        
			//				  Message(" 1 bulkg, bulkl = %u %u \n ", bulkg, bulkl);

							  if( bulkl ) 
							  {
					//			 iphase[c] = 1; // C_UDSI(c,t,0) = 1;
								 C_UDMI(c,t,1) = 1;
							  }

							  iphs = C_UDMI(c,t,1); //iphase[c];
								if (iphs == 1) //( C_UDSI(c,t,0) == 1 ) 
								{
				//					C_VOF(c,t_liquid) = 1.0;
				//					C_VOF(c,t_vapour) = 0.0 ;
				//					C_R(c,t_liquid) = ROL;
								}
								else if (iphs == 3) //( C_UDSI(c,t,0) == 3 ) 
								{
				//					C_VOF(c,t_liquid) = 0.0;
				//					C_VOF(c,t_vapour) = 1.0  ;
				//					  C_R(c,t_vapour) = ROG;	
								}
								else if( C_VOF(c,t_liquid) < tolg ) 
								{
						/*	        if( iphasn == 2 ) 
									{
										nmx( c, t_liquid, &nx, &ny);
										rmag = ( nx*nx + ny*ny );
										if( rmag > pow(10.,-3) ) 
										{
										  qint(c,t, FALSE, &sourcl, &sourcv, &tempn);
										  C_T(c,t) = tempn;
										}
										else
										{
										  C_T(c,t) = TSAT;
                  
										}
									}					*/

						//			 iphase[c] = 3; // C_UDSI(c,t,0) = 3;
									 C_UDMI(c,t,1) = 3;
				//					 C_VOF(c,t_vapour) = 1.0;
				//					 C_VOF(c,t_liquid) = 0.0;
				//					 C_R(c,t) = ROG;
								}
								else if( C_VOF(c,t_liquid) > 1.0-toll ) 
								{
						/*		   if( iphasn == 2 ) 
								   {	
										nmx( c, t_liquid, &nx, &ny);
										rmag = ( nx*nx + ny*ny );
										if( rmag > pow(10.,-3) ) 
										{
										  qint(c, t, TRUE, &sourcl, &sourcv, &tempn);
										  C_T(c,t) = tempn;
										}
										else
										{
										  C_T(c,t) = TSAT;
                  
										}
								   }						*/
					//				 iphase[c] = 1; // C_UDSI(c,t,0) = 1;  
									 C_UDMI(c,t,1) = 1;
					//				 C_VOF(c,t_vapour) = 0.0;
					//				 C_VOF(c,t_liquid) = 1.0;
					//				 C_R(c,t) = ROL;
								}
		
		}
		end_c_loop(c,t)
	}
	thread_loop_c(t,domain)
	{
		begin_c_loop(c,t)
		{
		   t_liquid = THREAD_SUB_THREAD(t,0);
		   t_vapour = THREAD_SUB_THREAD(t,1);
		   
			t_f = C_FACE_THREAD(c,t,0);
	
					if(BOUNDARY_FACE_THREAD_P(t_f))
					{
						/*
						c_node_loop(c,t,n)
						{
						  node = C_NODE(c,t,n);
 		 
	
							if( NODE_X(node) == 0 )
							{
								fr = C_FACE(c,t,2);
								tfr = C_FACE_THREAD(c,t,2);
								fl = C_FACE(c,t,0);					
								tfl = C_FACE_THREAD(c,t,0);			
								ff = C_FACE(c,t,3);					
								tff = C_FACE_THREAD(c,t,3);
								fa = C_FACE(c,t,1);
								tfa = C_FACE_THREAD(c,t,1);
							}

							if( NODE_X(node)*1000000 == 1135 )
							{
								fr = C_FACE(c,t,0);
								tfr = C_FACE_THREAD(c,t,0);
								fl = C_FACE(c,t,2);					
								tfl = C_FACE_THREAD(c,t,2);			
								ff = C_FACE(c,t,1);					
								tff = C_FACE_THREAD(c,t,1);
								fa = C_FACE(c,t,3);
								tfa = C_FACE_THREAD(c,t,3);
							}

							if( NODE_Y(node) == 0 )
							{
								fr = C_FACE(c,t,1);
								tfr = C_FACE_THREAD(c,t,1);
								fl = C_FACE(c,t,3);					
								tfl = C_FACE_THREAD(c,t,3);			
								ff = C_FACE(c,t,2);					
								tff = C_FACE_THREAD(c,t,2);
								fa = C_FACE(c,t,0);
								tfa = C_FACE_THREAD(c,t,0);
							}

							if( NODE_Y(node)*100000 == 227 )
							{
								fr = C_FACE(c,t,3);
								tfr = C_FACE_THREAD(c,t,3);
								fl = C_FACE(c,t,1);					
								tfl = C_FACE_THREAD(c,t,1);			
								ff = C_FACE(c,t,0);					
								tff = C_FACE_THREAD(c,t,0);
								fa = C_FACE(c,t,2);
								tfa = C_FACE_THREAD(c,t,2);
							}		
						}
								*/	
					}
					else
					{
		
								fr = C_FACE(c,t,1);
								tfr = C_FACE_THREAD(c,t,1);
								fl = C_FACE(c,t,3);					/* --------------------- FOR ---------------------- */
								tfl = C_FACE_THREAD(c,t,3);			/* ------------------ INTERIOR -------------------- */ 
								ff = C_FACE(c,t,2);					/* -------------------- CELLS --------------------- */
								tff = C_FACE_THREAD(c,t,2);
								fa = C_FACE(c,t,0);
								tfa = C_FACE_THREAD(c,t,0);

		
								/* ----------- RIGHT FACE ----------- */

								cr = F_C0(fr,tfr);
								if(cr == c)
								{
									cr = F_C1(fr,tfr);
									tr = F_C1_THREAD(fr,tfr);
								}
								else
								{
									tr = F_C0_THREAD(fr,tfr);
								}   
							/* ----------- LEFT FACE ------------ */

								cl = F_C0(fl,tfl);
								if(cl == c)
								{
									cl = F_C1(fl,tfl);
									tl = F_C1_THREAD(fl,tfl);
								}
								else
								{
									tl = F_C0_THREAD(fl,tfl);
								}
							/* ----------- FRONT FACE ------------ */

								cf = F_C0(ff,tff);
								if(cf == c)
								{
									cf = F_C1(ff,tff);
									tf = F_C1_THREAD(ff,tff);
								}
								else
								{
									tf = F_C0_THREAD(ff,tff);
								}

							/* ------------ AFTER FACE ------------ */
								ca = F_C0(fa,tfa);
								if(ca == c)
								{
									ca = F_C1(fa,tfa);
									ta = F_C1_THREAD(fa,tfa);
								}
								else
								{
									ta = F_C0_THREAD(fa,tfa);
								}
	

							iphs = C_UDMI(c,t,1); //iphase[c];; //C_UDSI(c,t,0);

							if( iphs != 1 ) 
							{
								goto moveit1;
							}
							if ( C_UDMI(cr,tr,1) != iphs && C_UDMI(cr,tr,1) != 2) //( C_UDSI(cr,tr,0) != iphs && C_UDSI(cr,tr,0) != 2) // ( iphase[cr] != iphs && iphase[cr] != 2)
							{
						//	  iphase[c] = 2; // C_UDSI(c,t,0) = 2;
							  C_UDMI(c,t,1) = 2;
						 //      C_VOF(c,t) = 1.0;
							}	

							if ( C_UDMI(cl,tl,1) != iphs && C_UDMI(cl,tl,1) != 2)  //( iphase[cl] != iphs && iphase[cl] != 2) //( C_UDSI(cl,tl,0) != iphs && C_UDSI(cl,tl,0) != 2)  
							{
						//		iphase[c] = 2; // C_UDSI(c,t,0) = 2;
								C_UDMI(c,t,1) = 2;
						//       C_VOF(c,t_liquid) = 1.0; 
							}

							if( C_UDMI(cf,tf,1) != iphs && C_UDMI(cf,tf,1) != 2) //( iphase[cf] != iphs && iphase[cf] != 2) //( C_UDSI(cf,tf,0) != iphs && C_UDSI(cf,tf,0) != 2)
							{
						//	   iphase[c] = 2; //C_UDSI(c,t,0) = 2;
							   C_UDMI(c,t,1) = 2;
						 //      C_VOF(c,t) = 1.0; 
							}

							if( C_UDMI(ca,ta,1) != iphs && C_UDMI(ca,ta,1) != 2)  // ( iphase[ca] != iphs && iphase[ca] != 2) //( C_UDSI(ca,ta,0) != iphs && C_UDSI(ca,ta,0) != 2)  
							{ 
						//	   iphase[c] = 2; //C_UDSI(c,t,0) = 2;
							   C_UDMI(c,t,1) = 2;
						//       C_VOF(c,t) = 1.0; 
							}
	  
					//	  Message(" iphase = %f \n ", C_UDMI(c,t,0));
						moveit1: ;
					}
		  
		}
		end_c_loop(c,t)
	}
// iface()
	thread_loop_c(t,domain)
	{
		if (FLUID_THREAD_P(t))
		{
			begin_c_loop_all(c,t)
			{
					check_r = FALSE;
					check_f = FALSE;
					check_l = FALSE;
					check_a = FALSE;
					boundary = FALSE;

				t_liquid = THREAD_SUB_THREAD(t,0);

				iphs = C_UDMI(c,t,1); //iphase[c];;

				if ( iphs != 2 )
				{
		//			Message(" Single phase cell \n");
					goto IFACE1_END;
				}
				else
				{
		//			Message(" Mixture phase cell \n");
					t_f = C_FACE_THREAD(c,t,0);
	
					if(BOUNDARY_FACE_THREAD_P(t_f))
					{				// Boundary Cells not considered here. SO This part becomes grid geometry independent.		
						boundary = TRUE;
																										
				/*			c_node_loop(c,t,a)
							{
										  node = C_NODE(c,t,a);

								if( NODE_Y(node) == 0 )
								{

									if( NODE_X(node) == 0 )
									{
											ff = C_FACE(c,t,3);					
											tff = C_FACE_THREAD(c,t,3);
											
											fr = C_FACE(c,t,2);
											tfr = C_FACE_THREAD(c,t,2);

//										 ----------- RIGHT FACE ----------- 

											cr = F_C0(fr,tfr);
											if(cr == c)
											{
												cr = F_C1(fr,tfr);
												tr = F_C1_THREAD(fr,tfr);
											}
											else
											{
												tr = F_C0_THREAD(fr,tfr);
											}   
//										 ----------- FRONT FACE ------------ 

											cf = F_C0(ff,tff);
											if(cf == c)
											{
												cf = F_C1(ff,tff);
												tf = F_C1_THREAD(ff,tff);
											}
											else
											{
												tf = F_C0_THREAD(ff,tff);
											}

											frp = C_FACE(cf,tf,2);
											tfrp = C_FACE_THREAD(cf,tf,2);

//										 ----------- crf cell ----------- 

											crf = F_C0(frp,tfrp);
											if(crf == cf)
											{
												crf = F_C1(frp,tfrp);
												trf = F_C1_THREAD(frp,tfrp);
											}
											else
											{
												trf = F_C0_THREAD(frp,tfrp);
											}   


										fe = (1.0/4.0)*(0.0 + 2*C_VOF(cr,t_liquid) + C_VOF(crf,t_liquid));     
										fw = (1.0/4.0)*(0.0);
										fn = (1.0/4.0)*(0.0 + 2*C_VOF(cf,t_liquid) + C_VOF(crf,t_liquid));
										fs = (1.0/4.0)*(0.0);


									}
									else if( NODE_X(node)*1000000 ==   1135 )
									{
											ff = C_FACE(c,t,2);					
											tff = C_FACE_THREAD(c,t,2);

											fl = C_FACE(c,t,3);			
											tfl = C_FACE_THREAD(c,t,3);	

//										 ----------- LEFT FACE ------------ 

											cl = F_C0(fl,tfl);
											if(cl == c)
											{
												cl = F_C1(fl,tfl);
												tl = F_C1_THREAD(fl,tfl);
											}
											else
											{
												tl = F_C0_THREAD(fl,tfl);
											}


//										 ----------- FRONT FACE ------------ 

											cf = F_C0(ff,tff);
											if(cf == c)
											{
												cf = F_C1(ff,tff);
												tf = F_C1_THREAD(ff,tff);
											}
											else
											{
												tf = F_C0_THREAD(ff,tff);
											}

											flp = C_FACE(cf,tf,2);
											tflp = C_FACE_THREAD(cf,tf,2);

//										 ----------- clf cell ----------- 

											clf = F_C0(flp,tflp);
											if(clf == cf)
											{
												clf = F_C1(flp,tflp);
												tlf = F_C1_THREAD(flp,tflp);
											}
											else
											{
												tlf = F_C0_THREAD(flp,tflp);
											}   

											fe = (1.0/4.0)*(0.0);     
											fw = (1.0/4.0)*(0.0 + 2*C_VOF(cl,t_liquid) + C_VOF(clf,t_liquid));
											fn = (1.0/4.0)*(C_VOF(clf,t_liquid) + 2*C_VOF(cf,t_liquid) + 0.0);
											fs = (1.0/4.0)*(0.0);    

									}
									else
									{
											ff = C_FACE(c,t,2);					
											tff = C_FACE_THREAD(c,t,2);
											
											fr = C_FACE(c,t,1);
											tfr = C_FACE_THREAD(c,t,1);
											
											fl = C_FACE(c,t,3);			
											tfl = C_FACE_THREAD(c,t,3);	

//										 ----------- RIGHT FACE ----------- 

											cr = F_C0(fr,tfr);
											if(cr == c)
											{
												cr = F_C1(fr,tfr);
												tr = F_C1_THREAD(fr,tfr);
											}
											else
											{
												tr = F_C0_THREAD(fr,tfr);
											}   

//										 ----------- LEFT FACE ------------ 

											cl = F_C0(fl,tfl);
											if(cl == c)
											{
												cl = F_C1(fl,tfl);
												tl = F_C1_THREAD(fl,tfl);
											}
											else
											{
												tl = F_C0_THREAD(fl,tfl);
											}


//										 ----------- FRONT FACE ------------ 

											cf = F_C0(ff,tff);
											if(cf == c)
											{
												cf = F_C1(ff,tff);
												tf = F_C1_THREAD(ff,tff);
											}
											else
											{
												tf = F_C0_THREAD(ff,tff);
											}

											frp = C_FACE(cf,tf,1);
											tfrp = C_FACE_THREAD(cf,tf,1);

											flp = C_FACE(cf,tf,3);
											tflp = C_FACE_THREAD(cf,tf,3);

//										 ----------- crf cell ----------- 

											crf = F_C0(frp,tfrp);
											if(crf == cf)
											{
												crf = F_C1(frp,tfrp);
												trf = F_C1_THREAD(frp,tfrp);
											}
											else
											{
												trf = F_C0_THREAD(frp,tfrp);
											}   

//										 ----------- clf cell ----------- 

											clf = F_C0(flp,tflp);
											if(clf == cf)
											{
												clf = F_C1(flp,tflp);
												tlf = F_C1_THREAD(flp,tflp);
											}
											else
											{
												tlf = F_C0_THREAD(flp,tflp);
											}   

											fe = (1.0/4.0)*(0.0 + 2*C_VOF(cr,t_liquid) + C_VOF(crf,t_liquid));     
											fw = (1.0/4.0)*(0.0 + 2*C_VOF(cl,t_liquid) + C_VOF(clf,t_liquid));
											fn = (1.0/4.0)*(C_VOF(clf,t_liquid) + 2*C_VOF(cf,t_liquid) + C_VOF(crf,t_liquid));
											fs = (1.0/4.0)*(0.0);

									}



								}

										if( ( NODE_X(node)*100000 == 0.0 ) && ( NODE_Y(node) > 0.0 ) && ( NODE_Y(node)*100000 != 227 ) )
										{
											ff = C_FACE(c,t,3);					
											tff = C_FACE_THREAD(c,t,3);
											fr = C_FACE(c,t,2);					
											tfr = C_FACE_THREAD(c,t,2);
											fa = C_FACE(c,t,1);
											tfa = C_FACE_THREAD(c,t,1);

//												 ----------- FRONT FACE ------------ 

													cf = F_C0(ff,tff);
													if(cf == c)
													{
														cf = F_C1(ff,tff);
														tf = F_C1_THREAD(ff,tff);
													}
													else
													{
														tf = F_C0_THREAD(ff,tff);
													}

//												 ----------- RIGHT FACE ----------- 

													cr = F_C0(fr,tfr);
													if(cr == c)
													{
														cr = F_C1(fr,tfr);
														tr = F_C1_THREAD(fr,tfr);
													}
													else
													{
														tr = F_C0_THREAD(fr,tfr);
													}   

//												 ------------ AFTER FACE ------------ 

													ca = F_C0(fa,tfa);
													if(ca == c)
													{
														ca = F_C1(fa,tfa);
														ta = F_C1_THREAD(fa,tfa);
													}
													else
													{
														ta = F_C0_THREAD(fa,tfa);
													}

													far  = C_FACE(cr,tr,0);	
													tfar = C_FACE_THREAD(cr,tr,0);

													ffr  = C_FACE(cr,tr,2);	
													tffr = C_FACE_THREAD(cr,tr,2);

//												 ----------- crf cell ----------- 

													crf = F_C0(ffr,tffr);
													if(crf == cr)
													{
														crf = F_C1(ffr,tffr);
														trf = F_C1_THREAD(ffr,tffr);
													}
													else
													{
														trf = F_C0_THREAD(ffr,tffr);
													}   

//												 ----------- cra cell ----------- 

													cra = F_C0(far,tfar);
													if(crf == cr)
													{
														crf = F_C1(far,tfar);
														trf = F_C1_THREAD(far,tfar);
													}
													else
													{
														trf = F_C0_THREAD(far,tfar);
													}   

												fe = (1.0/4.0)*(C_VOF(cra,t_liquid) + 2*C_VOF(cr,t_liquid) + C_VOF(crf,t_liquid));     
												fw = (1.0/4.0)*(0.0);
												fn = (1.0/4.0)*(0.0 + 2*C_VOF(cf,t_liquid) + C_VOF(crf,t_liquid));
												fs = (1.0/4.0)*(0.0 + 2*C_VOF(ca,t_liquid) + C_VOF(cra,t_liquid));  

										}

										if( ( NODE_X(node)*1000000 == 1135 ) && ( NODE_Y(node) > 0.0 ) && ( NODE_Y(node)*100000 != 227 ) )
										{
											ff = C_FACE(c,t,1);					
											tff = C_FACE_THREAD(c,t,1);

											fl = C_FACE(c,t,2);					
											tfl = C_FACE_THREAD(c,t,2);
											
											fa = C_FACE(c,t,3);
											tfa = C_FACE_THREAD(c,t,3);

//												 ----------- FRONT FACE ------------ 

													cf = F_C0(ff,tff);
													if(cf == c)
													{
														cf = F_C1(ff,tff);
														tf = F_C1_THREAD(ff,tff);
													}
													else
													{
														tf = F_C0_THREAD(ff,tff);
													}

//												 ----------- LEFT FACE ------------ 

													cl = F_C0(fl,tfl);
													if(cl == c)
													{
														cl = F_C1(fl,tfl);
														tl = F_C1_THREAD(fl,tfl);
													}
													else
													{
														tl = F_C0_THREAD(fl,tfl);
													}

//												 ------------ AFTER FACE ------------ 

													ca = F_C0(fa,tfa);
													if(ca == c)
													{
														ca = F_C1(fa,tfa);
														ta = F_C1_THREAD(fa,tfa);
													}
													else
													{
														ta = F_C0_THREAD(fa,tfa);
													}

													fal  = C_FACE(cl,tl,0);	
													tfal = C_FACE_THREAD(cl,tl,0);

													ffl  = C_FACE(cl,tl,2);	
													tffl = C_FACE_THREAD(cl,tl,2);

//												 ----------- clf cell ----------- 

													clf = F_C0(ffl,tffl);
													if(clf == cl)
													{
														clf = F_C1(ffl,tffl);
														tlf = F_C1_THREAD(ffl,tffl);
													}
													else
													{
														tlf = F_C0_THREAD(ffl,tffl);
													}   

//												 ----------- cla cell ----------- 

													cla = F_C0(fal,tfal);
													if(clf == cl)
													{
														clf = F_C1(fal,tfal);
														tlf = F_C1_THREAD(fal,tfal);
													}
													else
													{
														tlf = F_C0_THREAD(fal,tfal);
													}   

											fe = (1.0/4.0)*(0.0); 
											fw = (1.0/4.0)*(C_VOF(cla,t_liquid) + 2*C_VOF(cl,t_liquid) + C_VOF(clf,t_liquid));
											fn = (1.0/4.0)*(C_VOF(clf,t_liquid) + 2*C_VOF(cf,t_liquid) + 0.0);
											fs = (1.0/4.0)*(C_VOF(cla,t_liquid) + 2*C_VOF(ca,t_liquid) + 0.0);    

										}



								}				*/

					}
					else
					{
		//			Message("Interior Mixture cell \n");
						fr = C_FACE(c,t,1);
						tfr = C_FACE_THREAD(c,t,1);
						fl = C_FACE(c,t,3);					/* --------------------- FOR ---------------------- */
						tfl = C_FACE_THREAD(c,t,3);			/* ------------------ INTERIOR -------------------- */
						ff = C_FACE(c,t,2);					/* -------------------- CELLS --------------------- */
						tff = C_FACE_THREAD(c,t,2);
						fa = C_FACE(c,t,0);
						tfa = C_FACE_THREAD(c,t,0);

					
	
						/* ----------- RIGHT FACE ----------- */

						cr = F_C0(fr,tfr);
						if(cr == c)
						{
							cr = F_C1(fr,tfr);
							tr = F_C1_THREAD(fr,tfr);
						}
						else
						{
							tr = F_C0_THREAD(fr,tfr);
						}   

					/* ----------- LEFT FACE ------------ */

						cl = F_C0(fl,tfl);
						if(cl == c)
						{
							cl = F_C1(fl,tfl);
							tl = F_C1_THREAD(fl,tfl);
						}
						else
						{
							tl = F_C0_THREAD(fl,tfl);
						}
					/* ----------- FRONT FACE ------------ */
						cf = F_C0(ff,tff);
						if(cf == c)
						{
							cf = F_C1(ff,tff);
							tf = F_C1_THREAD(ff,tff);
						}
						else
						{
							tf = F_C0_THREAD(ff,tff);
						}
					/* ------------ AFTER FACE ------------ */
						ca = F_C0(fa,tfa);
						if(ca == c)
						{
							ca = F_C1(fa,tfa);
							ta = F_C1_THREAD(fa,tfa);
						}
						else
						{
							ta = F_C0_THREAD(fa,tfa);
						}

	
			//			Message("%u %u %u %u \n", cr, cl, cf, ca);

						c_face_loop(cr,tr,N)
						{
							t_fr = C_FACE_THREAD(cr,tr,N);
							if( BOUNDARY_FACE_THREAD_P(t_fr) )
							{
								check_r = TRUE;
							}
						}

						c_face_loop(cf,tf,N)
						{
							t_ff = C_FACE_THREAD(cf,tf,N);
							if( BOUNDARY_FACE_THREAD_P(t_ff) )
							{
								check_f = TRUE;
							}
						}

						c_face_loop(cl,tl,N)
						{
							t_fl = C_FACE_THREAD(cl,tl,N);
							if( BOUNDARY_FACE_THREAD_P(t_fl) )
							{
								check_l = TRUE;
							}
						}

						c_face_loop(ca,ta,N)
						{
							t_fa = C_FACE_THREAD(ca,ta,N);
							if( BOUNDARY_FACE_THREAD_P(t_fa) )
							{
								check_a = TRUE;
							}
						}				

				//			Message("%u %u %u %u \n", check_r, check_f, check_l, check_a);

						if( check_r )
						{
				//			Message(" BOUNDARY CELL ENCOUNTERED \n ");
			

								ffr = C_FACE(cr,tr,1);
								tffr = C_FACE_THREAD(cr,tr,1);

								far = C_FACE(cr,tr,3);
								tfar = C_FACE_THREAD(cr,tr,3);

								ffl = C_FACE(cl,tl,2);
								tffl = C_FACE_THREAD(cl,tl,2);

								fal = C_FACE(cl,tl,0);
								tfal = C_FACE_THREAD(cl,tl,0);

					
							/* ======================== (crf,trf) ============================= */

								crf = F_C0(ffr,tffr);
								if(crf == cr)
								{
									crf = F_C1(ffr,tffr);
									trf = F_C1_THREAD(ffr,tffr);
								}
								else
								{
									trf = F_C0_THREAD(ffr,tffr);
								}
					//			Message(" crf = %u \n ", crf);
							/* ======================== (cra,tra) ============================= */

								cra = F_C0(far,tfar);
								if(cra == cr)
								{
									cra = F_C1(far,tfar);
									tra = F_C1_THREAD(far,tfar);
								}
								else
								{
									tra = F_C0_THREAD(far,tfar);
								}
					//			Message(" cra = %u \n ", cra);	
							/* ======================== (clf,tlf) ============================= */

								clf = F_C0(ffl,tffl);
								if(clf == cl)
								{
									clf = F_C1(ffl,tffl);
									tlf = F_C1_THREAD(ffl,tffl);
								}
								else
								{
									tlf = F_C0_THREAD(ffl,tffl);
								}
					//			Message(" clf = %u \n ", clf);
							/* ======================== (cla,tla) ============================= */

								cla = F_C0(fal,tfal);
								if(cla == cl)
								{
									cla = F_C1(fal,tfal);
									tla = F_C1_THREAD(fal,tfal);
								}
								else
								{
									tla = F_C0_THREAD(fal,tfal);
								}
					//			Message(" cla = %u \n ", cla);
		
						}
						else if ( check_f )
						{
			
								frp = C_FACE(cf,tf,3);
								tfrp = C_FACE_THREAD(cf,tf,3);

								flp = C_FACE(cf,tf,1);
								tflp = C_FACE_THREAD(cf,tf,1);

								frm = C_FACE(ca,ta,1);
								tfrm = C_FACE_THREAD(ca,ta,1);

								flm = C_FACE(ca,ta,3);
								tflm = C_FACE_THREAD(ca,ta,3);

							/* ======================== (crf,trf) ============================= */

								crf = F_C0(frp,tfrp);
								if(crf == cr)
								{
									crf = F_C1(frp,tfrp);
									trf = F_C1_THREAD(frp,tfrp);
								}
								else
								{
									trf = F_C0_THREAD(frp,tfrp);
								}

							/* ======================== (clf,tlf) ============================= */

								clf = F_C0(flp,tflp);
								if(clf == cl)
								{
									clf = F_C1(flp,tflp);
									tlf = F_C1_THREAD(flp,tflp);
								}
								else
								{
									tlf = F_C0_THREAD(flp,tflp);
								}

							/* ======================== (cra,tra) ============================= */

								cra = F_C0(frm,tfrm);
								if(cra == cr)
								{
									cra = F_C1(frm,tfrm);
									tra = F_C1_THREAD(frm,tfrm);
								}
								else
								{
									tra = F_C0_THREAD(frm,tfrm);
								}

							/* ======================== (cla,tla) ============================= */

								cla = F_C0(flm,tflm);
								if(cla == cl)
								{
									cla = F_C1(flm,tflm);
									tla = F_C1_THREAD(flm,tflm);
								}
								else
								{
									tla = F_C0_THREAD(flm,tflm);
								}
			
						}
						else if ( check_l ) 
						{
			
								ffl = C_FACE(cl,tl,3);
								tffl = C_FACE_THREAD(cl,tl,3);

								fal = C_FACE(cl,tl,1);
								tfal = C_FACE_THREAD(cl,tl,1);

								ffr = C_FACE(cr,tr,2);
								tffr = C_FACE_THREAD(cr,tr,2);

								far = C_FACE(cr,tr,0);
								tfar = C_FACE_THREAD(cr,tr,0);

							/* ======================== (crf,trf) ============================= */

								crf = F_C0(ffr,tffr);
								if(crf == cr)
								{
									crf = F_C1(ffr,tffr);
									trf = F_C1_THREAD(ffr,tffr);
								}
								else
								{
									trf = F_C0_THREAD(ffr,tffr);
								}
					//			Message(" crf = %u \n ", crf);
							/* ======================== (cra,tra) ============================= */

								cra = F_C0(far,tfar);
								if(cra == cr)
								{
									cra = F_C1(far,tfar);
									tra = F_C1_THREAD(far,tfar);
								}
								else
								{
									tra = F_C0_THREAD(far,tfar);
								}
					//			Message(" cra = %u \n ", cra);	
							/* ======================== (clf,tlf) ============================= */

								clf = F_C0(ffl,tffl);
								if(clf == cl)
								{
									clf = F_C1(ffl,tffl);
									tlf = F_C1_THREAD(ffl,tffl);
								}
								else
								{
									tlf = F_C0_THREAD(ffl,tffl);
								}
					//			Message(" clf = %u \n ", clf);
							/* ======================== (cla,tla) ============================= */

								cla = F_C0(fal,tfal);
								if(cla == cl)
								{
									cla = F_C1(fal,tfal);
									tla = F_C1_THREAD(fal,tfal);
								}
								else
								{
									tla = F_C0_THREAD(fal,tfal);
								}
					//			Message(" cla = %u \n ", cla);
		
			
						}
						else if ( check_a )
						{
			
								frm = C_FACE(ca,ta,1);
								tfrm = C_FACE_THREAD(ca,ta,1);

								flm = C_FACE(ca,ta,3);
								tflm = C_FACE_THREAD(ca,ta,3);

								frp = C_FACE(cf,tf,1);
								tfrp = C_FACE_THREAD(cf,tf,1);

								flp = C_FACE(cf,tf,3);
								tflp = C_FACE_THREAD(cf,tf,3);
			
							/* ======================== (crf,trf) ============================= */

								crf = F_C0(frp,tfrp);
								if(crf == cr)
								{
									crf = F_C1(frp,tfrp);
									trf = F_C1_THREAD(frp,tfrp);
								}
								else
								{
									trf = F_C0_THREAD(frp,tfrp);
								}

							/* ======================== (clf,tlf) ============================= */

								clf = F_C0(flp,tflp);
								if(clf == cl)
								{
									clf = F_C1(flp,tflp);
									tlf = F_C1_THREAD(flp,tflp);
								}
								else
								{
									tlf = F_C0_THREAD(flp,tflp);
								}

							/* ======================== (cra,tra) ============================= */

								cra = F_C0(frm,tfrm);
								if(cra == cr)
								{
									cra = F_C1(frm,tfrm);
									tra = F_C1_THREAD(frm,tfrm);
								}
								else
								{
									tra = F_C0_THREAD(frm,tfrm);
								}

							/* ======================== (cla,tla) ============================= */

								cla = F_C0(flm,tflm);
								if(cla == cl)
								{
									cla = F_C1(flm,tflm);
									tla = F_C1_THREAD(flm,tflm);
								}
								else
								{
									tla = F_C0_THREAD(flm,tflm);
								}
						}
						else
						{
				/* ============== DEFINITION OF SECONDARY NEIGHBOURS ============== */

 
							ffr = C_FACE(cr,tr,2);
							tffr = C_FACE_THREAD(cr,tr,2);

							far = C_FACE(cr,tr,0);
							tfar = C_FACE_THREAD(cr,tr,0);

							ffl = C_FACE(cl,tl,2);
							tffl = C_FACE_THREAD(cl,tl,2);

							fal = C_FACE(cl,tl,0);
							tfal = C_FACE_THREAD(cl,tl,0);

				//		Message("  far, tfar, ffl, tffl, fal, tfal =  %u %u %u %u %u %u  \n ", far, tfar, ffl, tffl, fal, tfal); 

		

						/* ======================== (crf,trf) ============================= */

							crf = F_C0(ffr,tffr);
							if(crf == cr)
							{
								crf = F_C1(ffr,tffr);
								trf = F_C1_THREAD(ffr,tffr);
							}
							else
							{
								trf = F_C0_THREAD(ffr,tffr);
							}
				//			Message(" crf = %u \n ", crf);
						/* ======================== (cra,tra) ============================= */

							cra = F_C0(far,tfar);
							if(cra == cr)
							{
								cra = F_C1(far,tfar);
								tra = F_C1_THREAD(far,tfar);
							}
							else
							{
								tra = F_C0_THREAD(far,tfar);
							}
				//			Message(" cra = %u \n ", cra);	
						/* ======================== (clf,tlf) ============================= */

							clf = F_C0(ffl,tffl);
							if(clf == cl)
							{
								clf = F_C1(ffl,tffl);
								tlf = F_C1_THREAD(ffl,tffl);
							}
							else
							{
								tlf = F_C0_THREAD(ffl,tffl);
							}
				//			Message(" clf = %u \n ", clf);
						/* ======================== (cla,tla) ============================= */

							cla = F_C0(fal,tfal);
							if(cla == cl)
							{
								cla = F_C1(fal,tfal);
								tla = F_C1_THREAD(fal,tfal);
							}
							else
							{
								tla = F_C0_THREAD(fal,tfal);
							}
				//			Message(" cla = %u \n ", cla);
		
						}
//	Message("%u %u %u %u %u %u %u %u \n", check_r, check_f, check_l, check_a, crf, clf, cra, cla);
						
		

						fe = (1.0/4.0)*(C_VOF(cra,t_liquid) + 2*C_VOF(cr,t_liquid) + C_VOF(crf,t_liquid));     /* NOTE: t_liquid will be different for cells as they are having different threads */
						fw = (1.0/4.0)*(C_VOF(cla,t_liquid) + 2*C_VOF(cl,t_liquid) + C_VOF(clf,t_liquid));
						fn = (1.0/4.0)*(C_VOF(clf,t_liquid) + 2*C_VOF(cf,t_liquid) + C_VOF(crf,t_liquid));
						fs = (1.0/4.0)*(C_VOF(cla,t_liquid) + 2*C_VOF(ca,t_liquid) + C_VOF(cra,t_liquid));    
				
						nx = (1.0/2.0)*(fe-fw);
						ny = (1.0/2.0)*(fn-fs);

						rmag2 = nx*nx + ny*ny;
					//	rmag = sqrt(rmag2);
						ax = nx/sqrt(rmag2);
						ay = ny/sqrt(rmag2);
//				Message(" before nxi,nyi,nxf,nyf = %.15f %.15f %.15f %.15f \n ", nx, ny, ax, ay);
						if (rmag2 > 0.001)
						{
							rmag = sqrt(rmag2);
							nx = nx/rmag;
							ny = ny/rmag;
			//				Message("1 rmag = %f \n ", rmag );
/*							if( ( (nx != nx) && (ny != ny) ) || ( (nx != nx) || (ny != ny) ) )
							{
								Message(" nxi,nyi,nxf,nyf = %.15f %.15f %.15f %.15f \n ", (1.0/2.0)*(fe-fw), (1.0/2.0)*(fn-fs), nx, ny);
							}
							else
							{										*/
								C_UDMI(c,t,2) =	nx;
								C_UDMI(c,t,3) =	ny;
				//			}

						}	

		//				Message(" Hello  %u %f %f \n", c, C_UDMI(c,t,2), C_UDMI(c,t,3)  );
//				Youngs method represents first guess

						get_len(c, t_liquid, nx, ny);

						if(C_UDMI(c,t,5) < 0.0001 )
						{
		//					Message(" I Am Jumping %u \n", c );
							goto IFACE1_GET_LEN_END; 
						}

						nxy = nx;
						nyy = ny;
						sleny = C_UDMI(c,t,4);
						thetay = atan2(nyy,nxy);
					

	/*					if ( boundary )
						{
							    c_node_loop(c,t,k)
								{
									  node = C_NODE(c,t,k);

									if( NODE_Y(node) == 0 )
									{
										if(NODE_X(node) == 0)
										{
											save_len[1][1] = 0.0 ;
											save_len[2][1] = 0.0   ;
											save_len[3][1] = 0.0 ;
											save_len[1][2] = C_UDMI(cf,tf,4)   ;
											save_len[2][2] = C_UDMI(c,t,4)     ;
											save_len[3][2] = 0.0   ;
											save_len[1][3] = C_UDMI(crf,trf,4) ;
											save_len[2][3] = C_UDMI(cr,tr,4)   ;
											save_len[3][3] = 0.0 ;

											save_nx[1][1] = 0.0 ;
											save_nx[2][1] = 0.0   ;
											save_nx[3][1] = 0.0 ;
											save_nx[1][2] = C_UDMI(cf,tf,2)   ;
											save_nx[2][2] = C_UDMI(c,t,2)     ;
											save_nx[3][2] = 0.0   ;
											save_nx[1][3] = C_UDMI(crf,trf,2) ;
											save_nx[2][3] = C_UDMI(cr,tr,2)   ;
											save_nx[3][3] = 0.0 ;

											save_ny[1][1] = 0.0 ;
											save_ny[2][1] = 0.0   ;
											save_ny[3][1] = 0.0 ;
											save_ny[1][2] = C_UDMI(cf,tf,3)   ;
											save_ny[2][2] = C_UDMI(c,t,3)     ;
											save_ny[3][2] = 0.0   ;
											save_ny[1][3] = C_UDMI(crf,trf,3) ;
											save_ny[2][3] = C_UDMI(cr,tr,3)   ;
											save_ny[3][3] = 0.0	 ;
										}
										else if( NODE_X(node)*1000000 == 1135 )
										{
											save_len[1][1] = C_UDMI(clf,tlf,4) ;
											save_len[2][1] = C_UDMI(cl,tl,4)   ;
											save_len[3][1] = 0.0 ;
											save_len[1][2] = C_UDMI(cf,tf,4)   ;
											save_len[2][2] = C_UDMI(c,t,4)     ;
											save_len[3][2] = 0.0   ;
											save_len[1][3] = 0.0 ;
											save_len[2][3] = 0.0   ;
											save_len[3][3] = 0.0 ;

											save_nx[1][1] = C_UDMI(clf,tlf,2) ;
											save_nx[2][1] = C_UDMI(cl,tl,2)   ;
											save_nx[3][1] = 0.0 ;
											save_nx[1][2] = C_UDMI(cf,tf,2)   ;
											save_nx[2][2] = C_UDMI(c,t,2)     ;
											save_nx[3][2] = 0.0   ;
											save_nx[1][3] = 0.0   ;
											save_nx[2][3] = 0.0   ;
											save_nx[3][3] = 0.0	  ;

											save_ny[1][1] = C_UDMI(clf,tlf,3) ;
											save_ny[2][1] = C_UDMI(cl,tl,3)   ;
											save_ny[3][1] = 0.0 ;
											save_ny[1][2] = C_UDMI(cf,tf,3)   ;
											save_ny[2][2] = C_UDMI(c,t,3)     ;
											save_ny[3][2] = 0.0   ;
											save_ny[1][3] = 0.0   ;
											save_ny[2][3] = 0.0   ;
											save_ny[3][3] = 0.0   ;
										}
										else
										{
											save_len[1][1] = C_UDMI(clf,tlf,4) ;
											save_len[2][1] = C_UDMI(cl,tl,4)   ;
											save_len[3][1] = 0.0 ;
											save_len[1][2] = C_UDMI(cf,tf,4)   ;
											save_len[2][2] = C_UDMI(c,t,4)     ;
											save_len[3][2] = 0.0   ;
											save_len[1][3] = C_UDMI(crf,trf,4) ;
											save_len[2][3] = C_UDMI(cr,tr,4)   ;
											save_len[3][3] = 0.0 ;

											save_nx[1][1] = C_UDMI(clf,tlf,2) ;
											save_nx[2][1] = C_UDMI(cl,tl,2)   ;
											save_nx[3][1] = 0.0   ;
											save_nx[1][2] = C_UDMI(cf,tf,2)   ;
											save_nx[2][2] = C_UDMI(c,t,2)     ;
											save_nx[3][2] = 0.0   ;
											save_nx[1][3] = C_UDMI(crf,trf,2) ;
											save_nx[2][3] = C_UDMI(cr,tr,2)   ;
											save_nx[3][3] = 0.0	  ;

											save_ny[1][1] = C_UDMI(clf,tlf,3) ;
											save_ny[2][1] = C_UDMI(cl,tl,3)   ;
											save_ny[3][1] = 0.0   ;
											save_ny[1][2] = C_UDMI(cf,tf,3)   ;
											save_ny[2][2] = C_UDMI(c,t,3)     ;
											save_ny[3][2] = 0.0   ;
											save_ny[1][3] = C_UDMI(crf,trf,3) ;
											save_ny[2][3] = C_UDMI(cr,tr,3)   ;
											save_ny[3][3] = 0.0   ;
										}
						

									}

									if( ( NODE_X(node) == 0 ) && ( NODE_Y(node) > 0.0 ) &&  ( NODE_Y(node)*100000 != 227 ) )
									{
										save_len[1][1] = 0.0 ;
										save_len[2][1] = 0.0   ;
										save_len[3][1] = 0.0 ;
										save_len[1][2] = C_UDMI(cf,tf,4)   ;
										save_len[2][2] = C_UDMI(c,t,4)     ;
										save_len[3][2] = C_UDMI(ca,ta,4)   ;
										save_len[1][3] = C_UDMI(crf,trf,4) ;
										save_len[2][3] = C_UDMI(cr,tr,4)   ;
										save_len[3][3] = C_UDMI(cra,tra,4) ;

										save_nx[1][1] = 0.0 ;
										save_nx[2][1] = 0.0   ;
										save_nx[3][1] = 0.0 ;
										save_nx[1][2] = C_UDMI(cf,tf,2)   ;
										save_nx[2][2] = C_UDMI(c,t,2)     ;
										save_nx[3][2] = C_UDMI(ca,ta,2)   ;
										save_nx[1][3] = C_UDMI(crf,trf,2) ;
										save_nx[2][3] = C_UDMI(cr,tr,2)   ;
										save_nx[3][3] = C_UDMI(cra,tra,2) ;

										save_ny[1][1] = 0.0 ;
										save_ny[2][1] = 0.0 ;
										save_ny[3][1] = 0.0 ;
										save_ny[1][2] = C_UDMI(cf,tf,3)   ;
										save_ny[2][2] = C_UDMI(c,t,3)     ;
										save_ny[3][2] = C_UDMI(ca,ta,3)   ;
										save_ny[1][3] = C_UDMI(crf,trf,3) ;
										save_ny[2][3] = C_UDMI(cr,tr,3)   ;
										save_ny[3][3] = C_UDMI(cra,tra,3) ;

									}
									if( ( NODE_X(node)*1000000 == 1135 ) && ( NODE_Y(node) > 0.0 ) &&  ( NODE_Y(node)*100000 != 227 ) )
									{
										save_len[1][1] = C_UDMI(clf,tlf,4) ;
										save_len[2][1] = C_UDMI(cl,tl,4)   ;
										save_len[3][1] = C_UDMI(cla,tla,4) ;
										save_len[1][2] = C_UDMI(cf,tf,4)   ;
										save_len[2][2] = C_UDMI(c,t,4)     ;
										save_len[3][2] = C_UDMI(ca,ta,4)   ;
										save_len[1][3] = 0.0 ;
										save_len[2][3] = 0.0   ;
										save_len[3][3] = 0.0 ;

										save_nx[1][1] = C_UDMI(clf,tlf,2) ;
										save_nx[2][1] = C_UDMI(cl,tl,2)   ;
										save_nx[3][1] = C_UDMI(cla,tla,2) ;
										save_nx[1][2] = C_UDMI(cf,tf,2)   ;
										save_nx[2][2] = C_UDMI(c,t,2)     ;
										save_nx[3][2] = C_UDMI(ca,ta,2)   ;
										save_nx[1][3] = 0.0 ;
										save_nx[2][3] = 0.0   ;
										save_nx[3][3] = 0.0 ;

										save_ny[1][1] = C_UDMI(clf,tlf,3) ;
										save_ny[2][1] = C_UDMI(cl,tl,3)   ;
										save_ny[3][1] = C_UDMI(cla,tla,3) ;
										save_ny[1][2] = C_UDMI(cf,tf,3)   ;
										save_ny[2][2] = C_UDMI(c,t,3)     ;
										save_ny[3][2] = C_UDMI(ca,ta,3)   ;
										save_ny[1][3] = 0.0 ;
										save_ny[2][3] = 0.0   ;
										save_ny[3][3] = 0.0 ;
									}		
								}
						
						}
						else			
						{															*/
	/*		I AM NOTHING				save_len[1][1] = C_UDMI(clf,t,4) ;
										save_len[2][1] = C_UDMI(cl,t,4)   ;
										save_len[3][1] = C_UDMI(cla,t,4) ;
										save_len[1][2] = C_UDMI(cf,t,4)   ;
										save_len[2][2] = C_UDMI(c,t,4)     ;
										save_len[3][2] = C_UDMI(ca,t,4)   ;
										save_len[1][3] = C_UDMI(crf,t,4) ;
										save_len[2][3] = C_UDMI(cr,t,4)   ;
										save_len[3][3] = C_UDMI(cra,t,4) ;

										save_nx[1][1] = C_UDMI(clf,t,2) ;
										save_nx[2][1] = C_UDMI(cl,t,2)   ;
										save_nx[3][1] = C_UDMI(cla,t,2) ;
										save_nx[1][2] = C_UDMI(cf,t,2)   ;
										save_nx[2][2] = C_UDMI(c,t,2)     ;
										save_nx[3][2] = C_UDMI(ca,t,2)   ;
										save_nx[1][3] = C_UDMI(crf,t,2) ;
										save_nx[2][3] = C_UDMI(cr,t,2)   ;
										save_nx[3][3] = C_UDMI(cra,t,2) ;

										save_ny[1][1] = C_UDMI(clf,t,3) ;
										save_ny[2][1] = C_UDMI(cl,t,3)   ;
										save_ny[3][1] = C_UDMI(cla,t,3) ;
										save_ny[1][2] = C_UDMI(cf,t,3)   ;
										save_ny[2][2] = C_UDMI(c,t,3)     ;
										save_ny[3][2] = C_UDMI(ca,t,3)   ;
										save_ny[1][3] = C_UDMI(crf,t,3) ;
										save_ny[2][3] = C_UDMI(cr,t,3)   ;
										save_ny[3][3] = C_UDMI(cra,t,3) ;									*/
		//				}



//					Newton's method to find normal using LVIRA

					     theta = atan2(ny,nx);
					     dtheta = 0.001;
					     Gerr = 1.0;
					     ifter = 0;
					     maxiter = 150;
					
					
IFACE1_lvira11: ;

					if ( (fabs(Gerr) >= pow(10.,-8))  && ifter < maxiter  )
					{

		//				Message("LVIRA nx, ny = %u %d %f %f \n", c, ifter, nx, ny);
						ifter = ifter + 1;

						lvira(c, t, theta, dtheta, &Gfunp);

						if( (fabs(Gfunp) <= 0.000001) )		
						{
							if( C_UDMI(c,t,5) < 0.0001 )
							{

								nx = C_UDMI(c,t,2);
								ny = C_UDMI(c,t,3);
		//						Message(" 1 GOTO IFACE1_GET_LEN_END  %u \n", c );
								goto IFACE1_GET_LEN_END;
							}
							else
							{
								nx = cos(theta);
								ny = sin(theta);
								
		//						Message(" GOTO IFACE1_check %u \n", c);

							goto IFACE1_check11;
							}
						}
				
						thetar = theta + dtheta;

						lvira(c, t, thetar, dtheta, &Gfunpr);			// theta-right

						Gprime = (Gfunpr - Gfunp)/dtheta;

						IsFiniteNumber(Gprime, &INF) ;
						if(INF)
						{
							goto IFACE1_END;
							Message(" Gprime = %u %f %f %f \n ", c, Gfunpr, Gfunp ,Gprime);
						}

						theta_inc = - Gfunp/Gprime;

						theta = theta + theta_inc;

						nx = cos(theta);
						ny = sin(theta);

						Gerr = fabs(theta_inc);

						get_len(c, t_liquid, nx, ny );

						if(C_UDMI(c,t,5) < 0.0001 )
						{

								C_UDMI(c,t,2) = nx;
								C_UDMI(c,t,3) = ny;
		//						Message(" 2 GOTO IFACE1_GET_LEN_END  %u \n", c );
							goto IFACE1_GET_LEN_END;
						}
			//			Message(" c, ifter, Gprime, nx, ny =  %u %d %f %f %f \n", c, ifter, Gprime, nx, ny);
			//			Message(" c, nx, ny =  %u %f %f %f %f \n", c, nx, ny, C_UDMI(c,t,2), C_UDMI(c,t,3));
		//				Message(" Gerr = %g \n ", Gerr);
						goto IFACE1_lvira11;
					}
IFACE1_check11: ;
					
						if ( ifter >= maxiter)
						{

							nx = nxy;
							ny = nyy;
							C_UDMI(c,t,4) = sleny;
						}
						thetal = atan2(ny,nx);
						if( fabs(thetal - thetay) > M_PI/20.0 )
						{

							nx = nxy;
							ny = nyy;
							C_UDMI(c,t,4) = sleny;
						}
				
		//				Message(" 3 nx, ny = %u %d %f %f \n", c, ifter, nx, ny );

						C_UDMI(c,t,2) = nx;
						C_UDMI(c,t,3) = ny;

						get_len(c, t_liquid, nx, ny );

IFACE1_GET_LEN_END:;


		/*				if ( boundary )
						{
							    c_node_loop(c,t,k)
								{
									  node = C_NODE(c,t,k);

									if( NODE_Y(node) == 0 )
									{
										if(NODE_X(node) == 0)
										{

											C_UDMI(cf,tf,4)   = save_len[1][2] ;
											
											C_UDMI(crf,trf,4) = save_len[1][3] ;
											C_UDMI(cr,tr,4)   = save_len[2][3] ;
											

										
											C_UDMI(cf,tf,2)   = save_nx[1][2] ;
											
											C_UDMI(crf,trf,2) = save_nx[1][3] ;
											C_UDMI(cr,tr,2)   = save_nx[2][3] ;
											

										
											C_UDMI(cf,tf,3)   = save_ny[1][2] ;
											
											C_UDMI(crf,trf,3) = save_ny[1][3] ;
											C_UDMI(cr,tr,3)   = save_ny[2][3] ;
											
										}
										else if( NODE_X(node)*1000000 == 1135 )
										{
											C_UDMI(clf,tlf,4) = save_len[1][1] ;
											C_UDMI(cl,tl,4)   = save_len[2][1] ;
											C_UDMI(cf,tf,4)   = save_len[1][2] ;
											

											C_UDMI(clf,tlf,2) = save_nx[1][1] ;
											C_UDMI(cl,tl,2)   = save_nx[2][1] ;
											C_UDMI(cf,tf,2)   = save_nx[1][2] ;
											

											C_UDMI(clf,tlf,3) = save_ny[1][1] ;
											C_UDMI(cl,tl,3)   = save_ny[2][1] ;
											C_UDMI(cf,tf,3)   = save_ny[1][2] ;
											
														
										}
										else
										{
											C_UDMI(clf,tlf,4) = save_len[1][1] ;
											C_UDMI(cl,tl,4)   = save_len[2][1] ;
											C_UDMI(cf,tf,4)   = save_len[1][2] ;
											C_UDMI(crf,trf,4) = save_len[1][3] ;
											C_UDMI(cr,tr,4)   = save_len[2][3] ;

											C_UDMI(clf,tlf,2) = save_nx[1][1] ;
											C_UDMI(cl,tl,2)   = save_nx[2][1] ;
											C_UDMI(cf,tf,2)   = save_nx[1][2] ;
											C_UDMI(crf,trf,2) = save_nx[1][3] ;
											C_UDMI(cr,tr,2)   = save_nx[2][3] ;

											C_UDMI(clf,tlf,3) = save_ny[1][1] ;
											C_UDMI(cl,tl,3)   = save_ny[2][1] ;
											C_UDMI(cf,tf,3)   = save_ny[1][2] ;
											C_UDMI(crf,trf,3) = save_ny[1][3] ;
											C_UDMI(cr,tr,3)   = save_ny[2][3] ;

										}
						

									}

									if( ( NODE_X(node) == 0 ) && ( NODE_Y(node) > 0.0 ) &&  ( NODE_Y(node)*100000 != 227 ) )
									{
											C_UDMI(cf,tf,4)   = save_len[1][2] ;
											C_UDMI(ca,ta,4)   = save_len[3][2] ;
											C_UDMI(crf,trf,4) = save_len[1][3] ;
											C_UDMI(cr,tr,4)   = save_len[2][3] ;
											C_UDMI(cra,tra,4) = save_len[3][3] ;

											C_UDMI(cf,tf,2)   = save_nx[1][2] ;
											C_UDMI(ca,ta,2)   = save_nx[3][2] ;
											C_UDMI(crf,trf,2) = save_nx[1][3] ;
											C_UDMI(cr,tr,2)   = save_nx[2][3] ;
											C_UDMI(cra,tra,2) = save_nx[3][3] ;

											C_UDMI(cf,tf,3)   = save_ny[1][2] ;
											C_UDMI(ca,ta,3)   = save_ny[3][2] ;
											C_UDMI(crf,trf,3) = save_ny[1][3] ;
											C_UDMI(cr,tr,3)   = save_ny[2][3] ;
											C_UDMI(cra,tra,3) = save_ny[3][3] ;

									}
									if( ( NODE_X(node)*1000000 == 1135 ) && ( NODE_Y(node) > 0.0 ) &&  ( NODE_Y(node)*100000 != 227 ) )
									{
											C_UDMI(clf,tlf,4) = save_len[1][1] ;
											C_UDMI(cl,tl,4)   = save_len[2][1] ;
											C_UDMI(cla,tla,4) = save_len[3][1] ;
											C_UDMI(cf,tf,4)   = save_len[1][2] ;
											C_UDMI(ca,ta,4)   = save_len[3][2] ;

											C_UDMI(clf,tlf,2) = save_nx[1][1] ;
											C_UDMI(cl,tl,2)   = save_nx[2][1] ;
											C_UDMI(cla,tla,2) = save_nx[3][1] ;
											C_UDMI(cf,tf,2)   = save_nx[1][2] ;
											C_UDMI(ca,ta,2)   = save_nx[3][2] ;

											C_UDMI(clf,tlf,3) = save_ny[1][1] ;
											C_UDMI(cl,tl,3)   = save_ny[2][1] ;
											C_UDMI(cla,tla,3) = save_ny[3][1] ;
											C_UDMI(cf,tf,3)   = save_ny[1][2] ;
											C_UDMI(ca,ta,3)   = save_ny[3][2] ;
									}		
								}
						
						}
						else			
						{					*/
	/*	I AM BHARAT 					C_UDMI(clf,t,4) = save_len[1][1] ;
										C_UDMI(cl,t,4)   = save_len[2][1] ;
										C_UDMI(cla,t,4) = save_len[3][1] ;
										C_UDMI(cf,t,4)   = save_len[1][2] ;
										C_UDMI(ca,t,4)   = save_len[3][2] ;
										C_UDMI(crf,t,4) = save_len[1][3] ;
										C_UDMI(cr,t,4)   = save_len[2][3] ;
										C_UDMI(cra,t,4) = save_len[3][3] ;

										C_UDMI(clf,t,2) = save_nx[1][1] ;
										C_UDMI(cl,t,2)   = save_nx[2][1] ;
										C_UDMI(cla,t,2) = save_nx[3][1] ;
										C_UDMI(cf,t,2)   = save_nx[1][2] ;
										C_UDMI(ca,t,2)   = save_nx[3][2] ;
										C_UDMI(crf,t,2) = save_nx[1][3] ;
										C_UDMI(cr,t,2)   = save_nx[2][3] ;
										C_UDMI(cra,t,2) = save_nx[3][3] ;

										C_UDMI(clf,t,3) = save_ny[1][1] ;
										C_UDMI(cl,t,3)   = save_ny[2][1] ;
										C_UDMI(cla,t,3) = save_ny[3][1] ;
										C_UDMI(cf,t,3)   = save_ny[1][2] ;
										C_UDMI(ca,t,3)   = save_ny[3][2] ;
										C_UDMI(crf,t,3) = save_ny[1][3] ;
										C_UDMI(cr,t,3)   = save_ny[2][3] ;
										C_UDMI(cra,t,3) = save_ny[3][3] ;											*/
			//			}

	//	Message("1st iface - before - c, iphs, C_UDMI(c,t,2), C_UDMI(c,t,3)  = %u %d %.15f %.15f \n", c, iphs, C_UDMI(c,t,2), C_UDMI(c,t,3));
					
						
				}
IFACE1_END:;
			  }
			}
			end_c_loop_all(c,t)
		}
	}
// densty(id2)
	thread_loop_c(t,domain)
	{
		begin_c_loop(c,t)
		{
		   t_liquid = THREAD_SUB_THREAD(t,0);
		   t_vapour = THREAD_SUB_THREAD(t,1);
		   
		   t_f = C_FACE_THREAD(c,t,0);
		   idirex = id2;

		   				if(BOUNDARY_FACE_THREAD_P(t_f))
						{

						}
						else
						{
	
							fr = C_FACE(c,t,1);
							tfr = C_FACE_THREAD(c,t,1);
							fl = C_FACE(c,t,3);					/* --------------------- FOR ---------------------- */
							tfl = C_FACE_THREAD(c,t,3);			/* ------------------ INTERIOR -------------------- */ 
							ff = C_FACE(c,t,2);					/* -------------------- CELLS --------------------- */
							tff = C_FACE_THREAD(c,t,2);
							fa = C_FACE(c,t,0);
							tfa = C_FACE_THREAD(c,t,0);
	
	

							/* ----------- RIGHT FACE ----------- */

							cr = F_C0(fr,tfr);
							if(cr == c)
							{
								cr = F_C1(fr,tfr);
								tr = F_C1_THREAD(fr,tfr);
							}
							else
							{
								tr = F_C0_THREAD(fr,tfr);
							}   

						/* ----------- LEFT FACE ------------ */

							cl = F_C0(fl,tfl);
							if(cl == c)
							{
								cl = F_C1(fl,tfl);
								tl = F_C1_THREAD(fl,tfl);
							}
							else
							{
								tl = F_C0_THREAD(fl,tfl);
							}

						/* ----------- FRONT FACE ------------ */

							cf = F_C0(ff,tff);
							if(cf == c)
							{
								cf = F_C1(ff,tff);
								tf = F_C1_THREAD(ff,tff);
							}
							else
							{
								tf = F_C0_THREAD(ff,tff);
							}



						/* ------------ AFTER FACE ------------ */

							ca = F_C0(fa,tfa);
							if(ca == c)
							{
								ca = F_C1(fa,tfa);
								ta = F_C1_THREAD(fa,tfa);
							}
							else
							{
								ta = F_C0_THREAD(fa,tfa);
							}
	
	

						delta( c, t, &dx, &dy );

						vol = dx*dy;
	
						ur = C_U(c,t);
						ul = F_U(cl,t);
						vf = C_V(c,t);
						va = F_V(ca ,t);
	
					//	Message(" ur = %f \n ", ur);
					//	Message(" ul = %f \n ", ul);
					//	Message(" vf = %f \n ", vf);
					//	Message(" va = %f \n ", va);		
			
								C_CENTROID(X,c,t);
			
								F_CENTROID(xfr,fr,tfr);
								F_CENTROID(xff,ff,tff);
								F_CENTROID(xfl,fl,tfl);
								F_CENTROID(xfa,fa,tfa);

								xr = xfr[0] ;
								yf = xff[1] ;
								xl = xfl[0] ;
								ya = xfa[1] ;

						delta( c, t, &dx, &dy );
						iphs = C_UDMI(c,t,1); //iphase[c];;
					
						nx = C_UDMI(c,t,2);
						ny = C_UDMI(c,t,3);

									 
									 /* if v(i,j) >= 0 this cell will flux its material into the next cell */

									 if (vf > 0 )
									 {
										rlflux = 0.0;
										rgflux = 0.0;


										afluy = vf * CURRENT_TIMESTEP;
										yflux  = yf - afluy;

										dvol = afluy*dx;

										if ( iphs != 2 ) //( C_UDSI(c,t,0) != 2)
										{
											flux = C_R_M1(c,t) * dvol;
											if ( iphs == 1 ) // ( C_UDSI(c,t,0) == 1 )
											{
												rlflux = flux;
											}
											else
											{
												rgflux = flux;
											}
										goto densty33;
										}
							//			else
							//			{
				 
						//			 get_len(c, t_liquid, nx, ny , &len);
										len =	C_UDMI(c,t,4);	// -8.48917e-06;
									 lgvol( c, t_liquid, xl, xr, yflux, yf, &lvol );
				//					 Message(" c, xl, xr, yflux, yf = %u %g %g %g %g  \n", c, xl, xr, yflux, yf );
				//					 Message(" c, vf, len, lvol(vf), dvol,  nx1, ny1, N_ITER = %u %g %g %g %g %g %g %d \n", c, vf, len, lvol, dvol, nx, ny, N_ITER );

									 iphsf = C_UDMI(cf,tf,1);
									 if( lvol == 0 && iphsf ==1 ) //C_UDSI(cf,tf,0) == 1 )
									 {
										 lvol = dvol;
									 }
									 gvol = dvol - lvol;

									 rlflux = lvol * ROL;                  
									 rgflux = gvol * ROG;

									 if( fabs(rlflux) > ftol  && fabs(rgflux) > ftol )
									 {
						//				 itran[cf] = 1; //C_UDSI(cf,tf,1) = 1;  
										 C_UDMI(cf,tf,0) = 1; // itran[cf];
									 }
							//			}
									 densty33:  ;

									 flux = (rlflux + rgflux) / vol;

									 C_R(cf,tf) += flux;
						//			 Message(" C_R(cf,tf) = %f \n ", C_R(cf,tf));
									 C_R(c,t)   -= flux;
									 }

									 /* if v(i,j-1) <= 0 this cell will flux its material into the next cell */

									 if (va < 0 )
									 {
										rlflux = 0.0;
										rgflux = 0.0;


										afluy = - va * CURRENT_TIMESTEP;
										yflux  = ya + afluy;

										dvol = afluy*dx;

										if (iphs != 2) //( C_UDSI(c,t,0) != 2)
										{
											flux = C_R_M1(c,t) * dvol;
											if (iphs == 1) //( C_UDSI(c,t,0) == 1 )
											{
												rlflux = flux;
											}
											else
											{
												rgflux = flux;
											}
										goto densty44;
										}
							//			else
							//			{
				 
						//			 get_len(c, t_liquid, nx, ny , &len);
										len =	C_UDMI(c,t,4);	// -8.48917e-06;
									 lgvol( c, t_liquid, xl, xr, ya, yflux, &lvol );
				//					 Message(" c, xl, xr, ya, yflux = %u, %g %g %g %g  \n", c, xl, xr, ya, yflux );
				//					 Message("c, va, len, lvol(va), dvol, nx1, ny1, N_ITER = %u %g %g %g %g %g %g %d \n", c, va, len, lvol, dvol, nx, ny, N_ITER);

									 iphsa = C_UDMI(ca,ta,1);
									 if( lvol == 0 && iphsa == 1 ) //C_UDSI(ca,ta,0) == 1 )
									 {
										 lvol = dvol;
									 }
									 gvol = dvol - lvol;

									 rlflux = lvol * ROL;                  
									 rgflux = gvol * ROG;		

									 if( fabs(rlflux) > ftol  && fabs(rgflux) > ftol )
									 {
						//				itran[ca] = 1; // C_UDSI(ca,ta,1) = 1;  
										C_UDMI(ca,ta,0) = 1; // itran[ca];
									 }
							//			}
									 densty44:  ;

									 flux = (rlflux + rgflux) / vol;

									 C_R(ca,ta) += flux;
						//			 Message(" C_R(ca,ta) = %f \n ", C_R(ca,ta));
									 C_R(c,t)   -= flux;
									 }  
						}
		
		}
		end_c_loop(c,t)
	}
// moveit()
	thread_loop_c(t,domain)
	{
		begin_c_loop(c,t)
		{
		   t_liquid = THREAD_SUB_THREAD(t,0);
		   t_vapour = THREAD_SUB_THREAD(t,1);
		   
		   t_f = C_FACE_THREAD(c,t,0);
		   
		   					  iphasn = C_UDMI(c,t,1); //iphas; // C_UDSI_M1(c,t,0);
						itran = C_UDMI(c,t,0);		
					//		  if (itran == 1) //(C_UDSI(c,t,1) == 1 )
							  if (itran == 1)
							  { 
					//			  iphase[c] = 2; //C_UDSI(c,t,0) = 2;
								  C_UDMI(c,t,0) = itran;
								  C_UDMI(c,t,1) = 2;
							  }
	  
								chk_neighb(c,t,3,&bulkg);
        
							  if( bulkg ) 
							  { 
					//			  iphase[c] = 3; // C_UDSI(c,t,0) = 3;
								 C_UDMI(c,t,1) = 3;
							  }

							  chk_neighb(c,t,1, &bulkl );
        
							  if( bulkl ) 
							  {
					//			 iphase[c] = 1; // C_UDSI(c,t,0) = 1;
								 C_UDMI(c,t,1) = 1;
							  }

			//				    Message(" 2 bulkg, bulkl = %u %u \n ", bulkg, bulkl);

							  iphs = C_UDMI(c,t,1); //iphase[c];
								if (iphs == 1) //( C_UDSI(c,t,0) == 1 ) 
								{
				//					C_VOF(c,t_vapour) = 0.0;
				//					C_VOF(c,t_liquid) = 1.0;
				//					C_R(c,t_liquid) = ROL;
								}
								else if (iphs == 3) //( C_UDSI(c,t,0) == 3 ) 
								{
				//					C_VOF(c,t_vapour) = 1.0;
				//					C_VOF(c,t_liquid) = 0.0;
				//					  C_R(c,t_vapour) = ROG;	
								}
								else if( C_VOF(c,t_liquid) < tolg ) 
								{
						/*	        if( iphasn == 2 ) 
									{
										nmx( c, t_liquid, &nx, &ny);
										rmag = ( nx*nx + ny*ny );
										if( rmag > pow(10.,-3) ) 
										{
										  qint(c,t, FALSE, &sourcl, &sourcv, &tempn);
										  C_T(c,t) = tempn;
										}
										else
										{
										  C_T(c,t) = TSAT;
                  
										}
									}					*/

					//				 iphase[c] = 3; // C_UDSI(c,t,0) = 3;
									 C_UDMI(c,t,1) = 3;
				//					 C_VOF(c,t_vapour) = 1.0;
				//					 C_VOF(c,t_liquid) = 0.0;
				//					 C_R(c,t) = ROG;
								}
								else if( C_VOF(c,t_liquid) > 1.0-toll ) 
								{
						/*		   if( iphasn == 2 ) 
								   {	
										nmx( c, t_liquid, &nx, &ny);
										rmag = ( nx*nx + ny*ny );
										if( rmag > pow(10.,-3) ) 
										{
										  qint(c, t, TRUE, &sourcl, &sourcv, &tempn);
										  C_T(c,t) = tempn;
										}
										else
										{
										  C_T(c,t) = TSAT;
                  
										}
								   }						*/
						//			 iphase[c] = 1; // C_UDSI(c,t,0) = 1;  
									 C_UDMI(c,t,1) = 1;
				//					 C_VOF(c,t_vapour) = 0.0;
				//					 C_VOF(c,t_liquid) = 1.0;
				//					 C_R(c,t) = ROL;
								}
		
		}
		end_c_loop(c,t)
	}
	thread_loop_c(t,domain)
	{
		begin_c_loop(c,t)
		{
		   t_liquid = THREAD_SUB_THREAD(t,0);
		   t_vapour = THREAD_SUB_THREAD(t,1);
		   
			t_f = C_FACE_THREAD(c,t,0);
	
					if(BOUNDARY_FACE_THREAD_P(t_f))
					{
						/*
						c_node_loop(c,t,n)
						{
						  node = C_NODE(c,t,n);
 		 
	
							if( NODE_X(node) == 0 )
							{
								fr = C_FACE(c,t,2);
								tfr = C_FACE_THREAD(c,t,2);
								fl = C_FACE(c,t,0);					
								tfl = C_FACE_THREAD(c,t,0);			
								ff = C_FACE(c,t,3);					
								tff = C_FACE_THREAD(c,t,3);
								fa = C_FACE(c,t,1);
								tfa = C_FACE_THREAD(c,t,1);
							}

							if( NODE_X(node)*1000000 == 1135 )
							{
								fr = C_FACE(c,t,0);
								tfr = C_FACE_THREAD(c,t,0);
								fl = C_FACE(c,t,2);					
								tfl = C_FACE_THREAD(c,t,2);			
								ff = C_FACE(c,t,1);					
								tff = C_FACE_THREAD(c,t,1);
								fa = C_FACE(c,t,3);
								tfa = C_FACE_THREAD(c,t,3);
							}

							if( NODE_Y(node) == 0 )
							{
								fr = C_FACE(c,t,1);
								tfr = C_FACE_THREAD(c,t,1);
								fl = C_FACE(c,t,3);					
								tfl = C_FACE_THREAD(c,t,3);			
								ff = C_FACE(c,t,2);					
								tff = C_FACE_THREAD(c,t,2);
								fa = C_FACE(c,t,0);
								tfa = C_FACE_THREAD(c,t,0);
							}

							if( NODE_Y(node)*100000 == 227 )
							{
								fr = C_FACE(c,t,3);
								tfr = C_FACE_THREAD(c,t,3);
								fl = C_FACE(c,t,1);					
								tfl = C_FACE_THREAD(c,t,1);			
								ff = C_FACE(c,t,0);					
								tff = C_FACE_THREAD(c,t,0);
								fa = C_FACE(c,t,2);
								tfa = C_FACE_THREAD(c,t,2);
							}		
						}
								*/	
					}
					else
					{
		
								fr = C_FACE(c,t,1);
								tfr = C_FACE_THREAD(c,t,1);
								fl = C_FACE(c,t,3);					/* --------------------- FOR ---------------------- */
								tfl = C_FACE_THREAD(c,t,3);			/* ------------------ INTERIOR -------------------- */ 
								ff = C_FACE(c,t,2);					/* -------------------- CELLS --------------------- */
								tff = C_FACE_THREAD(c,t,2);
								fa = C_FACE(c,t,0);
								tfa = C_FACE_THREAD(c,t,0);

		
								/* ----------- RIGHT FACE ----------- */

								cr = F_C0(fr,tfr);
								if(cr == c)
								{
									cr = F_C1(fr,tfr);
									tr = F_C1_THREAD(fr,tfr);
								}
								else
								{
									tr = F_C0_THREAD(fr,tfr);
								}   
							/* ----------- LEFT FACE ------------ */

								cl = F_C0(fl,tfl);
								if(cl == c)
								{
									cl = F_C1(fl,tfl);
									tl = F_C1_THREAD(fl,tfl);
								}
								else
								{
									tl = F_C0_THREAD(fl,tfl);
								}
							/* ----------- FRONT FACE ------------ */

								cf = F_C0(ff,tff);
								if(cf == c)
								{
									cf = F_C1(ff,tff);
									tf = F_C1_THREAD(ff,tff);
								}
								else
								{
									tf = F_C0_THREAD(ff,tff);
								}

							/* ------------ AFTER FACE ------------ */
								ca = F_C0(fa,tfa);
								if(ca == c)
								{
									ca = F_C1(fa,tfa);
									ta = F_C1_THREAD(fa,tfa);
								}
								else
								{
									ta = F_C0_THREAD(fa,tfa);
								}
	

							iphs = C_UDMI(c,t,1); //iphase[c];; //C_UDSI(c,t,0);

							if( iphs != 1 ) 
							{
								goto moveit11;
							}
							if ( C_UDMI(cr,tr,1) != iphs && C_UDMI(cr,tr,1) != 2)	//( iphase[cr] != iphs && iphase[cr] != 2) //( C_UDSI(cr,tr,0) != iphs && C_UDSI(cr,tr,0) != 2)
							{
					//		  iphase[c] = 2; // C_UDSI(c,t,0) = 2;
							  C_UDMI(c,t,1) = 2;
						 //      C_VOF(c,t) = 1.0;
							}	

							if( C_UDMI(cl,tl,1) != iphs && C_UDMI(cl,tl,1) != 2)  // ( iphase[cl] != iphs && iphase[cl] != 2) //( C_UDSI(cl,tl,0) != iphs && C_UDSI(cl,tl,0) != 2)  
							{
					//			iphase[c] = 2; // C_UDSI(c,t,0) = 2;
								C_UDMI(c,t,1) = 2;
						//       C_VOF(c,t_liquid) = 1.0; 
							}

							if( C_UDMI(cf,tf,1) != iphs && C_UDMI(cf,tf,1) != 2) // ( iphase[cf] != iphs && iphase[cf] != 2) //( C_UDSI(cf,tf,0) != iphs && C_UDSI(cf,tf,0) != 2)
							{
					//		   iphase[c] = 2; //C_UDSI(c,t,0) = 2;
							   C_UDMI(c,t,1) = 2;
						 //      C_VOF(c,t) = 1.0; 
							}

							if( C_UDMI(ca,ta,1) != iphs && C_UDMI(ca,ta,1) != 2)	// ( iphase[ca] != iphs && iphase[ca] != 2) //( C_UDSI(ca,ta,0) != iphs && C_UDSI(ca,ta,0) != 2)  
							{ 
					//		   iphase[c] = 2; //C_UDSI(c,t,0) = 2;
							   C_UDMI(c,t,1) = 2;
						//       C_VOF(c,t) = 1.0; 
							}
	  
					//	  Message(" iphase = %f \n ", C_UDMI(c,t,0));
						moveit11: ;
					}
		  
		}
		end_c_loop(c,t)
	}
// iface()
	thread_loop_c(t,domain)
	{
		if (FLUID_THREAD_P(t))
		{
			begin_c_loop_all(c,t)
			{
					check_r = FALSE;
					check_f = FALSE;
					check_l = FALSE;
					check_a = FALSE;
					boundary = FALSE;

				t_liquid = THREAD_SUB_THREAD(t,0);

		//		Message("itran = %f \t",C_UDMI(c,t,0));

				iphs = C_UDMI(c,t,1); //iphase[c];;

				if ( iphs != 2 )
				{
		//			Message(" Single phase cell \n");
					goto IFACE2_END1;
				}
				else
				{
		//			Message(" Mixture phase cell \n");
					t_f = C_FACE_THREAD(c,t,0);
	
					if(BOUNDARY_FACE_THREAD_P(t_f))
					{
						boundary = TRUE;																									
					/*			c_node_loop(c,t,a)
							{
										  node = C_NODE(c,t,a);

								if( NODE_Y(node) == 0 )
								{

									if( NODE_X(node) == 0 )
									{
											ff = C_FACE(c,t,3);					
											tff = C_FACE_THREAD(c,t,3);
											
											fr = C_FACE(c,t,2);
											tfr = C_FACE_THREAD(c,t,2);

//										 ----------- RIGHT FACE ----------- 

											cr = F_C0(fr,tfr);
											if(cr == c)
											{
												cr = F_C1(fr,tfr);
												tr = F_C1_THREAD(fr,tfr);
											}
											else
											{
												tr = F_C0_THREAD(fr,tfr);
											}   
//										 ----------- FRONT FACE ------------ 

											cf = F_C0(ff,tff);
											if(cf == c)
											{
												cf = F_C1(ff,tff);
												tf = F_C1_THREAD(ff,tff);
											}
											else
											{
												tf = F_C0_THREAD(ff,tff);
											}

											frp = C_FACE(cf,tf,2);
											tfrp = C_FACE_THREAD(cf,tf,2);

//										 ----------- crf cell ----------- 

											crf = F_C0(frp,tfrp);
											if(crf == cf)
											{
												crf = F_C1(frp,tfrp);
												trf = F_C1_THREAD(frp,tfrp);
											}
											else
											{
												trf = F_C0_THREAD(frp,tfrp);
											}   


										fe = (1.0/4.0)*(0.0 + 2*C_VOF(cr,t_liquid) + C_VOF(crf,t_liquid));     
										fw = (1.0/4.0)*(0.0);
										fn = (1.0/4.0)*(0.0 + 2*C_VOF(cf,t_liquid) + C_VOF(crf,t_liquid));
										fs = (1.0/4.0)*(0.0);


									}
									else if( NODE_X(node)*1000000 ==   1135 )
									{
											ff = C_FACE(c,t,2);					
											tff = C_FACE_THREAD(c,t,2);

											fl = C_FACE(c,t,3);			
											tfl = C_FACE_THREAD(c,t,3);	

//										 ----------- LEFT FACE ------------ 

											cl = F_C0(fl,tfl);
											if(cl == c)
											{
												cl = F_C1(fl,tfl);
												tl = F_C1_THREAD(fl,tfl);
											}
											else
											{
												tl = F_C0_THREAD(fl,tfl);
											}


//										 ----------- FRONT FACE ------------ 

											cf = F_C0(ff,tff);
											if(cf == c)
											{
												cf = F_C1(ff,tff);
												tf = F_C1_THREAD(ff,tff);
											}
											else
											{
												tf = F_C0_THREAD(ff,tff);
											}

											flp = C_FACE(cf,tf,2);
											tflp = C_FACE_THREAD(cf,tf,2);

//										 ----------- clf cell ----------- 

											clf = F_C0(flp,tflp);
											if(clf == cf)
											{
												clf = F_C1(flp,tflp);
												tlf = F_C1_THREAD(flp,tflp);
											}
											else
											{
												tlf = F_C0_THREAD(flp,tflp);
											}   

											fe = (1.0/4.0)*(0.0);     
											fw = (1.0/4.0)*(0.0 + 2*C_VOF(cl,t_liquid) + C_VOF(clf,t_liquid));
											fn = (1.0/4.0)*(C_VOF(clf,t_liquid) + 2*C_VOF(cf,t_liquid) + 0.0);
											fs = (1.0/4.0)*(0.0);    

									}
									else
									{
											ff = C_FACE(c,t,2);					
											tff = C_FACE_THREAD(c,t,2);
											
											fr = C_FACE(c,t,1);
											tfr = C_FACE_THREAD(c,t,1);
											
											fl = C_FACE(c,t,3);			
											tfl = C_FACE_THREAD(c,t,3);	

//										 ----------- RIGHT FACE ----------- 

											cr = F_C0(fr,tfr);
											if(cr == c)
											{
												cr = F_C1(fr,tfr);
												tr = F_C1_THREAD(fr,tfr);
											}
											else
											{
												tr = F_C0_THREAD(fr,tfr);
											}   

//										 ----------- LEFT FACE ------------ 

											cl = F_C0(fl,tfl);
											if(cl == c)
											{
												cl = F_C1(fl,tfl);
												tl = F_C1_THREAD(fl,tfl);
											}
											else
											{
												tl = F_C0_THREAD(fl,tfl);
											}


//										 ----------- FRONT FACE ------------ 

											cf = F_C0(ff,tff);
											if(cf == c)
											{
												cf = F_C1(ff,tff);
												tf = F_C1_THREAD(ff,tff);
											}
											else
											{
												tf = F_C0_THREAD(ff,tff);
											}

											frp = C_FACE(cf,tf,1);
											tfrp = C_FACE_THREAD(cf,tf,1);

											flp = C_FACE(cf,tf,3);
											tflp = C_FACE_THREAD(cf,tf,3);

//										 ----------- crf cell ----------- 

											crf = F_C0(frp,tfrp);
											if(crf == cf)
											{
												crf = F_C1(frp,tfrp);
												trf = F_C1_THREAD(frp,tfrp);
											}
											else
											{
												trf = F_C0_THREAD(frp,tfrp);
											}   

//										 ----------- clf cell ----------- 

											clf = F_C0(flp,tflp);
											if(clf == cf)
											{
												clf = F_C1(flp,tflp);
												tlf = F_C1_THREAD(flp,tflp);
											}
											else
											{
												tlf = F_C0_THREAD(flp,tflp);
											}   

											fe = (1.0/4.0)*(0.0 + 2*C_VOF(cr,t_liquid) + C_VOF(crf,t_liquid));     
											fw = (1.0/4.0)*(0.0 + 2*C_VOF(cl,t_liquid) + C_VOF(clf,t_liquid));
											fn = (1.0/4.0)*(C_VOF(clf,t_liquid) + 2*C_VOF(cf,t_liquid) + C_VOF(crf,t_liquid));
											fs = (1.0/4.0)*(0.0);

									}



								}

										if( ( NODE_X(node)*100000 == 0.0 ) && ( NODE_Y(node) > 0.0 ) && ( NODE_Y(node)*100000 != 227 ) )
										{
											ff = C_FACE(c,t,3);					
											tff = C_FACE_THREAD(c,t,3);
											fr = C_FACE(c,t,2);					
											tfr = C_FACE_THREAD(c,t,2);
											fa = C_FACE(c,t,1);
											tfa = C_FACE_THREAD(c,t,1);

//												 ----------- FRONT FACE ------------ 

													cf = F_C0(ff,tff);
													if(cf == c)
													{
														cf = F_C1(ff,tff);
														tf = F_C1_THREAD(ff,tff);
													}
													else
													{
														tf = F_C0_THREAD(ff,tff);
													}

//												 ----------- RIGHT FACE ----------- 

													cr = F_C0(fr,tfr);
													if(cr == c)
													{
														cr = F_C1(fr,tfr);
														tr = F_C1_THREAD(fr,tfr);
													}
													else
													{
														tr = F_C0_THREAD(fr,tfr);
													}   

//												 ------------ AFTER FACE ------------ 

													ca = F_C0(fa,tfa);
													if(ca == c)
													{
														ca = F_C1(fa,tfa);
														ta = F_C1_THREAD(fa,tfa);
													}
													else
													{
														ta = F_C0_THREAD(fa,tfa);
													}

													far  = C_FACE(cr,tr,0);	
													tfar = C_FACE_THREAD(cr,tr,0);

													ffr  = C_FACE(cr,tr,2);	
													tffr = C_FACE_THREAD(cr,tr,2);

//												 ----------- crf cell ----------- 

													crf = F_C0(ffr,tffr);
													if(crf == cr)
													{
														crf = F_C1(ffr,tffr);
														trf = F_C1_THREAD(ffr,tffr);
													}
													else
													{
														trf = F_C0_THREAD(ffr,tffr);
													}   

//												 ----------- cra cell ----------- 

													cra = F_C0(far,tfar);
													if(crf == cr)
													{
														crf = F_C1(far,tfar);
														trf = F_C1_THREAD(far,tfar);
													}
													else
													{
														trf = F_C0_THREAD(far,tfar);
													}   

												fe = (1.0/4.0)*(C_VOF(cra,t_liquid) + 2*C_VOF(cr,t_liquid) + C_VOF(crf,t_liquid));     
												fw = (1.0/4.0)*(0.0);
												fn = (1.0/4.0)*(0.0 + 2*C_VOF(cf,t_liquid) + C_VOF(crf,t_liquid));
												fs = (1.0/4.0)*(0.0 + 2*C_VOF(ca,t_liquid) + C_VOF(cra,t_liquid));  

										}

										if( ( NODE_X(node)*1000000 == 1135 ) && ( NODE_Y(node) > 0.0 ) && ( NODE_Y(node)*100000 != 227 ) )
										{
											ff = C_FACE(c,t,1);					
											tff = C_FACE_THREAD(c,t,1);

											fl = C_FACE(c,t,2);					
											tfl = C_FACE_THREAD(c,t,2);
											
											fa = C_FACE(c,t,3);
											tfa = C_FACE_THREAD(c,t,3);

//												 ----------- FRONT FACE ------------ 

													cf = F_C0(ff,tff);
													if(cf == c)
													{
														cf = F_C1(ff,tff);
														tf = F_C1_THREAD(ff,tff);
													}
													else
													{
														tf = F_C0_THREAD(ff,tff);
													}

//												 ----------- LEFT FACE ------------ 

													cl = F_C0(fl,tfl);
													if(cl == c)
													{
														cl = F_C1(fl,tfl);
														tl = F_C1_THREAD(fl,tfl);
													}
													else
													{
														tl = F_C0_THREAD(fl,tfl);
													}

//												 ------------ AFTER FACE ------------ 

													ca = F_C0(fa,tfa);
													if(ca == c)
													{
														ca = F_C1(fa,tfa);
														ta = F_C1_THREAD(fa,tfa);
													}
													else
													{
														ta = F_C0_THREAD(fa,tfa);
													}

													fal  = C_FACE(cl,tl,0);	
													tfal = C_FACE_THREAD(cl,tl,0);

													ffl  = C_FACE(cl,tl,2);	
													tffl = C_FACE_THREAD(cl,tl,2);

//												 ----------- clf cell ----------- 

													clf = F_C0(ffl,tffl);
													if(clf == cl)
													{
														clf = F_C1(ffl,tffl);
														tlf = F_C1_THREAD(ffl,tffl);
													}
													else
													{
														tlf = F_C0_THREAD(ffl,tffl);
													}   

//												 ----------- cla cell ----------- 

													cla = F_C0(fal,tfal);
													if(clf == cl)
													{
														clf = F_C1(fal,tfal);
														tlf = F_C1_THREAD(fal,tfal);
													}
													else
													{
														tlf = F_C0_THREAD(fal,tfal);
													}   

											fe = (1.0/4.0)*(0.0); 
											fw = (1.0/4.0)*(C_VOF(cla,t_liquid) + 2*C_VOF(cl,t_liquid) + C_VOF(clf,t_liquid));
											fn = (1.0/4.0)*(C_VOF(clf,t_liquid) + 2*C_VOF(cf,t_liquid) + 0.0);
											fs = (1.0/4.0)*(C_VOF(cla,t_liquid) + 2*C_VOF(ca,t_liquid) + 0.0);    

										}



								}				*/

					}
					else
					{
		//			Message("Interior Mixture cell \n");
						fr = C_FACE(c,t,1);
						tfr = C_FACE_THREAD(c,t,1);
						fl = C_FACE(c,t,3);					/* --------------------- FOR ---------------------- */
						tfl = C_FACE_THREAD(c,t,3);			/* ------------------ INTERIOR -------------------- */ 
						ff = C_FACE(c,t,2);					/* -------------------- CELLS --------------------- */
						tff = C_FACE_THREAD(c,t,2);
						fa = C_FACE(c,t,0);
						tfa = C_FACE_THREAD(c,t,0);

					
	
						/* ----------- RIGHT FACE ----------- */

						cr = F_C0(fr,tfr);
						if(cr == c)
						{
							cr = F_C1(fr,tfr);
							tr = F_C1_THREAD(fr,tfr);
						}
						else
						{
							tr = F_C0_THREAD(fr,tfr);
						}   

					/* ----------- LEFT FACE ------------ */

						cl = F_C0(fl,tfl);
						if(cl == c)
						{
							cl = F_C1(fl,tfl);
							tl = F_C1_THREAD(fl,tfl);
						}
						else
						{
							tl = F_C0_THREAD(fl,tfl);
						}
					/* ----------- FRONT FACE ------------ */
						cf = F_C0(ff,tff);
						if(cf == c)
						{
							cf = F_C1(ff,tff);
							tf = F_C1_THREAD(ff,tff);
						}
						else
						{
							tf = F_C0_THREAD(ff,tff);
						}
					/* ------------ AFTER FACE ------------ */
						ca = F_C0(fa,tfa);
						if(ca == c)
						{
							ca = F_C1(fa,tfa);
							ta = F_C1_THREAD(fa,tfa);
						}
						else
						{
							ta = F_C0_THREAD(fa,tfa);
						}

	
			//			Message("%u %u %u %u \n", cr, cl, cf, ca);

						c_face_loop(cr,tr,N)
						{
							t_fr = C_FACE_THREAD(cr,tr,N);
							if( BOUNDARY_FACE_THREAD_P(t_fr) )
							{
								check_r = TRUE;
							}
						}

						c_face_loop(cf,tf,N)
						{
							t_ff = C_FACE_THREAD(cf,tf,N);
							if( BOUNDARY_FACE_THREAD_P(t_ff) )
							{
								check_f = TRUE;
							}
						}

						c_face_loop(cl,tl,N)
						{
							t_fl = C_FACE_THREAD(cl,tl,N);
							if( BOUNDARY_FACE_THREAD_P(t_fl) )
							{
								check_l = TRUE;
							}
						}

						c_face_loop(ca,ta,N)
						{
							t_fa = C_FACE_THREAD(ca,ta,N);
							if( BOUNDARY_FACE_THREAD_P(t_fa) )
							{
								check_a = TRUE;
							}
						}				

				//			Message("%u %u %u %u \n", check_r, check_f, check_l, check_a);

						if( check_r )
						{
				//			Message(" BOUNDARY CELL ENCOUNTERED \n ");
			

								ffr = C_FACE(cr,tr,1);
								tffr = C_FACE_THREAD(cr,tr,1);

								far = C_FACE(cr,tr,3);
								tfar = C_FACE_THREAD(cr,tr,3);

								ffl = C_FACE(cl,tl,2);
								tffl = C_FACE_THREAD(cl,tl,2);

								fal = C_FACE(cl,tl,0);
								tfal = C_FACE_THREAD(cl,tl,0);

					
							/* ======================== (crf,trf) ============================= */

								crf = F_C0(ffr,tffr);
								if(crf == cr)
								{
									crf = F_C1(ffr,tffr);
									trf = F_C1_THREAD(ffr,tffr);
								}
								else
								{
									trf = F_C0_THREAD(ffr,tffr);
								}
					//			Message(" crf = %u \n ", crf);
							/* ======================== (cra,tra) ============================= */

								cra = F_C0(far,tfar);
								if(cra == cr)
								{
									cra = F_C1(far,tfar);
									tra = F_C1_THREAD(far,tfar);
								}
								else
								{
									tra = F_C0_THREAD(far,tfar);
								}
					//			Message(" cra = %u \n ", cra);	
							/* ======================== (clf,tlf) ============================= */

								clf = F_C0(ffl,tffl);
								if(clf == cl)
								{
									clf = F_C1(ffl,tffl);
									tlf = F_C1_THREAD(ffl,tffl);
								}
								else
								{
									tlf = F_C0_THREAD(ffl,tffl);
								}
					//			Message(" clf = %u \n ", clf);
							/* ======================== (cla,tla) ============================= */

								cla = F_C0(fal,tfal);
								if(cla == cl)
								{
									cla = F_C1(fal,tfal);
									tla = F_C1_THREAD(fal,tfal);
								}
								else
								{
									tla = F_C0_THREAD(fal,tfal);
								}
					//			Message(" cla = %u \n ", cla);
		
						}
						else if ( check_f )
						{
			
								frp = C_FACE(cf,tf,3);
								tfrp = C_FACE_THREAD(cf,tf,3);

								flp = C_FACE(cf,tf,1);
								tflp = C_FACE_THREAD(cf,tf,1);

								frm = C_FACE(ca,ta,1);
								tfrm = C_FACE_THREAD(ca,ta,1);

								flm = C_FACE(ca,ta,3);
								tflm = C_FACE_THREAD(ca,ta,3);

							/* ======================== (crf,trf) ============================= */

								crf = F_C0(frp,tfrp);
								if(crf == cr)
								{
									crf = F_C1(frp,tfrp);
									trf = F_C1_THREAD(frp,tfrp);
								}
								else
								{
									trf = F_C0_THREAD(frp,tfrp);
								}

							/* ======================== (clf,tlf) ============================= */

								clf = F_C0(flp,tflp);
								if(clf == cl)
								{
									clf = F_C1(flp,tflp);
									tlf = F_C1_THREAD(flp,tflp);
								}
								else
								{
									tlf = F_C0_THREAD(flp,tflp);
								}

							/* ======================== (cra,tra) ============================= */

								cra = F_C0(frm,tfrm);
								if(cra == cr)
								{
									cra = F_C1(frm,tfrm);
									tra = F_C1_THREAD(frm,tfrm);
								}
								else
								{
									tra = F_C0_THREAD(frm,tfrm);
								}

							/* ======================== (cla,tla) ============================= */

								cla = F_C0(flm,tflm);
								if(cla == cl)
								{
									cla = F_C1(flm,tflm);
									tla = F_C1_THREAD(flm,tflm);
								}
								else
								{
									tla = F_C0_THREAD(flm,tflm);
								}
			
						}
						else if ( check_l ) 
						{
			
								ffl = C_FACE(cl,tl,3);
								tffl = C_FACE_THREAD(cl,tl,3);

								fal = C_FACE(cl,tl,1);
								tfal = C_FACE_THREAD(cl,tl,1);

								ffr = C_FACE(cr,tr,2);
								tffr = C_FACE_THREAD(cr,tr,2);

								far = C_FACE(cr,tr,0);
								tfar = C_FACE_THREAD(cr,tr,0);

							/* ======================== (crf,trf) ============================= */

								crf = F_C0(ffr,tffr);
								if(crf == cr)
								{
									crf = F_C1(ffr,tffr);
									trf = F_C1_THREAD(ffr,tffr);
								}
								else
								{
									trf = F_C0_THREAD(ffr,tffr);
								}
					//			Message(" crf = %u \n ", crf);
							/* ======================== (cra,tra) ============================= */

								cra = F_C0(far,tfar);
								if(cra == cr)
								{
									cra = F_C1(far,tfar);
									tra = F_C1_THREAD(far,tfar);
								}
								else
								{
									tra = F_C0_THREAD(far,tfar);
								}
					//			Message(" cra = %u \n ", cra);	
							/* ======================== (clf,tlf) ============================= */

								clf = F_C0(ffl,tffl);
								if(clf == cl)
								{
									clf = F_C1(ffl,tffl);
									tlf = F_C1_THREAD(ffl,tffl);
								}
								else
								{
									tlf = F_C0_THREAD(ffl,tffl);
								}
					//			Message(" clf = %u \n ", clf);
							/* ======================== (cla,tla) ============================= */

								cla = F_C0(fal,tfal);
								if(cla == cl)
								{
									cla = F_C1(fal,tfal);
									tla = F_C1_THREAD(fal,tfal);
								}
								else
								{
									tla = F_C0_THREAD(fal,tfal);
								}
					//			Message(" cla = %u \n ", cla);
		
			
						}
						else if ( check_a )
						{
			
								frm = C_FACE(ca,ta,1);
								tfrm = C_FACE_THREAD(ca,ta,1);

								flm = C_FACE(ca,ta,3);
								tflm = C_FACE_THREAD(ca,ta,3);

								frp = C_FACE(cf,tf,1);
								tfrp = C_FACE_THREAD(cf,tf,1);

								flp = C_FACE(cf,tf,3);
								tflp = C_FACE_THREAD(cf,tf,3);
			
							/* ======================== (crf,trf) ============================= */

								crf = F_C0(frp,tfrp);
								if(crf == cr)
								{
									crf = F_C1(frp,tfrp);
									trf = F_C1_THREAD(frp,tfrp);
								}
								else
								{
									trf = F_C0_THREAD(frp,tfrp);
								}

							/* ======================== (clf,tlf) ============================= */

								clf = F_C0(flp,tflp);
								if(clf == cl)
								{
									clf = F_C1(flp,tflp);
									tlf = F_C1_THREAD(flp,tflp);
								}
								else
								{
									tlf = F_C0_THREAD(flp,tflp);
								}

							/* ======================== (cra,tra) ============================= */

								cra = F_C0(frm,tfrm);
								if(cra == cr)
								{
									cra = F_C1(frm,tfrm);
									tra = F_C1_THREAD(frm,tfrm);
								}
								else
								{
									tra = F_C0_THREAD(frm,tfrm);
								}

							/* ======================== (cla,tla) ============================= */

								cla = F_C0(flm,tflm);
								if(cla == cl)
								{
									cla = F_C1(flm,tflm);
									tla = F_C1_THREAD(flm,tflm);
								}
								else
								{
									tla = F_C0_THREAD(flm,tflm);
								}
						}
						else
						{
				/* ============== DEFINITION OF SECONDARY NEIGHBOURS ============== */

 
							ffr = C_FACE(cr,tr,2);
							tffr = C_FACE_THREAD(cr,tr,2);

							far = C_FACE(cr,tr,0);
							tfar = C_FACE_THREAD(cr,tr,0);

							ffl = C_FACE(cl,tl,2);
							tffl = C_FACE_THREAD(cl,tl,2);

							fal = C_FACE(cl,tl,0);
							tfal = C_FACE_THREAD(cl,tl,0);

				//		Message("  far, tfar, ffl, tffl, fal, tfal =  %u %u %u %u %u %u  \n ", far, tfar, ffl, tffl, fal, tfal); 

		

						/* ======================== (crf,trf) ============================= */

							crf = F_C0(ffr,tffr);
							if(crf == cr)
							{
								crf = F_C1(ffr,tffr);
								trf = F_C1_THREAD(ffr,tffr);
							}
							else
							{
								trf = F_C0_THREAD(ffr,tffr);
							}
				//			Message(" crf = %u \n ", crf);
						/* ======================== (cra,tra) ============================= */

							cra = F_C0(far,tfar);
							if(cra == cr)
							{
								cra = F_C1(far,tfar);
								tra = F_C1_THREAD(far,tfar);
							}
							else
							{
								tra = F_C0_THREAD(far,tfar);
							}
				//			Message(" cra = %u \n ", cra);	
						/* ======================== (clf,tlf) ============================= */

							clf = F_C0(ffl,tffl);
							if(clf == cl)
							{
								clf = F_C1(ffl,tffl);
								tlf = F_C1_THREAD(ffl,tffl);
							}
							else
							{
								tlf = F_C0_THREAD(ffl,tffl);
							}
				//			Message(" clf = %u \n ", clf);
						/* ======================== (cla,tla) ============================= */

							cla = F_C0(fal,tfal);
							if(cla == cl)
							{
								cla = F_C1(fal,tfal);
								tla = F_C1_THREAD(fal,tfal);
							}
							else
							{
								tla = F_C0_THREAD(fal,tfal);
							}
				//			Message(" cla = %u \n ", cla);
		
						}
//	Message("%u %u %u %u %u %u %u %u \n", check_r, check_f, check_l, check_a, crf, clf, cra, cla);
						
		

						fe = (1.0/4.0)*(C_VOF(cra,t_liquid) + 2*C_VOF(cr,t_liquid) + C_VOF(crf,t_liquid));     /* NOTE: t_liquid will be different for cells as they are having different threads */
						fw = (1.0/4.0)*(C_VOF(cla,t_liquid) + 2*C_VOF(cl,t_liquid) + C_VOF(clf,t_liquid));
						fn = (1.0/4.0)*(C_VOF(clf,t_liquid) + 2*C_VOF(cf,t_liquid) + C_VOF(crf,t_liquid));
						fs = (1.0/4.0)*(C_VOF(cla,t_liquid) + 2*C_VOF(ca,t_liquid) + C_VOF(cra,t_liquid));    
		
				

						nx = (1.0/2.0)*(fe-fw);
						ny = (1.0/2.0)*(fn-fs);

						rmag2 = nx*nx + ny*ny;
					//	rmag = sqrt(rmag2);
						ax = nx/sqrt(rmag2);
						ay = ny/sqrt(rmag2);
		
		//				Message("after nxi,nyi,nxf,nyf = %.15f %.15f %.15f %.15f \n ", nx, ny, ax, ay);
		
		
						if (rmag2 > 0.001)
						{
							rmag = sqrt(rmag2);
							nx = nx/rmag;
							ny = ny/rmag;
				//			Message(" 2 rmag = %f \n ", rmag );
							if( ( (nx != nx) && (ny != ny) ) || ( (nx != nx) || (ny != ny) ) )
							{
				//				Message(" nxi,nyi,nxf,nyf = %.15f %.15f %.15f %.15f \n ", (1.0/2.0)*(fe-fw), (1.0/2.0)*(fn-fs), nx, ny);
							}
							else
							{
								C_UDMI(c,t,2) =	nx;
								C_UDMI(c,t,3) =	ny;
							}

						}							

//				Youngs method represents first guess

						get_len(c, t_liquid, nx, ny);



//						if(C_UDMI(c,t,5) < 0.0001 )
//						{

//							goto IFACE2_GET_LEN_END;
//						}

						nxy = nx;
						nyy = ny;
						sleny = C_UDMI(c,t,4);
						thetay = atan2(nyy,nxy);
					

	/*					if ( boundary )
						{
							    c_node_loop(c,t,k)
								{
									  node = C_NODE(c,t,k);

									if( NODE_Y(node) == 0 )
									{
										if(NODE_X(node) == 0)
										{
											save_len[1][1] = 0.0 ;
											save_len[2][1] = 0.0   ;
											save_len[3][1] = 0.0 ;
											save_len[1][2] = C_UDMI(cf,tf,4)   ;
											save_len[2][2] = C_UDMI(c,t,4)     ;
											save_len[3][2] = 0.0   ;
											save_len[1][3] = C_UDMI(crf,trf,4) ;
											save_len[2][3] = C_UDMI(cr,tr,4)   ;
											save_len[3][3] = 0.0 ;

											save_nx[1][1] = 0.0 ;
											save_nx[2][1] = 0.0   ;
											save_nx[3][1] = 0.0 ;
											save_nx[1][2] = C_UDMI(cf,tf,2)   ;
											save_nx[2][2] = C_UDMI(c,t,2)     ;
											save_nx[3][2] = 0.0   ;
											save_nx[1][3] = C_UDMI(crf,trf,2) ;
											save_nx[2][3] = C_UDMI(cr,tr,2)   ;
											save_nx[3][3] = 0.0 ;

											save_ny[1][1] = 0.0 ;
											save_ny[2][1] = 0.0   ;
											save_ny[3][1] = 0.0 ;
											save_ny[1][2] = C_UDMI(cf,tf,3)   ;
											save_ny[2][2] = C_UDMI(c,t,3)     ;
											save_ny[3][2] = 0.0   ;
											save_ny[1][3] = C_UDMI(crf,trf,3) ;
											save_ny[2][3] = C_UDMI(cr,tr,3)   ;
											save_ny[3][3] = 0.0	 ;
										}
										else if( NODE_X(node)*1000000 == 1135 )
										{
											save_len[1][1] = C_UDMI(clf,tlf,4) ;
											save_len[2][1] = C_UDMI(cl,tl,4)   ;
											save_len[3][1] = 0.0 ;
											save_len[1][2] = C_UDMI(cf,tf,4)   ;
											save_len[2][2] = C_UDMI(c,t,4)     ;
											save_len[3][2] = 0.0   ;
											save_len[1][3] = 0.0 ;
											save_len[2][3] = 0.0   ;
											save_len[3][3] = 0.0 ;

											save_nx[1][1] = C_UDMI(clf,tlf,2) ;
											save_nx[2][1] = C_UDMI(cl,tl,2)   ;
											save_nx[3][1] = 0.0 ;
											save_nx[1][2] = C_UDMI(cf,tf,2)   ;
											save_nx[2][2] = C_UDMI(c,t,2)     ;
											save_nx[3][2] = 0.0   ;
											save_nx[1][3] = 0.0   ;
											save_nx[2][3] = 0.0   ;
											save_nx[3][3] = 0.0	  ;

											save_ny[1][1] = C_UDMI(clf,tlf,3) ;
											save_ny[2][1] = C_UDMI(cl,tl,3)   ;
											save_ny[3][1] = 0.0 ;
											save_ny[1][2] = C_UDMI(cf,tf,3)   ;
											save_ny[2][2] = C_UDMI(c,t,3)     ;
											save_ny[3][2] = 0.0   ;
											save_ny[1][3] = 0.0   ;
											save_ny[2][3] = 0.0   ;
											save_ny[3][3] = 0.0   ;
										}
										else
										{
											save_len[1][1] = C_UDMI(clf,tlf,4) ;
											save_len[2][1] = C_UDMI(cl,tl,4)   ;
											save_len[3][1] = 0.0 ;
											save_len[1][2] = C_UDMI(cf,tf,4)   ;
											save_len[2][2] = C_UDMI(c,t,4)     ;
											save_len[3][2] = 0.0   ;
											save_len[1][3] = C_UDMI(crf,trf,4) ;
											save_len[2][3] = C_UDMI(cr,tr,4)   ;
											save_len[3][3] = 0.0 ;

											save_nx[1][1] = C_UDMI(clf,tlf,2) ;
											save_nx[2][1] = C_UDMI(cl,tl,2)   ;
											save_nx[3][1] = 0.0   ;
											save_nx[1][2] = C_UDMI(cf,tf,2)   ;
											save_nx[2][2] = C_UDMI(c,t,2)     ;
											save_nx[3][2] = 0.0   ;
											save_nx[1][3] = C_UDMI(crf,trf,2) ;
											save_nx[2][3] = C_UDMI(cr,tr,2)   ;
											save_nx[3][3] = 0.0	  ;

											save_ny[1][1] = C_UDMI(clf,tlf,3) ;
											save_ny[2][1] = C_UDMI(cl,tl,3)   ;
											save_ny[3][1] = 0.0   ;
											save_ny[1][2] = C_UDMI(cf,tf,3)   ;
											save_ny[2][2] = C_UDMI(c,t,3)     ;
											save_ny[3][2] = 0.0   ;
											save_ny[1][3] = C_UDMI(crf,trf,3) ;
											save_ny[2][3] = C_UDMI(cr,tr,3)   ;
											save_ny[3][3] = 0.0   ;
										}
						

									}

									if( ( NODE_X(node) == 0 ) && ( NODE_Y(node) > 0.0 ) &&  ( NODE_Y(node)*100000 != 227 ) )
									{
										save_len[1][1] = 0.0 ;
										save_len[2][1] = 0.0   ;
										save_len[3][1] = 0.0 ;
										save_len[1][2] = C_UDMI(cf,tf,4)   ;
										save_len[2][2] = C_UDMI(c,t,4)     ;
										save_len[3][2] = C_UDMI(ca,ta,4)   ;
										save_len[1][3] = C_UDMI(crf,trf,4) ;
										save_len[2][3] = C_UDMI(cr,tr,4)   ;
										save_len[3][3] = C_UDMI(cra,tra,4) ;

										save_nx[1][1] = 0.0 ;
										save_nx[2][1] = 0.0   ;
										save_nx[3][1] = 0.0 ;
										save_nx[1][2] = C_UDMI(cf,tf,2)   ;
										save_nx[2][2] = C_UDMI(c,t,2)     ;
										save_nx[3][2] = C_UDMI(ca,ta,2)   ;
										save_nx[1][3] = C_UDMI(crf,trf,2) ;
										save_nx[2][3] = C_UDMI(cr,tr,2)   ;
										save_nx[3][3] = C_UDMI(cra,tra,2) ;

										save_ny[1][1] = 0.0 ;
										save_ny[2][1] = 0.0 ;
										save_ny[3][1] = 0.0 ;
										save_ny[1][2] = C_UDMI(cf,tf,3)   ;
										save_ny[2][2] = C_UDMI(c,t,3)     ;
										save_ny[3][2] = C_UDMI(ca,ta,3)   ;
										save_ny[1][3] = C_UDMI(crf,trf,3) ;
										save_ny[2][3] = C_UDMI(cr,tr,3)   ;
										save_ny[3][3] = C_UDMI(cra,tra,3) ;

									}
									if( ( NODE_X(node)*1000000 == 1135 ) && ( NODE_Y(node) > 0.0 ) &&  ( NODE_Y(node)*100000 != 227 ) )
									{
										save_len[1][1] = C_UDMI(clf,tlf,4) ;
										save_len[2][1] = C_UDMI(cl,tl,4)   ;
										save_len[3][1] = C_UDMI(cla,tla,4) ;
										save_len[1][2] = C_UDMI(cf,tf,4)   ;
										save_len[2][2] = C_UDMI(c,t,4)     ;
										save_len[3][2] = C_UDMI(ca,ta,4)   ;
										save_len[1][3] = 0.0 ;
										save_len[2][3] = 0.0   ;
										save_len[3][3] = 0.0 ;

										save_nx[1][1] = C_UDMI(clf,tlf,2) ;
										save_nx[2][1] = C_UDMI(cl,tl,2)   ;
										save_nx[3][1] = C_UDMI(cla,tla,2) ;
										save_nx[1][2] = C_UDMI(cf,tf,2)   ;
										save_nx[2][2] = C_UDMI(c,t,2)     ;
										save_nx[3][2] = C_UDMI(ca,ta,2)   ;
										save_nx[1][3] = 0.0 ;
										save_nx[2][3] = 0.0   ;
										save_nx[3][3] = 0.0 ;

										save_ny[1][1] = C_UDMI(clf,tlf,3) ;
										save_ny[2][1] = C_UDMI(cl,tl,3)   ;
										save_ny[3][1] = C_UDMI(cla,tla,3) ;
										save_ny[1][2] = C_UDMI(cf,tf,3)   ;
										save_ny[2][2] = C_UDMI(c,t,3)     ;
										save_ny[3][2] = C_UDMI(ca,ta,3)   ;
										save_ny[1][3] = 0.0 ;
										save_ny[2][3] = 0.0   ;
										save_ny[3][3] = 0.0 ;
									}		
								}
						
						}
						else			
						{								*/
	/*		I AM NOTHING				save_len[1][1] = C_UDMI(clf,t,4) ;
										save_len[2][1] = C_UDMI(cl,t,4)   ;
										save_len[3][1] = C_UDMI(cla,t,4) ;
										save_len[1][2] = C_UDMI(cf,t,4)   ;
										save_len[2][2] = C_UDMI(c,t,4)     ;
										save_len[3][2] = C_UDMI(ca,t,4)   ;
										save_len[1][3] = C_UDMI(crf,t,4) ;
										save_len[2][3] = C_UDMI(cr,t,4)   ;
										save_len[3][3] = C_UDMI(cra,t,4) ;

										save_nx[1][1] = C_UDMI(clf,t,2) ;
										save_nx[2][1] = C_UDMI(cl,t,2)   ;
										save_nx[3][1] = C_UDMI(cla,t,2) ;
										save_nx[1][2] = C_UDMI(cf,t,2)   ;
										save_nx[2][2] = C_UDMI(c,t,2)     ;
										save_nx[3][2] = C_UDMI(ca,t,2)   ;
										save_nx[1][3] = C_UDMI(crf,t,2) ;
										save_nx[2][3] = C_UDMI(cr,t,2)   ;
										save_nx[3][3] = C_UDMI(cra,t,2) ;

										save_ny[1][1] = C_UDMI(clf,t,3) ;
										save_ny[2][1] = C_UDMI(cl,t,3)   ;
										save_ny[3][1] = C_UDMI(cla,t,3) ;
										save_ny[1][2] = C_UDMI(cf,t,3)   ;
										save_ny[2][2] = C_UDMI(c,t,3)     ;
										save_ny[3][2] = C_UDMI(ca,t,3)   ;
										save_ny[1][3] = C_UDMI(crf,t,3) ;
										save_ny[2][3] = C_UDMI(cr,t,3)   ;
										save_ny[3][3] = C_UDMI(cra,t,3) ;					*/
	//					}

//					Message(" nx  = \n %f %f %f \n %f %f %f \n %f %f %f \n ", save_nx[1][1], save_nx[2][1], save_nx[3][1], save_nx[1][2], save_nx[2][2], save_nx[3][2], save_nx[1][3], save_nx[2][3], save_nx[3][3]);
//					Message(" ny  = \n %f %f %f \n %f %f %f \n %f %f %f \n ", save_ny[1][1], save_ny[2][1], save_ny[3][1], save_ny[1][2], save_ny[2][2], save_ny[3][2], save_ny[1][3], save_ny[2][3], save_ny[3][3]);

//					Newton's method to find normal using LVIRA

					     theta = atan2(ny,nx);
					     dtheta = 0.001;
					     Gerr = 1.0;
					     ifter = 0;
					     maxiter = 150;
					
					
IFACE2_lvira11: ;

					if ( (fabs(Gerr) >= pow(10.,-8))  && ifter < maxiter  )
					{


						ifter = ifter + 1;

						lvira(c, t, theta, dtheta, &Gfunp);

						if( (fabs(Gfunp) <= 0.000001) )		
						{
							if( C_UDMI(c,t,5) < 0.0001 )
							{

								nx = C_UDMI(c,t,2);
								ny = C_UDMI(c,t,3);
								goto IFACE2_GET_LEN_END;
							}
							else
							{

								nx = cos(theta);
								ny = sin(theta);
							goto IFACE2_check11;
							}
						}
				
						thetar = theta + dtheta;

						lvira(c, t, thetar, dtheta, &Gfunpr);			// theta-right

						Gprime = (Gfunpr - Gfunp)/dtheta;

						IsFiniteNumber(Gprime, &INF) ;
						if(INF)
						{
							goto IFACE2_END1;
							Message(" Gprime = %u %f %f %f \n ", c, Gfunpr, Gfunp ,Gprime);
						}

						theta_inc = - Gfunp/Gprime;

						theta = theta + theta_inc;

						nx = cos(theta);
						ny = sin(theta);

						Gerr = fabs(theta_inc);

						get_len(c, t_liquid, nx, ny );

						if(C_UDMI(c,t,5) < 0.0001 )
						{

								C_UDMI(c,t,2) = nx;
								C_UDMI(c,t,3) = ny;
							goto IFACE2_GET_LEN_END;
						}

						goto IFACE2_lvira11;
					}
IFACE2_check11: ;



						if ( ifter > maxiter)
						{

							nx = nxy;
							ny = nyy;
							C_UDMI(c,t,4) = sleny;
						}
						thetal = atan2(ny,nx);
						if( fabs(thetal - thetay) > M_PI/20.0 )
						{

							nx = nxy;
							ny = nyy;
							C_UDMI(c,t,4) = sleny;
						}
				


						C_UDMI(c,t,2) = nx;
						C_UDMI(c,t,3) = ny;

						get_len(c, t_liquid, nx, ny );

IFACE2_GET_LEN_END:;


	/*					if ( boundary )
						{
							    c_node_loop(c,t,k)
								{
									  node = C_NODE(c,t,k);

									if( NODE_Y(node) == 0 )
									{
										if(NODE_X(node) == 0)
										{

											C_UDMI(cf,tf,4)   = save_len[1][2] ;
											
											C_UDMI(crf,trf,4) = save_len[1][3] ;
											C_UDMI(cr,tr,4)   = save_len[2][3] ;
											

										
											C_UDMI(cf,tf,2)   = save_nx[1][2] ;
											
											C_UDMI(crf,trf,2) = save_nx[1][3] ;
											C_UDMI(cr,tr,2)   = save_nx[2][3] ;
											

										
											C_UDMI(cf,tf,3)   = save_ny[1][2] ;
											
											C_UDMI(crf,trf,3) = save_ny[1][3] ;
											C_UDMI(cr,tr,3)   = save_ny[2][3] ;
											
										}
										else if( NODE_X(node)*1000000 == 1135 )
										{
											C_UDMI(clf,tlf,4) = save_len[1][1] ;
											C_UDMI(cl,tl,4)   = save_len[2][1] ;
											C_UDMI(cf,tf,4)   = save_len[1][2] ;
											

											C_UDMI(clf,tlf,2) = save_nx[1][1] ;
											C_UDMI(cl,tl,2)   = save_nx[2][1] ;
											C_UDMI(cf,tf,2)   = save_nx[1][2] ;
											

											C_UDMI(clf,tlf,3) = save_ny[1][1] ;
											C_UDMI(cl,tl,3)   = save_ny[2][1] ;
											C_UDMI(cf,tf,3)   = save_ny[1][2] ;
											
														
										}
										else
										{
											C_UDMI(clf,tlf,4) = save_len[1][1] ;
											C_UDMI(cl,tl,4)   = save_len[2][1] ;
											C_UDMI(cf,tf,4)   = save_len[1][2] ;
											C_UDMI(crf,trf,4) = save_len[1][3] ;
											C_UDMI(cr,tr,4)   = save_len[2][3] ;

											C_UDMI(clf,tlf,2) = save_nx[1][1] ;
											C_UDMI(cl,tl,2)   = save_nx[2][1] ;
											C_UDMI(cf,tf,2)   = save_nx[1][2] ;
											C_UDMI(crf,trf,2) = save_nx[1][3] ;
											C_UDMI(cr,tr,2)   = save_nx[2][3] ;

											C_UDMI(clf,tlf,3) = save_ny[1][1] ;
											C_UDMI(cl,tl,3)   = save_ny[2][1] ;
											C_UDMI(cf,tf,3)   = save_ny[1][2] ;
											C_UDMI(crf,trf,3) = save_ny[1][3] ;
											C_UDMI(cr,tr,3)   = save_ny[2][3] ;

										}
						

									}

									if( ( NODE_X(node) == 0 ) && ( NODE_Y(node) > 0.0 ) &&  ( NODE_Y(node)*100000 != 227 ) )
									{
											C_UDMI(cf,tf,4)   = save_len[1][2] ;
											C_UDMI(ca,ta,4)   = save_len[3][2] ;
											C_UDMI(crf,trf,4) = save_len[1][3] ;
											C_UDMI(cr,tr,4)   = save_len[2][3] ;
											C_UDMI(cra,tra,4) = save_len[3][3] ;

											C_UDMI(cf,tf,2)   = save_nx[1][2] ;
											C_UDMI(ca,ta,2)   = save_nx[3][2] ;
											C_UDMI(crf,trf,2) = save_nx[1][3] ;
											C_UDMI(cr,tr,2)   = save_nx[2][3] ;
											C_UDMI(cra,tra,2) = save_nx[3][3] ;

											C_UDMI(cf,tf,3)   = save_ny[1][2] ;
											C_UDMI(ca,ta,3)   = save_ny[3][2] ;
											C_UDMI(crf,trf,3) = save_ny[1][3] ;
											C_UDMI(cr,tr,3)   = save_ny[2][3] ;
											C_UDMI(cra,tra,3) = save_ny[3][3] ;

									}
									if( ( NODE_X(node)*1000000 == 1135 ) && ( NODE_Y(node) > 0.0 ) &&  ( NODE_Y(node)*100000 != 227 ) )
									{
											C_UDMI(clf,tlf,4) = save_len[1][1] ;
											C_UDMI(cl,tl,4)   = save_len[2][1] ;
											C_UDMI(cla,tla,4) = save_len[3][1] ;
											C_UDMI(cf,tf,4)   = save_len[1][2] ;
											C_UDMI(ca,ta,4)   = save_len[3][2] ;

											C_UDMI(clf,tlf,2) = save_nx[1][1] ;
											C_UDMI(cl,tl,2)   = save_nx[2][1] ;
											C_UDMI(cla,tla,2) = save_nx[3][1] ;
											C_UDMI(cf,tf,2)   = save_nx[1][2] ;
											C_UDMI(ca,ta,2)   = save_nx[3][2] ;

											C_UDMI(clf,tlf,3) = save_ny[1][1] ;
											C_UDMI(cl,tl,3)   = save_ny[2][1] ;
											C_UDMI(cla,tla,3) = save_ny[3][1] ;
											C_UDMI(cf,tf,3)   = save_ny[1][2] ;
											C_UDMI(ca,ta,3)   = save_ny[3][2] ;
									}		
								}
						
						}
						else			
						{															*/
	/* I AM BHARAT									C_UDMI(clf,t,4) = save_len[1][1] ;
										C_UDMI(cl,t,4)   = save_len[2][1] ;
										C_UDMI(cla,t,4) = save_len[3][1] ;
										C_UDMI(cf,t,4)   = save_len[1][2] ;
										C_UDMI(ca,t,4)   = save_len[3][2] ;
										C_UDMI(crf,t,4) = save_len[1][3] ;
										C_UDMI(cr,t,4)   = save_len[2][3] ;
										C_UDMI(cra,t,4) = save_len[3][3] ;

										C_UDMI(clf,t,2) = save_nx[1][1] ;
										C_UDMI(cl,t,2)   = save_nx[2][1] ;
										C_UDMI(cla,t,2) = save_nx[3][1] ;
										C_UDMI(cf,t,2)   = save_nx[1][2] ;
										C_UDMI(ca,t,2)   = save_nx[3][2] ;
										C_UDMI(crf,t,2) = save_nx[1][3] ;
										C_UDMI(cr,t,2)   = save_nx[2][3] ;
										C_UDMI(cra,t,2) = save_nx[3][3] ;

										C_UDMI(clf,t,3) = save_ny[1][1] ;
										C_UDMI(cl,t,3)   = save_ny[2][1] ;
										C_UDMI(cla,t,3) = save_ny[3][1] ;
										C_UDMI(cf,t,3)   = save_ny[1][2] ;
										C_UDMI(ca,t,3)   = save_ny[3][2] ;
										C_UDMI(crf,t,3) = save_ny[1][3] ;
										C_UDMI(cr,t,3)   = save_ny[2][3] ;
										C_UDMI(cra,t,3) = save_ny[3][3] ;				*/
//						}

//		
					
						
				}
IFACE2_END1:;
			  }

	//	Message("2nd iface - after - c, iphs, C_UDMI(c,t,2), C_UDMI(c,t,3)  = %u %d %.15f %.15f \n", c, iphs, C_UDMI(c,t,2), C_UDMI(c,t,3));
			}
			end_c_loop_all(c,t)
		}
	}


#endif
}


// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

/* This DEFINE_ADJUST function is used to impose a boundary condition at the bottom wall.
   This will ensure first cells are always vapour cell as is done in FORTRAN CODE */
DEFINE_ADJUST(adjust,d)
{
	Thread *t, *tf, *t_vapour;
	cell_t c, cf;
	Node *node;
	int i;
	real xf[ND_ND];
	real  nx, ny;
	int iphs;

	thread_loop_c(t,d)
	{
		if (FLUID_THREAD_P(t))
		{
			begin_c_loop_all(c,t)
			{
				cf = C_FACE(c,t,0);
				tf = C_FACE_THREAD(c,t,0);
				
				t_vapour = THREAD_SUB_THREAD(t,1);

				C_CENTROID(xf,cf,tf);

	//			Message(" iphs, nx, ny = %d %f %f \n ", C_UDMI(c,t,1), C_UDMI(c,t,2), C_UDMI(c,t,3) );
				
					if(fequal( xf[1] , 0.001135/360.0))
					{
						C_UDMI(c,t,1) = 3;
						C_VOF(c,t_vapour) = 1.0;
					//	Message(" Vapour Cell \n ");
					}

					if(C_UDMI(c,t,1) == 2)
					{
						C_T(c,t) = TSAT;
					}
//					iphs = iphase[c];
				
//					nmx( c, t_liquid, iphs, &nx, &ny);
//					Message("nx2,ny2 = %g %g \n", nx, ny);
//					normx[c] = nx;
//					normy[c] = ny;
				
			}
			end_c_loop_all(c,t)
		}
	}
}


/* THIS PART is used for initialising nx, ny values using LVIRA method. 
   Refer G.Biswas Notes and iface() subroutine file for further clarification. */

// IMPORTANT NOTE: In This Macro Boundary cells are not considered. SO if we are not considering boundary cells then this part becomes grid geometry independent. 
//  But if in future we include boundary cells as well then This part needs to be changed for different geometry.
DEFINE_INIT(normal,d)
{																							// MODIFIED PART OF THIS UDF.............
	Thread *t, *t_liquid;													
	cell_t c, cf, ca,cr,cl,crf,cra,clf,cla;
	Thread *tf,*ta,*tr,*tl,*trf,*tra,*tlf,*tla;
	Thread *t_f;
	Node *node;
	face_t fr,ff,fl,fa,ffr,far,ffl,fal,frp,flp,frm,flm;
	Thread *tfr,*tff,*tfl,*tfa,*tffr,*tfar,*tffl,*tfal, *tfrp, *tflp, *tfrm, *tflm;
	real X[ND_ND],XC[ND_ND];
	float XS[3];
	int i,j,k,n,nr,nl,nf,na,N,r,l,f,a, iphs;
	real xc[ND_ND],xcr[ND_ND];
	cell_t *cell;
	Thread  *threadf, *threadface;
	Thread *t_fr, *t_ff, *t_fl, *t_fa;

	cxboolean check_r ;
	cxboolean check_f ;
	cxboolean check_l ;
	cxboolean check_a ;
	cxboolean boundary ;
	real nx, ny, ax, ay;
	real fe,fw,fn,fs;
	real rmag2,rmag;
	real len;

	int niter,itermx,maxiter,ifter;
	real nxy, nyy, sleny;
	real thetay, thetal;
	real Gfunp , Gerr, theta, dtheta, theta_inc;
	real Gfunpr, Gprime, thetar, nxr, nyr;
	real save_len[3][3], save_nx[3][3], save_ny[3][3];

	thread_loop_c(t,d)
	{
		if (FLUID_THREAD_P(t))
		{
			begin_c_loop_all(c,t)
			{
					check_r = FALSE;
					check_f = FALSE;
					check_l = FALSE;
					check_a = FALSE;
					boundary = FALSE;


				t_liquid = THREAD_SUB_THREAD(t,0);

				iphs = C_UDMI(c,t,1); //iphase[c];;

				if ( iphs != 2 )
				{
		//			Message(" Single phase cell \n");
					goto END;
				}
				else
				{
		//			Message(" Mixture phase cell \n");
					t_f = C_FACE_THREAD(c,t,0);
	
					if(BOUNDARY_FACE_THREAD_P(t_f))
					{
						boundary = TRUE;
	
				/*			c_node_loop(c,t,a)
							{
										  node = C_NODE(c,t,a);

								if( NODE_Y(node) == 0 )
								{

									if( NODE_X(node) == 0 )
									{
											ff = C_FACE(c,t,3);					
											tff = C_FACE_THREAD(c,t,3);
											
											fr = C_FACE(c,t,2);
											tfr = C_FACE_THREAD(c,t,2);

//										 ----------- RIGHT FACE ----------- 

											cr = F_C0(fr,tfr);
											if(cr == c)
											{
												cr = F_C1(fr,tfr);
												tr = F_C1_THREAD(fr,tfr);
											}
											else
											{
												tr = F_C0_THREAD(fr,tfr);
											}   
//										 ----------- FRONT FACE ------------ 

											cf = F_C0(ff,tff);
											if(cf == c)
											{
												cf = F_C1(ff,tff);
												tf = F_C1_THREAD(ff,tff);
											}
											else
											{
												tf = F_C0_THREAD(ff,tff);
											}

											frp = C_FACE(cf,tf,2);
											tfrp = C_FACE_THREAD(cf,tf,2);

//										 ----------- crf cell ----------- 

											crf = F_C0(frp,tfrp);
											if(crf == cf)
											{
												crf = F_C1(frp,tfrp);
												trf = F_C1_THREAD(frp,tfrp);
											}
											else
											{
												trf = F_C0_THREAD(frp,tfrp);
											}   


										fe = (1.0/4.0)*(0.0 + 2*C_VOF(cr,t_liquid) + C_VOF(crf,t_liquid));     
										fw = (1.0/4.0)*(0.0);
										fn = (1.0/4.0)*(0.0 + 2*C_VOF(cf,t_liquid) + C_VOF(crf,t_liquid));
										fs = (1.0/4.0)*(0.0);


									}
									else if( NODE_X(node)*1000000 ==   1135 )
									{
											ff = C_FACE(c,t,2);					
											tff = C_FACE_THREAD(c,t,2);

											fl = C_FACE(c,t,3);			
											tfl = C_FACE_THREAD(c,t,3);	

//										 ----------- LEFT FACE ------------ 

											cl = F_C0(fl,tfl);
											if(cl == c)
											{
												cl = F_C1(fl,tfl);
												tl = F_C1_THREAD(fl,tfl);
											}
											else
											{
												tl = F_C0_THREAD(fl,tfl);
											}


//										 ----------- FRONT FACE ------------ 

											cf = F_C0(ff,tff);
											if(cf == c)
											{
												cf = F_C1(ff,tff);
												tf = F_C1_THREAD(ff,tff);
											}
											else
											{
												tf = F_C0_THREAD(ff,tff);
											}

											flp = C_FACE(cf,tf,2);
											tflp = C_FACE_THREAD(cf,tf,2);

//										 ----------- clf cell ----------- 

											clf = F_C0(flp,tflp);
											if(clf == cf)
											{
												clf = F_C1(flp,tflp);
												tlf = F_C1_THREAD(flp,tflp);
											}
											else
											{
												tlf = F_C0_THREAD(flp,tflp);
											}   

											fe = (1.0/4.0)*(0.0);     
											fw = (1.0/4.0)*(0.0 + 2*C_VOF(cl,t_liquid) + C_VOF(clf,t_liquid));
											fn = (1.0/4.0)*(C_VOF(clf,t_liquid) + 2*C_VOF(cf,t_liquid) + 0.0);
											fs = (1.0/4.0)*(0.0);    

									}
									else
									{
											ff = C_FACE(c,t,2);					
											tff = C_FACE_THREAD(c,t,2);
											
											fr = C_FACE(c,t,1);
											tfr = C_FACE_THREAD(c,t,1);
											
											fl = C_FACE(c,t,3);			
											tfl = C_FACE_THREAD(c,t,3);	

//										 ----------- RIGHT FACE ----------- 

											cr = F_C0(fr,tfr);
											if(cr == c)
											{
												cr = F_C1(fr,tfr);
												tr = F_C1_THREAD(fr,tfr);
											}
											else
											{
												tr = F_C0_THREAD(fr,tfr);
											}   

//										 ----------- LEFT FACE ------------ 

											cl = F_C0(fl,tfl);
											if(cl == c)
											{
												cl = F_C1(fl,tfl);
												tl = F_C1_THREAD(fl,tfl);
											}
											else
											{
												tl = F_C0_THREAD(fl,tfl);
											}


//										 ----------- FRONT FACE ------------ 

											cf = F_C0(ff,tff);
											if(cf == c)
											{
												cf = F_C1(ff,tff);
												tf = F_C1_THREAD(ff,tff);
											}
											else
											{
												tf = F_C0_THREAD(ff,tff);
											}

											frp = C_FACE(cf,tf,1);
											tfrp = C_FACE_THREAD(cf,tf,1);

											flp = C_FACE(cf,tf,3);
											tflp = C_FACE_THREAD(cf,tf,3);

//										 ----------- crf cell ----------- 

											crf = F_C0(frp,tfrp);
											if(crf == cf)
											{
												crf = F_C1(frp,tfrp);
												trf = F_C1_THREAD(frp,tfrp);
											}
											else
											{
												trf = F_C0_THREAD(frp,tfrp);
											}   

//										 ----------- clf cell ----------- 

											clf = F_C0(flp,tflp);
											if(clf == cf)
											{
												clf = F_C1(flp,tflp);
												tlf = F_C1_THREAD(flp,tflp);
											}
											else
											{
												tlf = F_C0_THREAD(flp,tflp);
											}   

											fe = (1.0/4.0)*(0.0 + 2*C_VOF(cr,t_liquid) + C_VOF(crf,t_liquid));     
											fw = (1.0/4.0)*(0.0 + 2*C_VOF(cl,t_liquid) + C_VOF(clf,t_liquid));
											fn = (1.0/4.0)*(C_VOF(clf,t_liquid) + 2*C_VOF(cf,t_liquid) + C_VOF(crf,t_liquid));
											fs = (1.0/4.0)*(0.0);

									}



								}

										if( ( NODE_X(node)*100000 == 0.0 ) && ( NODE_Y(node) > 0.0 ) && ( NODE_Y(node)*100000 != 227 ) )
										{
											ff = C_FACE(c,t,3);					
											tff = C_FACE_THREAD(c,t,3);
											fr = C_FACE(c,t,2);					
											tfr = C_FACE_THREAD(c,t,2);
											fa = C_FACE(c,t,1);
											tfa = C_FACE_THREAD(c,t,1);

//												 ----------- FRONT FACE ------------ 

													cf = F_C0(ff,tff);
													if(cf == c)
													{
														cf = F_C1(ff,tff);
														tf = F_C1_THREAD(ff,tff);
													}
													else
													{
														tf = F_C0_THREAD(ff,tff);
													}

//												 ----------- RIGHT FACE ----------- 

													cr = F_C0(fr,tfr);
													if(cr == c)
													{
														cr = F_C1(fr,tfr);
														tr = F_C1_THREAD(fr,tfr);
													}
													else
													{
														tr = F_C0_THREAD(fr,tfr);
													}   

//												 ------------ AFTER FACE ------------ 

													ca = F_C0(fa,tfa);
													if(ca == c)
													{
														ca = F_C1(fa,tfa);
														ta = F_C1_THREAD(fa,tfa);
													}
													else
													{
														ta = F_C0_THREAD(fa,tfa);
													}

													far  = C_FACE(cr,tr,0);	
													tfar = C_FACE_THREAD(cr,tr,0);

													ffr  = C_FACE(cr,tr,2);	
													tffr = C_FACE_THREAD(cr,tr,2);

//												 ----------- crf cell ----------- 

													crf = F_C0(ffr,tffr);
													if(crf == cr)
													{
														crf = F_C1(ffr,tffr);
														trf = F_C1_THREAD(ffr,tffr);
													}
													else
													{
														trf = F_C0_THREAD(ffr,tffr);
													}   

//												 ----------- cra cell ----------- 

													cra = F_C0(far,tfar);
													if(crf == cr)
													{
														crf = F_C1(far,tfar);
														trf = F_C1_THREAD(far,tfar);
													}
													else
													{
														trf = F_C0_THREAD(far,tfar);
													}   

												fe = (1.0/4.0)*(C_VOF(cra,t_liquid) + 2*C_VOF(cr,t_liquid) + C_VOF(crf,t_liquid));     
												fw = (1.0/4.0)*(0.0);
												fn = (1.0/4.0)*(0.0 + 2*C_VOF(cf,t_liquid) + C_VOF(crf,t_liquid));
												fs = (1.0/4.0)*(0.0 + 2*C_VOF(ca,t_liquid) + C_VOF(cra,t_liquid));  

										}

										if( ( NODE_X(node)*1000000 == 1135 ) && ( NODE_Y(node) > 0.0 ) && ( NODE_Y(node)*100000 != 227 ) )
										{
											ff = C_FACE(c,t,1);					
											tff = C_FACE_THREAD(c,t,1);

											fl = C_FACE(c,t,2);					
											tfl = C_FACE_THREAD(c,t,2);
											
											fa = C_FACE(c,t,3);
											tfa = C_FACE_THREAD(c,t,3);

//												 ----------- FRONT FACE ------------ 

													cf = F_C0(ff,tff);
													if(cf == c)
													{
														cf = F_C1(ff,tff);
														tf = F_C1_THREAD(ff,tff);
													}
													else
													{
														tf = F_C0_THREAD(ff,tff);
													}

//												 ----------- LEFT FACE ------------ 

													cl = F_C0(fl,tfl);
													if(cl == c)
													{
														cl = F_C1(fl,tfl);
														tl = F_C1_THREAD(fl,tfl);
													}
													else
													{
														tl = F_C0_THREAD(fl,tfl);
													}

//												 ------------ AFTER FACE ------------ 

													ca = F_C0(fa,tfa);
													if(ca == c)
													{
														ca = F_C1(fa,tfa);
														ta = F_C1_THREAD(fa,tfa);
													}
													else
													{
														ta = F_C0_THREAD(fa,tfa);
													}

													fal  = C_FACE(cl,tl,0);	
													tfal = C_FACE_THREAD(cl,tl,0);

													ffl  = C_FACE(cl,tl,2);	
													tffl = C_FACE_THREAD(cl,tl,2);

//												 ----------- clf cell ----------- 

													clf = F_C0(ffl,tffl);
													if(clf == cl)
													{
														clf = F_C1(ffl,tffl);
														tlf = F_C1_THREAD(ffl,tffl);
													}
													else
													{
														tlf = F_C0_THREAD(ffl,tffl);
													}   

//												 ----------- cla cell ----------- 

													cla = F_C0(fal,tfal);
													if(clf == cl)
													{
														clf = F_C1(fal,tfal);
														tlf = F_C1_THREAD(fal,tfal);
													}
													else
													{
														tlf = F_C0_THREAD(fal,tfal);
													}   

											fe = (1.0/4.0)*(0.0); 
											fw = (1.0/4.0)*(C_VOF(cla,t_liquid) + 2*C_VOF(cl,t_liquid) + C_VOF(clf,t_liquid));
											fn = (1.0/4.0)*(C_VOF(clf,t_liquid) + 2*C_VOF(cf,t_liquid) + 0.0);
											fs = (1.0/4.0)*(C_VOF(cla,t_liquid) + 2*C_VOF(ca,t_liquid) + 0.0);    

										}



								}				*/
	

					}
					else
					{
		//			Message("Interior Mixture cell \n");
						fr = C_FACE(c,t,1);
						tfr = C_FACE_THREAD(c,t,1);
						fl = C_FACE(c,t,3);					/* --------------------- FOR ---------------------- */
						tfl = C_FACE_THREAD(c,t,3);			/* ------------------ INTERIOR -------------------- */ 
						ff = C_FACE(c,t,2);					/* -------------------- CELLS --------------------- */
						tff = C_FACE_THREAD(c,t,2);
						fa = C_FACE(c,t,0);
						tfa = C_FACE_THREAD(c,t,0);

					
	
						/* ----------- RIGHT FACE ----------- */

						cr = F_C0(fr,tfr);
						if(cr == c)
						{
							cr = F_C1(fr,tfr);
							tr = F_C1_THREAD(fr,tfr);
						}
						else
						{
							tr = F_C0_THREAD(fr,tfr);
						}   

					/* ----------- LEFT FACE ------------ */

						cl = F_C0(fl,tfl);
						if(cl == c)
						{
							cl = F_C1(fl,tfl);
							tl = F_C1_THREAD(fl,tfl);
						}
						else
						{
							tl = F_C0_THREAD(fl,tfl);
						}
					/* ----------- FRONT FACE ------------ */
						cf = F_C0(ff,tff);
						if(cf == c)
						{
							cf = F_C1(ff,tff);
							tf = F_C1_THREAD(ff,tff);
						}
						else
						{
							tf = F_C0_THREAD(ff,tff);
						}
					/* ------------ AFTER FACE ------------ */
						ca = F_C0(fa,tfa);
						if(ca == c)
						{
							ca = F_C1(fa,tfa);
							ta = F_C1_THREAD(fa,tfa);
						}
						else
						{
							ta = F_C0_THREAD(fa,tfa);
						}

	
			//			Message("%u %u %u %u \n", cr, cl, cf, ca);

						c_face_loop(cr,tr,N)
						{
							t_fr = C_FACE_THREAD(cr,tr,N);
							if( BOUNDARY_FACE_THREAD_P(t_fr) )
							{
								check_r = TRUE;
							}
						}

						c_face_loop(cf,tf,N)
						{
							t_ff = C_FACE_THREAD(cf,tf,N);
							if( BOUNDARY_FACE_THREAD_P(t_ff) )
							{
								check_f = TRUE;
							}
						}

						c_face_loop(cl,tl,N)
						{
							t_fl = C_FACE_THREAD(cl,tl,N);
							if( BOUNDARY_FACE_THREAD_P(t_fl) )
							{
								check_l = TRUE;
							}
						}

						c_face_loop(ca,ta,N)
						{
							t_fa = C_FACE_THREAD(ca,ta,N);
							if( BOUNDARY_FACE_THREAD_P(t_fa) )
							{
								check_a = TRUE;
							}
						}				



						if( check_r )
						{
				//			Message(" BOUNDARY CELL ENCOUNTERED \n ");
			

								ffr = C_FACE(cr,tr,1);
								tffr = C_FACE_THREAD(cr,tr,1);

								far = C_FACE(cr,tr,3);
								tfar = C_FACE_THREAD(cr,tr,3);

								ffl = C_FACE(cl,tl,2);
								tffl = C_FACE_THREAD(cl,tl,2);

								fal = C_FACE(cl,tl,0);
								tfal = C_FACE_THREAD(cl,tl,0);

					
							/* ======================== (crf,trf) ============================= */

								crf = F_C0(ffr,tffr);
								if(crf == cr)
								{
									crf = F_C1(ffr,tffr);
									trf = F_C1_THREAD(ffr,tffr);
								}
								else
								{
									trf = F_C0_THREAD(ffr,tffr);
								}
					//			Message(" crf = %u \n ", crf);
							/* ======================== (cra,tra) ============================= */

								cra = F_C0(far,tfar);
								if(cra == cr)
								{
									cra = F_C1(far,tfar);
									tra = F_C1_THREAD(far,tfar);
								}
								else
								{
									tra = F_C0_THREAD(far,tfar);
								}
					//			Message(" cra = %u \n ", cra);	
							/* ======================== (clf,tlf) ============================= */

								clf = F_C0(ffl,tffl);
								if(clf == cl)
								{
									clf = F_C1(ffl,tffl);
									tlf = F_C1_THREAD(ffl,tffl);
								}
								else
								{
									tlf = F_C0_THREAD(ffl,tffl);
								}
					//			Message(" clf = %u \n ", clf);
							/* ======================== (cla,tla) ============================= */

								cla = F_C0(fal,tfal);
								if(cla == cl)
								{
									cla = F_C1(fal,tfal);
									tla = F_C1_THREAD(fal,tfal);
								}
								else
								{
									tla = F_C0_THREAD(fal,tfal);
								}
					//			Message(" cla = %u \n ", cla);
		
						}
						else if ( check_f )
						{
			
								frp = C_FACE(cf,tf,3);
								tfrp = C_FACE_THREAD(cf,tf,3);

								flp = C_FACE(cf,tf,1);
								tflp = C_FACE_THREAD(cf,tf,1);

								frm = C_FACE(ca,ta,1);
								tfrm = C_FACE_THREAD(ca,ta,1);

								flm = C_FACE(ca,ta,3);
								tflm = C_FACE_THREAD(ca,ta,3);

							/* ======================== (crf,trf) ============================= */

								crf = F_C0(frp,tfrp);
								if(crf == cr)
								{
									crf = F_C1(frp,tfrp);
									trf = F_C1_THREAD(frp,tfrp);
								}
								else
								{
									trf = F_C0_THREAD(frp,tfrp);
								}

							/* ======================== (clf,tlf) ============================= */

								clf = F_C0(flp,tflp);
								if(clf == cl)
								{
									clf = F_C1(flp,tflp);
									tlf = F_C1_THREAD(flp,tflp);
								}
								else
								{
									tlf = F_C0_THREAD(flp,tflp);
								}

							/* ======================== (cra,tra) ============================= */

								cra = F_C0(frm,tfrm);
								if(cra == cr)
								{
									cra = F_C1(frm,tfrm);
									tra = F_C1_THREAD(frm,tfrm);
								}
								else
								{
									tra = F_C0_THREAD(frm,tfrm);
								}

							/* ======================== (cla,tla) ============================= */

								cla = F_C0(flm,tflm);
								if(cla == cl)
								{
									cla = F_C1(flm,tflm);
									tla = F_C1_THREAD(flm,tflm);
								}
								else
								{
									tla = F_C0_THREAD(flm,tflm);
								}
			
						}
						else if ( check_l ) 
						{
			
								ffl = C_FACE(cl,tl,3);
								tffl = C_FACE_THREAD(cl,tl,3);

								fal = C_FACE(cl,tl,1);
								tfal = C_FACE_THREAD(cl,tl,1);

								ffr = C_FACE(cr,tr,2);
								tffr = C_FACE_THREAD(cr,tr,2);

								far = C_FACE(cr,tr,0);
								tfar = C_FACE_THREAD(cr,tr,0);

							/* ======================== (crf,trf) ============================= */

								crf = F_C0(ffr,tffr);
								if(crf == cr)
								{
									crf = F_C1(ffr,tffr);
									trf = F_C1_THREAD(ffr,tffr);
								}
								else
								{
									trf = F_C0_THREAD(ffr,tffr);
								}
					//			Message(" crf = %u \n ", crf);
							/* ======================== (cra,tra) ============================= */

								cra = F_C0(far,tfar);
								if(cra == cr)
								{
									cra = F_C1(far,tfar);
									tra = F_C1_THREAD(far,tfar);
								}
								else
								{
									tra = F_C0_THREAD(far,tfar);
								}
					//			Message(" cra = %u \n ", cra);	
							/* ======================== (clf,tlf) ============================= */

								clf = F_C0(ffl,tffl);
								if(clf == cl)
								{
									clf = F_C1(ffl,tffl);
									tlf = F_C1_THREAD(ffl,tffl);
								}
								else
								{
									tlf = F_C0_THREAD(ffl,tffl);
								}
					//			Message(" clf = %u \n ", clf);
							/* ======================== (cla,tla) ============================= */

								cla = F_C0(fal,tfal);
								if(cla == cl)
								{
									cla = F_C1(fal,tfal);
									tla = F_C1_THREAD(fal,tfal);
								}
								else
								{
									tla = F_C0_THREAD(fal,tfal);
								}
					//			Message(" cla = %u \n ", cla);
		
			
						}
						else if ( check_a )
						{
			
								frm = C_FACE(ca,ta,1);
								tfrm = C_FACE_THREAD(ca,ta,1);

								flm = C_FACE(ca,ta,3);
								tflm = C_FACE_THREAD(ca,ta,3);

								frp = C_FACE(cf,tf,1);
								tfrp = C_FACE_THREAD(cf,tf,1);

								flp = C_FACE(cf,tf,3);
								tflp = C_FACE_THREAD(cf,tf,3);
			
							/* ======================== (crf,trf) ============================= */

								crf = F_C0(frp,tfrp);
								if(crf == cr)
								{
									crf = F_C1(frp,tfrp);
									trf = F_C1_THREAD(frp,tfrp);
								}
								else
								{
									trf = F_C0_THREAD(frp,tfrp);
								}

							/* ======================== (clf,tlf) ============================= */

								clf = F_C0(flp,tflp);
								if(clf == cl)
								{
									clf = F_C1(flp,tflp);
									tlf = F_C1_THREAD(flp,tflp);
								}
								else
								{
									tlf = F_C0_THREAD(flp,tflp);
								}

							/* ======================== (cra,tra) ============================= */

								cra = F_C0(frm,tfrm);
								if(cra == cr)
								{
									cra = F_C1(frm,tfrm);
									tra = F_C1_THREAD(frm,tfrm);
								}
								else
								{
									tra = F_C0_THREAD(frm,tfrm);
								}

							/* ======================== (cla,tla) ============================= */

								cla = F_C0(flm,tflm);
								if(cla == cl)
								{
									cla = F_C1(flm,tflm);
									tla = F_C1_THREAD(flm,tflm);
								}
								else
								{
									tla = F_C0_THREAD(flm,tflm);
								}
						}
						else
						{
				/* ============== DEFINITION OF SECONDARY NEIGHBOURS ============== */

 
							ffr = C_FACE(cr,tr,2);
							tffr = C_FACE_THREAD(cr,tr,2);

							far = C_FACE(cr,tr,0);
							tfar = C_FACE_THREAD(cr,tr,0);

							ffl = C_FACE(cl,tl,2);
							tffl = C_FACE_THREAD(cl,tl,2);

							fal = C_FACE(cl,tl,0);
							tfal = C_FACE_THREAD(cl,tl,0);

				//		Message("  far, tfar, ffl, tffl, fal, tfal =  %u %u %u %u %u %u  \n ", far, tfar, ffl, tffl, fal, tfal); 

		

						/* ======================== (crf,trf) ============================= */

							crf = F_C0(ffr,tffr);
							if(crf == cr)
							{
								crf = F_C1(ffr,tffr);
								trf = F_C1_THREAD(ffr,tffr);
							}
							else
							{
								trf = F_C0_THREAD(ffr,tffr);
							}
				//			Message(" crf = %u \n ", crf);
						/* ======================== (cra,tra) ============================= */

							cra = F_C0(far,tfar);
							if(cra == cr)
							{
								cra = F_C1(far,tfar);
								tra = F_C1_THREAD(far,tfar);
							}
							else
							{
								tra = F_C0_THREAD(far,tfar);
							}
				//			Message(" cra = %u \n ", cra);	
						/* ======================== (clf,tlf) ============================= */

							clf = F_C0(ffl,tffl);
							if(clf == cl)
							{
								clf = F_C1(ffl,tffl);
								tlf = F_C1_THREAD(ffl,tffl);
							}
							else
							{
								tlf = F_C0_THREAD(ffl,tffl);
							}
				//			Message(" clf = %u \n ", clf);
						/* ======================== (cla,tla) ============================= */

							cla = F_C0(fal,tfal);
							if(cla == cl)
							{
								cla = F_C1(fal,tfal);
								tla = F_C1_THREAD(fal,tfal);
							}
							else
							{
								tla = F_C0_THREAD(fal,tfal);
							}
				//			Message(" cla = %u \n ", cla);
		
						}
//	Message("%u %u %u %u %u %u %u %u \n", check_r, check_f, check_l, check_a, crf, clf, cra, cla);
						
		

						fe = (1.0/4.0)*(C_VOF(cra,t_liquid) + 2*C_VOF(cr,t_liquid) + C_VOF(crf,t_liquid));     
						fw = (1.0/4.0)*(C_VOF(cla,t_liquid) + 2*C_VOF(cl,t_liquid) + C_VOF(clf,t_liquid));
						fn = (1.0/4.0)*(C_VOF(clf,t_liquid) + 2*C_VOF(cf,t_liquid) + C_VOF(crf,t_liquid));
						fs = (1.0/4.0)*(C_VOF(cla,t_liquid) + 2*C_VOF(ca,t_liquid) + C_VOF(cra,t_liquid));    
					
				
					

						nx = (1.0/2.0)*(fe-fw);
						ny = (1.0/2.0)*(fn-fs);

						rmag2 = nx*nx + ny*ny;
					
						ax = nx/sqrt(rmag2);
						ay = ny/sqrt(rmag2);

		
		
						if (rmag2 > 0.001)
						{
							rmag = sqrt(rmag2);
							nx = nx/rmag;
							ny = ny/rmag;

							
								C_UDMI(c,t,2) =	nx;
								C_UDMI(c,t,3) =	ny;
							
						}		
						else
						{
								if(C_VOF(c,t_liquid) < 0.5)
								{
									rmag = 1.0;
									C_UDMI(c,t,1) = 3;
									goto END;
								}
								else
								{
									rmag = 1.0;
									C_UDMI(c,t,1) = 1;
									goto END;
								}
						}					
				//		C_UDMI(c,t,7) = 1;
//				Youngs method represents first guess

						get_len(c, t_liquid, nx, ny);

		//				Message(" Youngs Normals = %f %f \n", nx, ny);

//						if(C_UDMI(c,t,5) < 0.0001 )
//						{
		//					Message(" I am in 1 %u \n", c);
//								C_UDMI(c,t,2) =	nx;
//								C_UDMI(c,t,3) =	ny;
//							goto GET_LEN_END;
//						}

						nxy = nx;
						nyy = ny;
						sleny = C_UDMI(c,t,4);
						thetay = atan2(nyy,nxy);
					
		/*				if ( boundary )
						{
							    c_node_loop(c,t,k)
								{
									  node = C_NODE(c,t,k);

									if( NODE_Y(node) == 0 )
									{
										if(NODE_X(node) == 0)
										{
											save_len[1][1] = 0.0 ;
											save_len[2][1] = 0.0   ;
											save_len[3][1] = 0.0 ;
											save_len[1][2] = C_UDMI(cf,tf,4)   ;
											save_len[2][2] = C_UDMI(c,t,4)     ;
											save_len[3][2] = 0.0   ;
											save_len[1][3] = C_UDMI(crf,trf,4) ;
											save_len[2][3] = C_UDMI(cr,tr,4)   ;
											save_len[3][3] = 0.0 ;

											save_nx[1][1] = 0.0 ;
											save_nx[2][1] = 0.0   ;
											save_nx[3][1] = 0.0 ;
											save_nx[1][2] = C_UDMI(cf,tf,2)   ;
											save_nx[2][2] = C_UDMI(c,t,2)     ;
											save_nx[3][2] = 0.0   ;
											save_nx[1][3] = C_UDMI(crf,trf,2) ;
											save_nx[2][3] = C_UDMI(cr,tr,2)   ;
											save_nx[3][3] = 0.0 ;

											save_ny[1][1] = 0.0 ;
											save_ny[2][1] = 0.0   ;
											save_ny[3][1] = 0.0 ;
											save_ny[1][2] = C_UDMI(cf,tf,3)   ;
											save_ny[2][2] = C_UDMI(c,t,3)     ;
											save_ny[3][2] = 0.0   ;
											save_ny[1][3] = C_UDMI(crf,trf,3) ;
											save_ny[2][3] = C_UDMI(cr,tr,3)   ;
											save_ny[3][3] = 0.0	 ;
										}
										else if( NODE_X(node)*1000000 == 1135 )
										{
											save_len[1][1] = C_UDMI(clf,tlf,4) ;
											save_len[2][1] = C_UDMI(cl,tl,4)   ;
											save_len[3][1] = 0.0 ;
											save_len[1][2] = C_UDMI(cf,tf,4)   ;
											save_len[2][2] = C_UDMI(c,t,4)     ;
											save_len[3][2] = 0.0   ;
											save_len[1][3] = 0.0 ;
											save_len[2][3] = 0.0   ;
											save_len[3][3] = 0.0 ;

											save_nx[1][1] = C_UDMI(clf,tlf,2) ;
											save_nx[2][1] = C_UDMI(cl,tl,2)   ;
											save_nx[3][1] = 0.0 ;
											save_nx[1][2] = C_UDMI(cf,tf,2)   ;
											save_nx[2][2] = C_UDMI(c,t,2)     ;
											save_nx[3][2] = 0.0   ;
											save_nx[1][3] = 0.0   ;
											save_nx[2][3] = 0.0   ;
											save_nx[3][3] = 0.0	  ;

											save_ny[1][1] = C_UDMI(clf,tlf,3) ;
											save_ny[2][1] = C_UDMI(cl,tl,3)   ;
											save_ny[3][1] = 0.0 ;
											save_ny[1][2] = C_UDMI(cf,tf,3)   ;
											save_ny[2][2] = C_UDMI(c,t,3)     ;
											save_ny[3][2] = 0.0   ;
											save_ny[1][3] = 0.0   ;
											save_ny[2][3] = 0.0   ;
											save_ny[3][3] = 0.0   ;
										}
										else
										{
											save_len[1][1] = C_UDMI(clf,tlf,4) ;
											save_len[2][1] = C_UDMI(cl,tl,4)   ;
											save_len[3][1] = 0.0 ;
											save_len[1][2] = C_UDMI(cf,tf,4)   ;
											save_len[2][2] = C_UDMI(c,t,4)     ;
											save_len[3][2] = 0.0   ;
											save_len[1][3] = C_UDMI(crf,trf,4) ;
											save_len[2][3] = C_UDMI(cr,tr,4)   ;
											save_len[3][3] = 0.0 ;

											save_nx[1][1] = C_UDMI(clf,tlf,2) ;
											save_nx[2][1] = C_UDMI(cl,tl,2)   ;
											save_nx[3][1] = 0.0   ;
											save_nx[1][2] = C_UDMI(cf,tf,2)   ;
											save_nx[2][2] = C_UDMI(c,t,2)     ;
											save_nx[3][2] = 0.0   ;
											save_nx[1][3] = C_UDMI(crf,trf,2) ;
											save_nx[2][3] = C_UDMI(cr,tr,2)   ;
											save_nx[3][3] = 0.0	  ;

											save_ny[1][1] = C_UDMI(clf,tlf,3) ;
											save_ny[2][1] = C_UDMI(cl,tl,3)   ;
											save_ny[3][1] = 0.0   ;
											save_ny[1][2] = C_UDMI(cf,tf,3)   ;
											save_ny[2][2] = C_UDMI(c,t,3)     ;
											save_ny[3][2] = 0.0   ;
											save_ny[1][3] = C_UDMI(crf,trf,3) ;
											save_ny[2][3] = C_UDMI(cr,tr,3)   ;
											save_ny[3][3] = 0.0   ;
										}
						

									}

									if( ( NODE_X(node) == 0 ) && ( NODE_Y(node) > 0.0 ) &&  ( NODE_Y(node)*100000 != 227 ) )
									{
										save_len[1][1] = 0.0 ;
										save_len[2][1] = 0.0   ;
										save_len[3][1] = 0.0 ;
										save_len[1][2] = C_UDMI(cf,tf,4)   ;
										save_len[2][2] = C_UDMI(c,t,4)     ;
										save_len[3][2] = C_UDMI(ca,ta,4)   ;
										save_len[1][3] = C_UDMI(crf,trf,4) ;
										save_len[2][3] = C_UDMI(cr,tr,4)   ;
										save_len[3][3] = C_UDMI(cra,tra,4) ;

										save_nx[1][1] = 0.0 ;
										save_nx[2][1] = 0.0   ;
										save_nx[3][1] = 0.0 ;
										save_nx[1][2] = C_UDMI(cf,tf,2)   ;
										save_nx[2][2] = C_UDMI(c,t,2)     ;
										save_nx[3][2] = C_UDMI(ca,ta,2)   ;
										save_nx[1][3] = C_UDMI(crf,trf,2) ;
										save_nx[2][3] = C_UDMI(cr,tr,2)   ;
										save_nx[3][3] = C_UDMI(cra,tra,2) ;

										save_ny[1][1] = 0.0 ;
										save_ny[2][1] = 0.0 ;
										save_ny[3][1] = 0.0 ;
										save_ny[1][2] = C_UDMI(cf,tf,3)   ;
										save_ny[2][2] = C_UDMI(c,t,3)     ;
										save_ny[3][2] = C_UDMI(ca,ta,3)   ;
										save_ny[1][3] = C_UDMI(crf,trf,3) ;
										save_ny[2][3] = C_UDMI(cr,tr,3)   ;
										save_ny[3][3] = C_UDMI(cra,tra,3) ;

									}
									if( ( NODE_X(node)*1000000 == 1135 ) && ( NODE_Y(node) > 0.0 ) &&  ( NODE_Y(node)*100000 != 227 ) )
									{
										save_len[1][1] = C_UDMI(clf,tlf,4) ;
										save_len[2][1] = C_UDMI(cl,tl,4)   ;
										save_len[3][1] = C_UDMI(cla,tla,4) ;
										save_len[1][2] = C_UDMI(cf,tf,4)   ;
										save_len[2][2] = C_UDMI(c,t,4)     ;
										save_len[3][2] = C_UDMI(ca,ta,4)   ;
										save_len[1][3] = 0.0 ;
										save_len[2][3] = 0.0   ;
										save_len[3][3] = 0.0 ;

										save_nx[1][1] = C_UDMI(clf,tlf,2) ;
										save_nx[2][1] = C_UDMI(cl,tl,2)   ;
										save_nx[3][1] = C_UDMI(cla,tla,2) ;
										save_nx[1][2] = C_UDMI(cf,tf,2)   ;
										save_nx[2][2] = C_UDMI(c,t,2)     ;
										save_nx[3][2] = C_UDMI(ca,ta,2)   ;
										save_nx[1][3] = 0.0 ;
										save_nx[2][3] = 0.0   ;
										save_nx[3][3] = 0.0 ;

										save_ny[1][1] = C_UDMI(clf,tlf,3) ;
										save_ny[2][1] = C_UDMI(cl,tl,3)   ;
										save_ny[3][1] = C_UDMI(cla,tla,3) ;
										save_ny[1][2] = C_UDMI(cf,tf,3)   ;
										save_ny[2][2] = C_UDMI(c,t,3)     ;
										save_ny[3][2] = C_UDMI(ca,ta,3)   ;
										save_ny[1][3] = 0.0 ;
										save_ny[2][3] = 0.0   ;
										save_ny[3][3] = 0.0 ;
									}		
								}
						
						}
						else			
						{															*/
		/*		I AM BHARAT				save_len[1][1] = C_UDMI(clf,tlf,4) ;
										save_len[2][1] = C_UDMI(cl,tl,4)   ;
										save_len[3][1] = C_UDMI(cla,tla,4) ;
										save_len[1][2] = C_UDMI(cf,tf,4)   ;
										save_len[2][2] = C_UDMI(c,t,4)     ;
										save_len[3][2] = C_UDMI(ca,ta,4)   ;
										save_len[1][3] = C_UDMI(crf,trf,4) ;
										save_len[2][3] = C_UDMI(cr,tr,4)   ;
										save_len[3][3] = C_UDMI(cra,tra,4) ;

										save_nx[1][1] = C_UDMI(clf,tlf,2) ;
										save_nx[2][1] = C_UDMI(cl,tl,2)   ;
										save_nx[3][1] = C_UDMI(cla,tla,2) ;
										save_nx[1][2] = C_UDMI(cf,tf,2)   ;
										save_nx[2][2] = C_UDMI(c,t,2)     ;
										save_nx[3][2] = C_UDMI(ca,ta,2)   ;
										save_nx[1][3] = C_UDMI(crf,trf,2) ;
										save_nx[2][3] = C_UDMI(cr,tr,2)   ;
										save_nx[3][3] = C_UDMI(cra,tra,2) ;

										save_ny[1][1] = C_UDMI(clf,tlf,3) ;
										save_ny[2][1] = C_UDMI(cl,tl,3)   ;
										save_ny[3][1] = C_UDMI(cla,tla,3) ;
										save_ny[1][2] = C_UDMI(cf,tf,3)   ;
										save_ny[2][2] = C_UDMI(c,t,3)     ;
										save_ny[3][2] = C_UDMI(ca,ta,3)   ;
										save_ny[1][3] = C_UDMI(crf,trf,3) ;
										save_ny[2][3] = C_UDMI(cr,tr,3)   ;
										save_ny[3][3] = C_UDMI(cra,tra,3) ;						*/
	//					}


//					Newton's method to find normal using LVIRA

					     theta = atan2(ny,nx);
					     dtheta = 0.001;
					     Gerr = 1.0;
					     ifter = 0;
					     maxiter = 150;
					
					
lvira11: ;
		//			Message(" BEFORE LVIRA \n");
					if ( (fabs(Gerr) >= pow(10.,-8))  && ifter < maxiter  )
					{
		//				Message("lvira %u \n", c);

						ifter = ifter + 1;

						lvira(c, t, theta, dtheta, &Gfunp);
	//					Message(" c, ifter, theta, dtheta, Gfunp, nx, ny =  %u %d %f %f %g %f %f \n " , c, ifter, theta, dtheta, Gfunp, nx, ny );

						if( (fabs(Gfunp) <= 0.000001) )		
						{
							goto check11;

						}
				
						thetar = theta + dtheta;

						lvira(c, t, thetar, dtheta, &Gfunpr);			// theta-right

						Gprime = (Gfunpr - Gfunp)/dtheta;

						theta_inc = - Gfunp/Gprime;

						theta = theta + theta_inc;

						nx = cos(theta);
						ny = sin(theta);

						Gerr = fabs(theta_inc);
		//				Message(" check \n" );
		//				C_UDMI(c,t,7) = 2;
						get_len(c, t_liquid, nx, ny );

						goto lvira11;
					}
check11: ;

		//			Message(" Normals After LVIRA loop = %f %f \n", nx, ny);

						if ( ifter > maxiter)
						{
		//					Message(" One Happened \n");
							nx = nxy;
							ny = nyy;
							C_UDMI(c,t,4) = sleny;
						}
						thetal = atan2(ny,nx);
						if( fabs(thetal - thetay) > M_PI/20.0 )
						{
		//					Message(" Two Happened \n");
							nx = nxy;
							ny = nyy;
							C_UDMI(c,t,4) = sleny;
						}
				
	//					Message(" Correct Normals After LVIRA loop = %f %f \n", nx, ny);
GET_LEN_END:;
						C_UDMI(c,t,2) = nx;
						C_UDMI(c,t,3) = ny;
						
		//				C_UDMI(c,t,7) = 3;
						get_len(c, t_liquid, nx, ny );
						
		//				Message("GET_LEN_END = BEFORE \n");

						C_CENTROID(XC,c,t);
						if(fequal( XC[0], 3.1278*pow(10.0,-06) ) && ( C_UDMI(c,t,2) < 0.0 ) )
						{
							C_UDMI(c,t,2) = 0.0;
							C_UDMI(c,t,3) = 1.0;
							nx = C_UDMI(c,t,2) ;
							ny = C_UDMI(c,t,3) ;
						
		//					C_UDMI(c,t,7) = 4;							
							get_len(c, t_liquid, nx, ny );
						}
						else if(fequal( XC[0], 0.0011318472222 ) && ( C_UDMI(c,t,2) < 0.0 ) )
						{
							C_UDMI(c,t,2) = 0.0;
							C_UDMI(c,t,3) = 1.0;
							nx = C_UDMI(c,t,2) ;
							ny = C_UDMI(c,t,3) ;

		//					C_UDMI(c,t,7) = 5;
							get_len(c, t_liquid, nx, ny );
						}


		//				Message("GET_LEN_END = AFTER \n");
		//				Message("B slen, nx, ny = %u %g %f %f \n", c, C_UDMI(c,t,4), nx, ny );


/*						if ( boundary )
						{
							    c_node_loop(c,t,k)
								{
									  node = C_NODE(c,t,k);

									if( NODE_Y(node) == 0 )
									{
										if(NODE_X(node) == 0)
										{

											C_UDMI(cf,tf,4)   = save_len[1][2] ;
											
											C_UDMI(crf,trf,4) = save_len[1][3] ;
											C_UDMI(cr,tr,4)   = save_len[2][3] ;
											

										
											C_UDMI(cf,tf,2)   = save_nx[1][2] ;
											
											C_UDMI(crf,trf,2) = save_nx[1][3] ;
											C_UDMI(cr,tr,2)   = save_nx[2][3] ;
											

										
											C_UDMI(cf,tf,3)   = save_ny[1][2] ;
											
											C_UDMI(crf,trf,3) = save_ny[1][3] ;
											C_UDMI(cr,tr,3)   = save_ny[2][3] ;
											
										}
										else if( NODE_X(node)*1000000 == 1135 )
										{
											C_UDMI(clf,tlf,4) = save_len[1][1] ;
											C_UDMI(cl,tl,4)   = save_len[2][1] ;
											C_UDMI(cf,tf,4)   = save_len[1][2] ;
											

											C_UDMI(clf,tlf,2) = save_nx[1][1] ;
											C_UDMI(cl,tl,2)   = save_nx[2][1] ;
											C_UDMI(cf,tf,2)   = save_nx[1][2] ;
											

											C_UDMI(clf,tlf,3) = save_ny[1][1] ;
											C_UDMI(cl,tl,3)   = save_ny[2][1] ;
											C_UDMI(cf,tf,3)   = save_ny[1][2] ;
											
														
										}
										else
										{
											C_UDMI(clf,tlf,4) = save_len[1][1] ;
											C_UDMI(cl,tl,4)   = save_len[2][1] ;
											C_UDMI(cf,tf,4)   = save_len[1][2] ;
											C_UDMI(crf,trf,4) = save_len[1][3] ;
											C_UDMI(cr,tr,4)   = save_len[2][3] ;

											C_UDMI(clf,tlf,2) = save_nx[1][1] ;
											C_UDMI(cl,tl,2)   = save_nx[2][1] ;
											C_UDMI(cf,tf,2)   = save_nx[1][2] ;
											C_UDMI(crf,trf,2) = save_nx[1][3] ;
											C_UDMI(cr,tr,2)   = save_nx[2][3] ;

											C_UDMI(clf,tlf,3) = save_ny[1][1] ;
											C_UDMI(cl,tl,3)   = save_ny[2][1] ;
											C_UDMI(cf,tf,3)   = save_ny[1][2] ;
											C_UDMI(crf,trf,3) = save_ny[1][3] ;
											C_UDMI(cr,tr,3)   = save_ny[2][3] ;

										}
						

									}

									if( ( NODE_X(node) == 0 ) && ( NODE_Y(node) > 0.0 ) &&  ( NODE_Y(node)*100000 != 227 ) )
									{
											C_UDMI(cf,tf,4)   = save_len[1][2] ;
											C_UDMI(ca,ta,4)   = save_len[3][2] ;
											C_UDMI(crf,trf,4) = save_len[1][3] ;
											C_UDMI(cr,tr,4)   = save_len[2][3] ;
											C_UDMI(cra,tra,4) = save_len[3][3] ;

											C_UDMI(cf,tf,2)   = save_nx[1][2] ;
											C_UDMI(ca,ta,2)   = save_nx[3][2] ;
											C_UDMI(crf,trf,2) = save_nx[1][3] ;
											C_UDMI(cr,tr,2)   = save_nx[2][3] ;
											C_UDMI(cra,tra,2) = save_nx[3][3] ;

											C_UDMI(cf,tf,3)   = save_ny[1][2] ;
											C_UDMI(ca,ta,3)   = save_ny[3][2] ;
											C_UDMI(crf,trf,3) = save_ny[1][3] ;
											C_UDMI(cr,tr,3)   = save_ny[2][3] ;
											C_UDMI(cra,tra,3) = save_ny[3][3] ;

									}
									if( ( NODE_X(node)*1000000 == 1135 ) && ( NODE_Y(node) > 0.0 ) &&  ( NODE_Y(node)*100000 != 227 ) )
									{
											C_UDMI(clf,tlf,4) = save_len[1][1] ;
											C_UDMI(cl,tl,4)   = save_len[2][1] ;
											C_UDMI(cla,tla,4) = save_len[3][1] ;
											C_UDMI(cf,tf,4)   = save_len[1][2] ;
											C_UDMI(ca,ta,4)   = save_len[3][2] ;

											C_UDMI(clf,tlf,2) = save_nx[1][1] ;
											C_UDMI(cl,tl,2)   = save_nx[2][1] ;
											C_UDMI(cla,tla,2) = save_nx[3][1] ;
											C_UDMI(cf,tf,2)   = save_nx[1][2] ;
											C_UDMI(ca,ta,2)   = save_nx[3][2] ;

											C_UDMI(clf,tlf,3) = save_ny[1][1] ;
											C_UDMI(cl,tl,3)   = save_ny[2][1] ;
											C_UDMI(cla,tla,3) = save_ny[3][1] ;
											C_UDMI(cf,tf,3)   = save_ny[1][2] ;
											C_UDMI(ca,ta,3)   = save_ny[3][2] ;
									}		
								}
						
						}
						else			
						{																*/
/* I AM NOTHING							C_UDMI(clf,tlf,4) = save_len[1][1] ;
										C_UDMI(cl,tl,4)   = save_len[2][1] ;
										C_UDMI(cla,tla,4) = save_len[3][1] ;
										C_UDMI(cf,tf,4)   = save_len[1][2] ;
										C_UDMI(ca,ta,4)   = save_len[3][2] ;
										C_UDMI(crf,trf,4) = save_len[1][3] ;
										C_UDMI(cr,tr,4)   = save_len[2][3] ;
										C_UDMI(cra,tra,4) = save_len[3][3] ;

										C_UDMI(clf,tlf,2) = save_nx[1][1] ;
										C_UDMI(cl,tl,2)   = save_nx[2][1] ;
										C_UDMI(cla,tla,2) = save_nx[3][1] ;
										C_UDMI(cf,tf,2)   = save_nx[1][2] ;
										C_UDMI(ca,ta,2)   = save_nx[3][2] ;
										C_UDMI(crf,trf,2) = save_nx[1][3] ;
										C_UDMI(cr,tr,2)   = save_nx[2][3] ;
										C_UDMI(cra,tra,2) = save_nx[3][3] ;

										C_UDMI(clf,tlf,3) = save_ny[1][1] ;
										C_UDMI(cl,tl,3)   = save_ny[2][1] ;
										C_UDMI(cla,tla,3) = save_ny[3][1] ;
										C_UDMI(cf,tf,3)   = save_ny[1][2] ;
										C_UDMI(ca,ta,3)   = save_ny[3][2] ;
										C_UDMI(crf,trf,3) = save_ny[1][3] ;
										C_UDMI(cr,tr,3)   = save_ny[2][3] ;
										C_UDMI(cra,tra,3) = save_ny[3][3] ;					*/
	//					}
					

				}
END:;
			  }

	//		  Message("init iface - after - c, iphs, C_UDMI(c,t,2), C_UDMI(c,t,3)  = %u %f %.15f %.15f \n", c, C_UDMI(c,t,1), C_UDMI(c,t,2), C_UDMI(c,t,3));		

			}
			end_c_loop_all(c,t)
		}
	}
}

extern void
G_fun(cell_t c, Thread *t, real theta, real *Gfun)
{
/*	Constructs approximation to interface shape. Interface is
    plane surface surface in each cell.  Unit normal is constructed
    from liquid volume fraction profile.
    also see the G-function of Pucket et al. (JCP, 130, 269-282, 1997)	*/
	
	cell_t cr, cf, cl, ca, crf, cra, clf, cla ;
	Thread *tf, *ta, *tr, *tl, *trf, *tra, *tlf, *tla ;
	face_t fr,ff,fl,fa,ffr,far,ffl,fal,flfl,frfl,frfr,frff,fraf,fraa;
	Thread *tfr, *tff, *tfl, *tfa, *tffr, *tfar, *tffl, *tfal, *tflfl, *tfrfl, *tfrfr, *tfrff, *tfraf, *tfraa;
	Thread *t_f, *t_fr, *t_ff, *t_fl, *t_fa;
	
	Thread *t_liquid = THREAD_SUB_THREAD(t,0);
	
	real dx, dy;
	real nx , ny , normalx , normaly , dvol ;
    real voll, voidll, dvoid ;
	real xi, yi ;
    real lenij ;
    real xc[ND_ND], xci[ND_ND], xfrfr[ND_ND], xfrfl[ND_ND], xffr[ND_ND], xfar[ND_ND], xffl[ND_ND], xflfl[ND_ND], xfrff[ND_ND], xfraf[ND_ND], xfraa[ND_ND];
	real dxc, dyc, dxrf, dyrf, dxlf, dylf, dxra, dyra ;
	int rr, cc, n, N;
	real xp, xpm, xm, xmm, yp, ypm, ym, ymm;
	real len;

	cxboolean check;
	cxboolean check_r ;
	cxboolean check_f ;
	cxboolean check_l ;
	cxboolean check_a ;
	
	check   = FALSE;
	check_r = FALSE;
	check_f = FALSE;
	check_l = FALSE;
	check_a = FALSE;
	
	C_CENTROID(xc,c,t);

	delta( c, t_liquid, &dx, &dy );

	
	len = C_UDMI(c,t,4);		// slen[c];										// REVISED !!!!!

	nx = cos(theta);
    ny = sin(theta);

	xi = xc[0] - len * nx ;
    yi = xc[1] - len * ny ;
	dvol = dx*dy;
	(*Gfun) = 0.0;


	
	t_f = C_FACE_THREAD(c,t,0);
	if( BOUNDARY_FACE_THREAD_P(t_f) )
	{
												// BOUNDARY CELLS ARE NOT CONSIDERED HERE. LATER ON IT MAY BE REQUIRED.
	}
	else
	{
		
	(fr) = C_FACE(c,t,1);
	(tfr) = C_FACE_THREAD(c,t,1);
	(fl) = C_FACE(c,t,3);					/* --------------------- FOR ---------------------- */
	(tfl) = C_FACE_THREAD(c,t,3);			/* ------------------ INTERIOR -------------------- */ 
	(ff) = C_FACE(c,t,2);					/* -------------------- CELLS --------------------- */
	(tff) = C_FACE_THREAD(c,t,2);
	(fa) = C_FACE(c,t,0);
	(tfa) = C_FACE_THREAD(c,t,0);

		/* ----------- RIGHT FACE ----------- */

		(cr) = F_C0((fr),(tfr));
		if((cr) == c)
		{
			(cr) = F_C1((fr),(tfr));

			(tr) = F_C1_THREAD((fr),(tfr));

		}
		else
		{

			(tr) = F_C0_THREAD((fr),(tfr));

		}   

		/* ----------- LEFT FACE ------------ */

		(cl) = F_C0((fl),(tfl));
		if((cl) == c)
		{
			(cl) = F_C1((fl),(tfl));
			(tl) = F_C1_THREAD((fl),(tfl));
		}
		else
		{
			(tl) = F_C0_THREAD((fl),(tfl));
		}

		/* ----------- FRONT FACE ------------ */

		(cf) = F_C0((ff),(tff));
		if((cf) == c)
		{
			(cf) = F_C1((ff),(tff));

			(tf) = F_C1_THREAD((ff),(tff));

		}
		else
		{

			(tf) = F_C0_THREAD((ff),(tff));
		}


		/* ------------ AFTER FACE ------------ */

		(ca) = F_C0((fa),(tfa));
		if((ca) == c)
		{
			(ca) = F_C1((fa),(tfa));
			(ta) = F_C1_THREAD((fa),(tfa));
		}
		else
		{
			(ta) = F_C0_THREAD((fa),(tfa));
		}


		c_face_loop((cr),(tr),N)
		{
			t_fr = C_FACE_THREAD((cr),(tr),N);
			if( BOUNDARY_FACE_THREAD_P(t_fr) )
			{
				check_r = TRUE;
			}
		}

		c_face_loop((cf),(tf),N)
		{
			t_ff = C_FACE_THREAD((cf),(tf),N);
			if( BOUNDARY_FACE_THREAD_P(t_ff) )
			{
				check_f = TRUE;
			}
		}

		c_face_loop((cl),(tl),N)
		{
			t_fl = C_FACE_THREAD((cl),(tl),N);
			if( BOUNDARY_FACE_THREAD_P(t_fl) )
			{
				check_l = TRUE;
			}
		}

		c_face_loop((ca),(ta),N)
		{
			t_fa = C_FACE_THREAD((ca),(ta),N);
			if( BOUNDARY_FACE_THREAD_P(t_fa) )
			{
				check_a = TRUE;
			}
		}				

		if( check_r  || check_f  || check_l  || check_a  )
		{
			//			BOUNDARY CELLS ARE NOT CONSIDERED HERE.
//			Message(" BOUNDARY CELL ENCOUNTERED \n ");

		}
		else
		{
		/* ============== DEFINITION OF SECONDARY NEIGHBOURS ============== */

 
			(ffr) = C_FACE((cr),(tr),2);
			(tffr) = C_FACE_THREAD((cr),(tr),2);

			(far) = C_FACE((cr),(tr),0);
			(tfar) = C_FACE_THREAD((cr),(tr),0);

			(ffl) = C_FACE((cl),(tl),2);
			(tffl) = C_FACE_THREAD((cl),(tl),2);

			(fal) = C_FACE((cl),(tl),0);
			(tfal) = C_FACE_THREAD((cl),(tl),0);

//			Message("far, tfar, ffl, tffl, fal, tfal = %u %u %u %u %u %u \n", far, tfar, ffl, tffl, fal, tfal);



		/* ======================== (crf,trf) ============================= */

			(crf) = F_C0((ffr),(tffr));
			if((crf) == (cr))
			{
				(crf) = F_C1((ffr),(tffr));
				(trf) = F_C1_THREAD((ffr),(tffr));
			}
			else
			{
				(trf) = F_C0_THREAD((ffr),(tffr));
			}
	//		Message(" crf = %u \n ", crf);
		/* ======================== (cra,tra) ============================= */

			(cra) = F_C0((far),(tfar));
			if((cra) == (cr))
			{
				(cra) = F_C1((far),(tfar));
				(tra) = F_C1_THREAD((far),(tfar));
			}
			else
			{
				(tra) = F_C0_THREAD((far),(tfar));
			}
	//		Message(" cra = %u \n ", cra);	
		/* ======================== (clf,tlf) ============================= */

			(clf) = F_C0((ffl),(tffl));
			if((clf) == (cl))
			{
				(clf) = F_C1((ffl),(tffl));
				(tlf) = F_C1_THREAD((ffl),(tffl));
			}
			else
			{
				(tlf) = F_C0_THREAD((ffl),(tffl));
			}
	//		Message(" clf = %u \n ", clf);
		/* ======================== (cla,tla) ============================= */

			(cla) = F_C0((fal),(tfal));
			if((cla) == (cl))
			{
				(cla) = F_C1((fal),(tfal));
				(tla) = F_C1_THREAD((fal),(tfal));
			}
			else
			{
				(tla) = F_C0_THREAD((fal),(tfal));
			}



			
	for (rr = -1; rr <= 1; ++rr)								// REVISED !!!!!
		for (cc = -1; cc <= 1; ++cc)							// REVISED !!!!!
		{
			if( rr == 1 && cc == -1 )
			{
				C_CENTROID(xci,clf,tlf);
				
				dxc = xc[0] - xci[0];
				dyc = xc[1] - xci[1];
				C_UDMI(clf,t,4) = len - dxc*nx - dyc*ny ;
				C_UDMI(clf,t,2) = nx;
				C_UDMI(clf,t,3) = ny;
				
			}
			else if( rr == 1 && cc == 0 )
			{	
				C_CENTROID(xci,cf,tf);

				dxc = xc[0] - xci[0];
				dyc = xc[1] - xci[1];
				C_UDMI(cf,t,4) = len - dxc*nx - dyc*ny ;
				C_UDMI(cf,t,2) = nx;
				C_UDMI(cf,t,3) = ny;
			}
			else if( rr == 1 && cc == 1 )
			{
				C_CENTROID(xci,crf,trf);

				dxc = xc[0] - xci[0];
				dyc = xc[1] - xci[1];
				C_UDMI(crf,t,4) = len - dxc*nx - dyc*ny ;
				C_UDMI(crf,t,2) = nx;
				C_UDMI(crf,t,3) = ny;
			}
			else if( rr == 0 && cc == -1 )
			{
				C_CENTROID(xci,cl,tl);

				dxc = xc[0] - xci[0];
				dyc = xc[1] - xci[1];
				C_UDMI(cl,t,4) = len - dxc*nx - dyc*ny ;
				C_UDMI(cl,t,2) = nx;
				C_UDMI(cl,t,3) = ny;
			}
			else if( rr == 0 && cc == 0 )
			{
				goto SUPERMAN;
			}
			else if( rr == 0 && cc == 1 )
			{	
				C_CENTROID(xci,cr,tr);

				dxc = xc[0] - xci[0];
				dyc = xc[1] - xci[1];
				C_UDMI(cr,t,4) = len - dxc*nx - dyc*ny ;
				C_UDMI(cr,t,2) = nx;
				C_UDMI(cr,t,3) = ny;
			}
			else if( rr == - 1 && cc == - 1 )
			{
				C_CENTROID(xci,cla,tla);

				dxc = xc[0] - xci[0];
				dyc = xc[1] - xci[1];
				C_UDMI(cla,t,4) = len - dxc*nx - dyc*ny ;
				C_UDMI(cla,t,2) = nx;
				C_UDMI(cla,t,3) = ny;
			}
			else if( rr == - 1 && cc == 0 )
			{
				C_CENTROID(xci,ca,ta);

				dxc = xc[0] - xci[0];
				dyc = xc[1] - xci[1];
				C_UDMI(ca,t,4) = len - dxc*nx - dyc*ny ;
				C_UDMI(ca,t,2) = nx;
				C_UDMI(ca,t,3) = ny;
			}
			else if( rr == - 1 && cc == 1 )
			{
				C_CENTROID(xci,cra,tra);

				dxc = xc[0] - xci[0];
				dyc = xc[1] - xci[1];
				C_UDMI(cra,t,4) = len - dxc*nx - dyc*ny ;
				C_UDMI(cra,t,2) = nx;
				C_UDMI(cra,t,3) = ny;
			}
			
			
			

			frfr = C_FACE(crf, trf, 1);
			tfrfr = C_FACE_THREAD(crf, trf, 1);

			frfl = C_FACE(crf, trf, 3);
			tfrfl = C_FACE_THREAD(crf, trf, 3);
			
			frff = C_FACE(crf, trf, 2);
			tfrff = C_FACE_THREAD(crf, trf, 2);
			
			ffr = C_FACE(crf, trf, 0);
			tffr = C_FACE_THREAD(crf, trf, 0);
			
			ffl = C_FACE(cf, tf, 3);
			tffl = C_FACE_THREAD(cf, tf, 3);
			
			flfl = C_FACE(clf, tlf, 3);
			tflfl = C_FACE_THREAD(clf, tlf, 3);

			fraf = C_FACE(cr, tr, 0);
			tfraf = C_FACE_THREAD(cr, tr, 0);

			fraa = C_FACE(cra, tra, 0);
			tfraa = C_FACE_THREAD(cra, tra, 0);

			F_CENTROID(xfrfr,frfr, tfrfr);
			F_CENTROID(xfrfl,frfl, tfrfl);
			F_CENTROID(xffl,ffl, tffl);
			F_CENTROID(xflfl,flfl, tflfl);
			F_CENTROID(xfrff,frff, tfrff);
			F_CENTROID(xffr,ffr, tffr);
			F_CENTROID(xfraf,fraf, tfraf);
			F_CENTROID(xfraa,fraa, tfraa);
			
		//	Message("xp, xmm, yp, ymm = %f %f %f %f \n", xp, xmm, yp, ymm);
			

			if ( rr == 1 && cc == - 1 )
			{
						if( clf == 1795 )
						 {
//							 Message(" 1,-1 clf, t_liquid, xflfl[0], xffl[0], xffr[1], xfrff[1] = %u %u %f %f %f %f \n", clf, t_liquid, xflfl[0], xffl[0], xffr[1], xfrff[1]);
						 }

				
				lgvol( clf, t_liquid, xflfl[0], xffl[0], xffr[1], xfrff[1], &voll );
				voidll = voll/dvol;
				dvoid = C_VOF(clf,t_liquid) - voidll;
//				Message(" 1,-1 voll = %f \n", voll);
			}
			else if ( rr == 1 && cc == 0 )
			{
//				Message(" 1,0 xffl[0], xfrfl[0], xffr[1], xfrff[1] = %f %f %f %f \n", xffl[0], xfrfl[0], xffr[1], xfrff[1]);
				lgvol( cf, t_liquid, xffl[0], xfrfl[0], xffr[1], xfrff[1], &voll );
				voidll = voll/dvol;
				dvoid = C_VOF(cf,t_liquid) - voidll;
//				Message(" 1,0 voll = %f \n", voll);
			}
			else if ( rr == 1 && cc == 1 )
			{
//				Message(" 1,1 xfrfl[0], xfrfr[0], xffr[1], xfrff[1] = %f %f %f %f \n", xfrfl[0], xfrfr[0], xffr[1], xfrff[1] );
				lgvol( crf, t_liquid, xfrfl[0], xfrfr[0], xffr[1], xfrff[1], &voll );
				voidll = voll/dvol;
				dvoid = C_VOF(crf,t_liquid) - voidll;
//				Message(" 1,1 voll = %f \n", voll);
			}
			else if ( rr == 0 && cc == - 1 )
			{
//				Message(" 0,-1  xflfl[0], xffl[0], xfraf[1], xffr[1] = %f %f %f %f \n", xflfl[0], xffl[0], xfraf[1], xffr[1]);
				lgvol( cl, t_liquid, xflfl[0], xffl[0], xfraf[1], xffr[1], &voll );
				voidll = voll/dvol;
				dvoid = C_VOF(cl,t_liquid) - voidll;
//				Message(" 0,-1 voll = %f \n", voll);
			}
			else if ( rr == 0 && cc == 1 )
			{
//				Message(" 0,1  xfrfl[0], xfrfr[0], xfraf[1], xffr[1] = %f %f %f %f \n",  xfrfl[0], xfrfr[0], xfraf[1], xffr[1]);
				lgvol( cr, t_liquid, xfrfl[0], xfrfr[0], xfraf[1], xffr[1], &voll );
				voidll = voll/dvol;
				dvoid = C_VOF(cr,t_liquid) - voidll;
//				Message(" 0,1 voll = %f \n", voll);
			}
			else if ( rr == -1 && cc == - 1 )
			{
//				Message(" -1,-1 xflfl[0], xffl[0], xfraa[1], xfraf[1] = %f %f %f %f \n", xflfl[0], xffl[0], xfraa[1], xfraf[1]);
				lgvol( cla, t_liquid, xflfl[0], xffl[0], xfraa[1], xfraf[1], &voll );
				voidll = voll/dvol;
				dvoid = C_VOF(cla,t_liquid) - voidll;
//				Message(" -1,-1 voll = %f \n", voll);
			}
			else if ( rr == - 1 && cc == 0 )
			{
//				Message(" -1,0 xffl[0], xfrfl[0], xfraa[1], xfraf[1] = %f %f %f %f \n", xffl[0], xfrfl[0], xfraa[1], xfraf[1]);
				lgvol( ca, t_liquid, xffl[0], xfrfl[0], xfraa[1], xfraf[1], &voll );
				voidll = voll/dvol;
				dvoid = C_VOF(ca,t_liquid) - voidll;
//				Message(" -1,0 voll = %f \n", voll);
			}
			else if ( rr == - 1 && cc == 1 )
			{
//				Message(" -1,1 xfrfl[0], xfrfr[0], xfraa[1], xfraf[1] = %f %f %f %f \n", xfrfl[0], xfrfr[0], xfraa[1], xfraf[1]);
				lgvol( cra, t_liquid, xfrfl[0], xfrfr[0], xfraa[1], xfraf[1], &voll );
				voidll = voll/dvol;
				dvoid = C_VOF(cra,t_liquid) - voidll;
//				Message(" -1,1 voll = %f \n", voll);
			}
			
			(*Gfun) = (*Gfun) + dvoid*dvoid ;
//			Message( "Gfun = %u %d %d %.15f %f \n", c, rr, cc, (*Gfun), dvoid );
 SUPERMAN: ;
		}
	  }
	}
}	

extern void
lvira(cell_t c, Thread *t, real theta, real dtheta, real *Gfunp)
{
/*	 constructs approximation to interface shape. Interface is
     plane surface in each cell.  Unit normal is constructed
     from liquid volume fraction profile.						*/
	Thread *t_liquid = THREAD_SUB_THREAD(t,0);
	real Gfun, Gfunr, Gfunl, thetar, thetal ;
    real ssave, nx, ny;
	real len;

	ssave = C_UDMI(c,t,4); //  slen[c];

    thetar = theta + dtheta;
    nx	   = cos(thetar);
    ny     = sin(thetar);
	
//	C_UDMI(c,t,7) = 6;
	get_len(c, t_liquid, nx, ny );
	G_fun(c, t, thetar, &Gfunr);
//	if(C_UDMI(c,t,5) < 0.0001 )
//	{
	//	Message(" I am in 3 %u \n", c);
//		(*Gfunp) = 0.0;
//		C_UDMI(c,t,2) = nx;
//		C_UDMI(c,t,3) = ny;
	//	Message(" 1 nx, ny = %u %f %f \n", c, nx, ny );
//		goto LVIRA_END;
//	}

	thetal = theta - dtheta;
    nx	   = cos(thetal);
    ny     = sin(thetal);

//	C_UDMI(c,t,7) = 7;
	get_len(c, t_liquid, nx, ny );
	G_fun(c, t, thetal, &Gfunl);
//	if(C_UDMI(c,t,5) < 0.0001 )
//	{
	//	Message(" I am in 3 %u \n", c);
//		(*Gfunp) = 0.0;
//		C_UDMI(c,t,2) = nx;
//		C_UDMI(c,t,3) = ny;
	//	Message(" 2 nx, ny = %u %f %f \n", c, nx, ny );
//		goto LVIRA_END;
//	}

	(*Gfunp) = ( Gfunr - Gfunl )/(2.0*dtheta);

	C_UDMI(c,t,4) = ssave;

//LVIRA_END:;
	return;

}

/* Outlet boundary condition  =  Pressur eoutlet B.C 
Refer page no  330 of above mentioned paper. */
DEFINE_PROFILE(outlet_pressure_profile,t,i)
{
  Thread *t_liquid;
  real x[ND_ND];                /* this will hold the position vector */
  real y;
  real T;
  face_t f;
  
  t_liquid = THREAD_SUB_THREAD(t,0);

  begin_f_loop(f,t)
    {
      F_PROFILE(f,t,i) = PSAT - ROL*M_G*(0.002270 - 7.56*pow(10,-5)) ;
    }
  end_f_loop(f,t)
}




/* This part calculates mass transfer rate due to evaporation. Refer G. Biswas NOTES and FORTRAN code */ 

// IMPORTANT NOTE: 

//   THIS PART DEPENDS ON GRID GEOMETRY. This code is written for Rectangular grid of size 1.135mm width and 2.27 mm height.
//   Please change it if you wish to alter geometry.
DEFINE_MASS_TRANSFER(GTM_Mass_Transfer_MODEL,c,t,from_index,from_species_index, to_index, to_species_index)
{
	Domain *d = Get_Domain(1);   
	Thread *t_liquid = THREAD_SUB_THREAD(t,from_index);
	Thread *t_vapour = THREAD_SUB_THREAD(t,to_index);
	cell_t cs; 
	Thread *ts;
	
	/* =============== DECLARATION OF NEIGHBOURING CELL ID'S AND THREAD'S ================= */
	cell_t cr, cf, cl, ca, crf, cra, clf, cla ;
	Thread *tf, *ta, *tr, *tl, *trf, *tra, *tlf, *tla ;

	face_t fr,ff,fl,fa,ffr,far,ffl,fal,frp,flp,frm,flm;
	Thread *tfr, *tff, *tfl, *tfa, *tffr, *tfar, *tffl, *tfal, *tfrp, *tflp, *tfrm, *tflm;

	face_t f;
	Thread *t_f;
	Thread *t_fr, *t_ff, *t_fl, *t_fa;
	Node *node;
	int a;
	/* ------------------------------------------------------------------------------------ */
	cell_t CELL[3][3];
	Thread *THREAD[3][3];
	float NV_VEC(S11), NV_VEC(S12), NV_VEC(S13), NV_VEC(S21), NV_VEC(S22), NV_VEC(S23), NV_VEC(S31), NV_VEC(S32), NV_VEC(S33);
	
	float SX[3][3], SY[3][3], DS[3][3];

	float source;

	float NV_VEC(n), NV_VEC(s), NV_VEC(sr), NV_VEC(sf), NV_VEC(sl), NV_VEC(sa), NV_VEC(srf), NV_VEC(slf), NV_VEC(sla), NV_VEC(sra), sx , sy ;
	real  xl , xr , ya , yf; 
	float XR[ND_ND], XF[ND_ND], XL[ND_ND], XA[ND_ND] , xi , yi , xis , yis;
	real nx,ny,xint1, xint2 , yint1, yint2;
	float X[ND_ND], Xr[ND_ND], Xf[ND_ND], Xl[ND_ND], Xa[ND_ND], Xrf[ND_ND], Xlf[ND_ND], Xla[ND_ND], Xra[ND_ND], XC[ND_ND], XCS[ND_ND];
	real xcf[ND_ND],xca[ND_ND], xcr[ND_ND], xcl[ND_ND] ;
	real *ptl, *ptr, *pta, *ptf ;
	real xci[ND_ND];
	int N;
	int iface_int1, iface_int2;
	int iphs;
	float NV_VEC(q_s), q_n , ds , kl , kg, keff, liq_vof_grad, latent_heat;
	float XS[ND_ND];
	int ii,jj;
	int rr, cc, n_row, n_col ;
	float dot_prod[3][3] , S[3][3]  ;
	float big;
	real ax, ay, bx, by;
	FILE *fp;
	char name[50];

	real dx,dy;
	real len, voll ;
	real sourcl, sourcv, tempn;
	
	real distance;
	
	cxboolean check_r ;
	cxboolean check_f ;
	cxboolean check_l ;
	cxboolean check_a ;
	cxboolean boundary;

	check_r = FALSE;
	check_f = FALSE;
	check_l = FALSE;
	check_a = FALSE;
	
	iphs = C_UDMI(c,t,1); //iphase[c];
	n[0] = C_UDMI(c,t,2); //nx;
	n[1] = C_UDMI(c,t,3); //ny;	

//	

if (iphs == 2 )
{
//	Message(" c, iphs, nx, ny = %u %f %f %f \n", c, C_UDMI(c,t,1), C_UDMI(c,t,2), C_UDMI(c,t,3)  );
//	Message(" MASS    c,0,1,2,3,4,5 = %u %g %g %g %g %g %g \n", c, C_UDMI(c,t,0), C_UDMI(c,t,1), C_UDMI(c,t,2), C_UDMI(c,t,3), C_UDMI(c,t,4), C_UDMI(c,t,5));	
//	t_f = C_FACE_THREAD(c,t,0);
/*
		boundary = FALSE;
	c_face_loop(c,t,a)
	{
						  
			t_f = C_FACE_THREAD(c,t,a);
			if(BOUNDARY_FACE_THREAD_P(t_f))
			{
				boundary = TRUE;
			}
						  
		}		*/
	t_f = C_FACE_THREAD(c,t,0);

  		C_CENTROID(XC,c,t);
//	Message(" iphs, n[0], n[1] = %d %f %f \n ", iphs, n[0], n[1] );

	if(BOUNDARY_FACE_THREAD_P(t_f))
	{													


					// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to left boundary.)
					if( fequal(XC[0], 0.00001135) && (XC[1] > 0.00003405) && (XC[1] < 0.0022473)  )
					{
						ff = C_FACE(c,t,3);					
						tff = C_FACE_THREAD(c,t,3);
						fa = C_FACE(c,t,1);
						tfa = C_FACE_THREAD(c,t,1);
							fr = C_FACE(c,t,2);
							tfr = C_FACE_THREAD(c,t,2);	
							fl = C_FACE(c,t,0);
							tfl = C_FACE_THREAD(c,t,0);	
							
//=====================================================================================================================================
							F_CENTROID(XR,fr,tfr);
							F_CENTROID(XF,ff,tff);
							F_CENTROID(XL,fl,tfl);
							F_CENTROID(XA,fa,tfa);

							xr = XR[0] ;
							yf = XF[1] ;
							xl = XL[0] ;
							ya = XA[1] ;

						// ================ GTM FUNCTION CALL =================== 

							delta(c,t, &dx, &dy); 
							nx = C_UDMI(c,t,2);
							ny = C_UDMI(c,t,3);
	
							linseg(c, t_liquid, xl, xr, ya, yf, &xint1, &xint2, &yint1, &yint2, &iface_int1, &iface_int2);
							lgvol( c, t_liquid, xl, xr, ya, yf, &voll );

						// =============== DEFINITION OF N-VECTOR ================ 

				//			n[0]  =  nx; 
				//			n[1]  =  ny;

						// =============== MODIFIED DEFINITION OF S-VECTOR ================ 


						if(xint1 > xint2)
						{
							xi = xint2 + fabs((xint1 - xint2)/2.0) ;
						}
						else
						{
							xi = xint1 + fabs((xint1 - xint2)/2.0) ;
						}

						if(yint1 > yint2)
						{
							yi = yint2 + fabs((yint1 - yint2)/2.0) ;								
						}
						else
						{
							yi = yint1 + fabs((yint1 - yint2)/2.0) ;								
						}							

//============================================================================================================================================						


					// ----------- FRONT FACE ------------ 

						cf = F_C0(ff,tff);
						if(cf == c)
						{
							cf = F_C1(ff,tff);
							tf = F_C1_THREAD(ff,tff);
						}
						else
						{
							tf = F_C0_THREAD(ff,tff);
						}
						
						// ----------- RIGHT FACE ----------- 

							cr = F_C0(fr,tfr);
							if(cr == c)
							{
								cr = F_C1(fr,tfr);
								tr = F_C1_THREAD(fr,tfr);
							}
							else
							{
								tr = F_C0_THREAD(fr,tfr);
							}   

					// ------------ AFTER FACE ------------ 

						ca = F_C0(fa,tfa);
						if(ca == c)
						{
							ca = F_C1(fa,tfa);
							ta = F_C1_THREAD(fa,tfa);
						}
						else
						{
							ta = F_C0_THREAD(fa,tfa);
						}

						C_CENTROID(xcf,cf,tf);
						C_CENTROID(xca,ca,ta);

							if ( fequal( xcf[1], 0.00225865 ) )
							{
								return 0.0;							
							}
							else if ( fequal(xca[1],0.00001135) )
							{
								return 0.0;
							}
							else
							{
									frm = C_FACE(ca,ta,2);
									tfrm = C_FACE_THREAD(ca,ta,2);

									frp = C_FACE(cf,tf,2);
									tfrp = C_FACE_THREAD(cf,tf,2);
			
								// ======================== (crf,trf) ============================= 

									crf = F_C0(frp,tfrp);
									if(crf == cr)
									{
										crf = F_C1(frp,tfrp);
										trf = F_C1_THREAD(frp,tfrp);
									}
									else
									{
										trf = F_C0_THREAD(frp,tfrp);
									}


								// ======================== (cra,tra) ============================= 

									cra = F_C0(frm,tfrm);
									if(cra == cr)
									{
										cra = F_C1(frm,tfrm);
										tra = F_C1_THREAD(frm,tfrm);
									}
									else
									{
										tra = F_C0_THREAD(frm,tfrm);
									}
							}
//			Message(" cf = %u \t crf = %u \n ", cf, crf);		
//			Message(" c  = %u \t cr  = %u \n ", c, cr   );	
//			Message(" ca = %u \t cra = %u \n ", ca, cra);

					}

					// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to right boundary.)
				    else if( fequal(XC[0], 0.00112365) && (XC[1] > 0.00003405) && (XC[1] < 0.0022473)  )
					{
						ff = C_FACE(c,t,1);					
						tff = C_FACE_THREAD(c,t,1);
						fa = C_FACE(c,t,3);
						tfa = C_FACE_THREAD(c,t,3);
						fl = C_FACE(c,t,2);
						tfl = C_FACE_THREAD(c,t,2);	
						fr = C_FACE(c,t,0);
						tfr = C_FACE_THREAD(c,t,0);	
					
			//			Message(" HI I am Right \n");

//=========================================================================================================================================
							F_CENTROID(XR,fr,tfr);
							F_CENTROID(XF,ff,tff);
							F_CENTROID(XL,fl,tfl);
							F_CENTROID(XA,fa,tfa);

							xr = XR[0] ;
							yf = XF[1] ;
							xl = XL[0] ;
							ya = XA[1] ;

						// ================ GTM FUNCTION CALL =================== 

							delta(c,t, &dx, &dy); 
							nx = C_UDMI(c,t,2);
							ny = C_UDMI(c,t,3);
	
							linseg(c, t_liquid, xl, xr, ya, yf, &xint1, &xint2, &yint1, &yint2, &iface_int1, &iface_int2);
							lgvol( c, t_liquid, xl, xr, ya, yf, &voll );

						// =============== DEFINITION OF N-VECTOR ================ 

				//			n[0]  =  nx; 
				//			n[1]  =  ny;

						// =============== MODIFIED DEFINITION OF S-VECTOR ================ 


						if(xint1 > xint2)
						{
							xi = xint2 + fabs((xint1 - xint2)/2.0) ;
						}
						else
						{
							xi = xint1 + fabs((xint1 - xint2)/2.0) ;
						}

						if(yint1 > yint2)
						{
							yi = yint2 + fabs((yint1 - yint2)/2.0) ;								
						}
						else
						{
							yi = yint1 + fabs((yint1 - yint2)/2.0) ;								
						}			

//============================================================================================================================================

							// ----------- FRONT FACE ------------ 

								cf = F_C0(ff,tff);
								if(cf == c)
								{
									cf = F_C1(ff,tff);
									tf = F_C1_THREAD(ff,tff);
								}
								else
								{
									tf = F_C0_THREAD(ff,tff);
								}

					// ----------- LEFT FACE ------------ 

							cl = F_C0(fl,tfl);
							if(cl == c)
							{
								cl = F_C1(fl,tfl);
								tl = F_C1_THREAD(fl,tfl);
							}
							else
							{
								tl = F_C0_THREAD(fl,tfl);
							}


							// ------------ AFTER FACE ------------ 

								ca = F_C0(fa,tfa);
								if(ca == c)
								{
									ca = F_C1(fa,tfa);
									ta = F_C1_THREAD(fa,tfa);
								}
								else
								{
									ta = F_C0_THREAD(fa,tfa);
								}

						C_CENTROID(xcf,cf,tf);
						C_CENTROID(xca,ca,ta);

							if ( fequal( xcf[1], 0.00225865 ) )
							{
								return 0.0;			
							}
							else if ( fequal(xca[1],0.00001135) )
							{
								return 0.0;
							}
							else
							{
									flp = C_FACE(cf,tf,2);
									tflp = C_FACE_THREAD(cf,tf,2);

									flm = C_FACE(ca,ta,2);
									tflm = C_FACE_THREAD(ca,ta,2);


								// ======================== (crf,trf) ============================= 

									clf = F_C0(flp,tflp);
									if(clf == cl)
									{
										clf = F_C1(flp,tflp);
										tlf = F_C1_THREAD(flp,tflp);
									}
									else
									{
										tlf = F_C0_THREAD(flp,tflp);
									}


								// ======================== (cra,tra) ============================= 

									cla = F_C0(flm,tflm);
									if(cla == cl)
									{
										cla = F_C1(flm,tflm);
										tla = F_C1_THREAD(flm,tflm);
									}
									else
									{
										tla = F_C0_THREAD(flm,tflm);
									}
							}
//			Message(" clf = %u \t cf = %u \n ", clf, cf);		
//			Message(" cl = %u  \t c  = %u \n ", cl, c   );	
//			Message(" cla = %u \t ca = %u \n ", cla, ca);




					}

					// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to bottom boundary.)
					else if( fequal(XC[1], 0.00001135) && (XC[0] > 0.0000227) && (XC[0] < 0.00112365) )
					{
						ff = C_FACE(c,t,2);					
						tff = C_FACE_THREAD(c,t,2);
						fr = C_FACE(c,t,1);
						tfr = C_FACE_THREAD(c,t,1);			
						fl = C_FACE(c,t,3);
						tfl = C_FACE_THREAD(c,t,3);
						fa = C_FACE(c,t,0);
						tfa = C_FACE_THREAD(c,t,0);


//=========================================================================================================================================
						F_CENTROID(XR,fr,tfr);
						F_CENTROID(XF,ff,tff);
						F_CENTROID(XL,fl,tfl);
						F_CENTROID(XA,fa,tfa);

						xr = XR[0] ;
						yf = XF[1] ;
						xl = XL[0] ;
						ya = XA[1] ;

					// ================ GTM FUNCTION CALL =================== 

						delta(c,t, &dx, &dy); 
						nx = C_UDMI(c,t,2);
						ny = C_UDMI(c,t,3);
	
						linseg(c, t_liquid, xl, xr, ya, yf, &xint1, &xint2, &yint1, &yint2, &iface_int1, &iface_int2);
						lgvol( c, t_liquid, xl, xr, ya, yf, &voll );

					// =============== DEFINITION OF N-VECTOR ================ 

			//				n[0]  =  nx; 
			//				n[1]  =  ny;

					// =============== MODIFIED DEFINITION OF S-VECTOR ================ 


						if(xint1 > xint2)
						{
							xi = xint2 + fabs((xint1 - xint2)/2.0) ;
						}
						else
						{
							xi = xint1 + fabs((xint1 - xint2)/2.0) ;
						}

						if(yint1 > yint2)
						{
							yi = yint2 + fabs((yint1 - yint2)/2.0) ;								
						}
						else
						{
							yi = yint1 + fabs((yint1 - yint2)/2.0) ;								
						}			

//============================================================================================================================================


						// ----------- RIGHT FACE ----------- 

							cr = F_C0(fr,tfr);
							if(cr == c)
							{
								cr = F_C1(fr,tfr);
								tr = F_C1_THREAD(fr,tfr);
							}
							else
							{
								tr = F_C0_THREAD(fr,tfr);
							}   

						// ----------- LEFT FACE ------------ =

							cl = F_C0(fl,tfl);
							if(cl == c)
							{
								cl = F_C1(fl,tfl);
								tl = F_C1_THREAD(fl,tfl);
							}
							else
							{
								tl = F_C0_THREAD(fl,tfl);
							}

						// ----------- FRONT FACE ------------ =

							cf = F_C0(ff,tff);
							if(cf == c)
							{
								cf = F_C1(ff,tff);
								tf = F_C1_THREAD(ff,tff);
							}
							else
							{
								tf = F_C0_THREAD(ff,tff);
							}

						c_face_loop(cr,tr,N)
						{
							t_fr = C_FACE_THREAD(cr,tr,N);
							if( BOUNDARY_FACE_THREAD_P(t_fr) )
							{
								check_r = TRUE;
							}
						}

					C_CENTROID(xcr, cr, tr);
					C_CENTROID(xcl, cl, tl);

							if (fequal(xcr[0], 0.00112365) )
							{
								return 0.0 ;

							}
							else if(fequal(xcl[0], 0.000011365) )
							{
								return 0.0 ;
							}
							else
							{

									ffr = C_FACE(cr,tr,2);
									tffr = C_FACE_THREAD(cr,tr,2);

									ffl = C_FACE(cl,tl,2);
									tffl = C_FACE_THREAD(cl,tl,2);

								// ======================== (crf,trf) ============================= 

									crf = F_C0(ffr,tffr);
									if(crf == cr)
									{
										crf = F_C1(ffr,tffr);
										trf = F_C1_THREAD(ffr,tffr);
									}
									else
									{
										trf = F_C0_THREAD(ffr,tffr);
									}
						//			Message(" crf = %u \n ", crf);

								// ======================== (clf,tlf) ============================= 

									clf = F_C0(ffl,tffl);
									if(clf == cl)
									{
										clf = F_C1(ffl,tffl);
										tlf = F_C1_THREAD(ffl,tffl);
									}
									else
									{
										tlf = F_C0_THREAD(ffl,tffl);
									}
						//			Message(" clf = %u \n ", clf);
							
							}

//								Message(" clf = %u \t cf = %u \t crf = %u \n ", clf, cf, crf);		
//								Message(" cl = %u  \t c  = %u \t cr  = %u \n ", cl, c, cr   );									

					}
					
					// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to top boundary.)
					else if( fequal(XC[1], 0.00225865) && (XC[0] > 0.0000227) && (XC[0] < 0.00112365) )
					{
						fa = C_FACE(c,t,2);
						tfa = C_FACE_THREAD(c,t,2);
						fr = C_FACE(c,t,3);
						tfr = C_FACE_THREAD(c,t,3);			
						fl = C_FACE(c,t,1);
						tfl = C_FACE_THREAD(c,t,1);
						ff = C_FACE(c,t,0);
						tff = C_FACE_THREAD(c,t,0);

	//					Message(" HI I am TOP \n");
					
//=========================================================================================================================================
						F_CENTROID(XR,fr,tfr);
						F_CENTROID(XF,ff,tff);
						F_CENTROID(XL,fl,tfl);
						F_CENTROID(XA,fa,tfa);

						xr = XR[0] ;
						yf = XF[1] ;
						xl = XL[0] ;
						ya = XA[1] ;

					// ================ GTM FUNCTION CALL =================== 

						delta(c,t, &dx, &dy); 
						nx = C_UDMI(c,t,2);
						ny = C_UDMI(c,t,3);
	
						linseg(c, t_liquid, xl, xr, ya, yf, &xint1, &xint2, &yint1, &yint2, &iface_int1, &iface_int2);
						lgvol( c, t_liquid, xl, xr, ya, yf, &voll );

					// =============== DEFINITION OF N-VECTOR ================ 

			//				n[0]  =  nx; 
			//				n[1]  =  ny;

					// =============== MODIFIED DEFINITION OF S-VECTOR ================ 


						if(xint1 > xint2)
						{
							xi = xint2 + fabs((xint1 - xint2)/2.0) ;
						}
						else
						{
							xi = xint1 + fabs((xint1 - xint2)/2.0) ;
						}

						if(yint1 > yint2)
						{
							yi = yint2 + fabs((yint1 - yint2)/2.0) ;								
						}
						else
						{
							yi = yint1 + fabs((yint1 - yint2)/2.0) ;								
						}			

//============================================================================================================================================

						// ----------- RIGHT FACE ----------- 

							cr = F_C0(fr,tfr);
							if(cr == c)
							{
								cr = F_C1(fr,tfr);
								tr = F_C1_THREAD(fr,tfr);
							}
							else
							{
								tr = F_C0_THREAD(fr,tfr);
							}   

						// ----------- LEFT FACE ------------ 

							cl = F_C0(fl,tfl);
							if(cl == c)
							{
								cl = F_C1(fl,tfl);
								tl = F_C1_THREAD(fl,tfl);
							}
							else
							{
								tl = F_C0_THREAD(fl,tfl);
							}

						// ----------- AFTER FACE ------------ 

							ca = F_C0(fa,tfa);
							if(ca == c)
							{
								ca = F_C1(fa,tfa);
								ta = F_C1_THREAD(fa,tfa);
							}
							else
							{
								ta = F_C0_THREAD(fa,tfa);
							}



							C_CENTROID(xcr,cr,tr);
							C_CENTROID(xcl,cl,tl);

							if (fequal(xcr[0] , 0.00112365))
							{
								return 0.0 ;
							}
							else if(fequal(xcl[0], 0.00001135))
							{
								return 0.0 ;
							}
							else
							{
									far = C_FACE(cr,tr,2);
									tfar = C_FACE_THREAD(cr,tr,2);

									fal = C_FACE(cl,tl,2);
									tfal = C_FACE_THREAD(cl,tl,2);

								// ======================== (cra,tra) ============================= 

									cra = F_C0(far,tfar);
									if(cra == cr)
									{
										cra = F_C1(far,tfar);
										tra = F_C1_THREAD(far,tfar);
									}
									else
									{
										tra = F_C0_THREAD(far,tfar);
									}
						//			Message(" crf = %u \n ", crf);

								// ======================== (cla,tla) ============================= 

									cla = F_C0(fal,tfal);
									if(cla == cl)
									{
										cla = F_C1(fal,tfal);
										tla = F_C1_THREAD(fal,tfal);
									}
									else
									{
										tla = F_C0_THREAD(fal,tfal);
									}
						//			Message(" clf = %u \n ", clf);

							}
//									Message(" cl = %u  \t c  = %u \t cr  = %u \n ", cl, c, cr   );
//									Message(" cla = %u \t ca = %u \t cra = %u \n ", cla, ca, cra);
					}				
					else
					{
						return 0.0;

						}
			
	}
	else
	{
	
		fr = C_FACE(c,t,1);
		tfr = C_FACE_THREAD(c,t,1);
		fl = C_FACE(c,t,3);					
		tfl = C_FACE_THREAD(c,t,3);			
		ff = C_FACE(c,t,2);					
		tff = C_FACE_THREAD(c,t,2);
		fa = C_FACE(c,t,0);
		tfa = C_FACE_THREAD(c,t,0);
	



	// ----------- RIGHT FACE ----------- =

		cr = F_C0(fr,tfr);
		if(cr == c)
		{
			cr = F_C1(fr,tfr);
			tr = F_C1_THREAD(fr,tfr);
		}
		else
		{
			tr = F_C0_THREAD(fr,tfr);
		}   

	// ----------- LEFT FACE ------------ =

		cl = F_C0(fl,tfl);
		if(cl == c)
		{
			cl = F_C1(fl,tfl);
			tl = F_C1_THREAD(fl,tfl);
		}
		else
		{
			tl = F_C0_THREAD(fl,tfl);
		}

	// ----------- FRONT FACE ------------ =

		cf = F_C0(ff,tff);
		if(cf == c)
		{
			cf = F_C1(ff,tff);
			tf = F_C1_THREAD(ff,tff);
		}
		else
		{
			tf = F_C0_THREAD(ff,tff);
		}

	// ------------ AFTER FACE ------------ =

		ca = F_C0(fa,tfa);
		if(ca == c)
		{
			ca = F_C1(fa,tfa);
			ta = F_C1_THREAD(fa,tfa);
		}
		else
		{
			ta = F_C0_THREAD(fa,tfa);
		}
//	Message("      cf    = \t \t %u \t \t  \n ", cf );
//	Message(" cl , c, cr = %u \t %u \t %u \n ", cl, c, cr );
//	Message("      ca    = \t \t %u \t \t  \n ", ca );

//=========================================================================================================================================
						F_CENTROID(XR,fr,tfr);
						F_CENTROID(XF,ff,tff);
						F_CENTROID(XL,fl,tfl);
						F_CENTROID(XA,fa,tfa);

						xr = XR[0] ;
						yf = XF[1] ;
						xl = XL[0] ;
						ya = XA[1] ;

					// ================ GTM FUNCTION CALL =================== 

						delta(c,t, &dx, &dy); 
						nx = C_UDMI(c,t,2);
						ny = C_UDMI(c,t,3);
	
						linseg(c, t_liquid, xl, xr, ya, yf, &xint1, &xint2, &yint1, &yint2, &iface_int1, &iface_int2);
						lgvol( c, t_liquid, xl, xr, ya, yf, &voll );

					// =============== DEFINITION OF N-VECTOR ================ 

		//					n[0]  =  nx; 
		//					n[1]  =  ny;

					// =============== MODIFIED DEFINITION OF S-VECTOR ================ 


						if(xint1 > xint2)
						{
							xi = xint2 + fabs((xint1 - xint2)/2.0) ;
						}
						else
						{
							xi = xint1 + fabs((xint1 - xint2)/2.0) ;
						}

						if(yint1 > yint2)
						{
							yi = yint2 + fabs((yint1 - yint2)/2.0) ;								
						}
						else
						{
							yi = yint1 + fabs((yint1 - yint2)/2.0) ;								
						}			

//============================================================================================================================================


		c_face_loop(cr,tr,N)
		{
			t_fr = C_FACE_THREAD(cr,tr,N);
			if( BOUNDARY_FACE_THREAD_P(t_fr) )
			{
				check_r = TRUE;
			}
		}

		c_face_loop(cf,tf,N)
		{
			t_ff = C_FACE_THREAD(cf,tf,N);
			if( BOUNDARY_FACE_THREAD_P(t_ff) )
			{
				check_f = TRUE;
			}
		}

		c_face_loop(cl,tl,N)
		{
			t_fl = C_FACE_THREAD(cl,tl,N);
			if( BOUNDARY_FACE_THREAD_P(t_fl) )
			{
				check_l = TRUE;
			}
		}

		c_face_loop(ca,ta,N)
		{
			t_fa = C_FACE_THREAD(ca,ta,N);
			if( BOUNDARY_FACE_THREAD_P(t_fa) )
			{
				check_a = TRUE;
			}
		}				

		if( check_r )
		{
//			Message(" BOUNDARY CELL ENCOUNTERED \n ");
			

				ffr = C_FACE(cr,tr,1);
				tffr = C_FACE_THREAD(cr,tr,1);

				far = C_FACE(cr,tr,3);
				tfar = C_FACE_THREAD(cr,tr,3);

				ffl = C_FACE(cl,tl,2);
				tffl = C_FACE_THREAD(cl,tl,2);

				fal = C_FACE(cl,tl,0);
				tfal = C_FACE_THREAD(cl,tl,0);

			// ======================== (crf,trf) ============================= =

				crf = F_C0(ffr,tffr);
				if(crf == cr)
				{
					crf = F_C1(ffr,tffr);
					trf = F_C1_THREAD(ffr,tffr);
				}
				else
				{
					trf = F_C0_THREAD(ffr,tffr);
				}
	//			Message(" crf = %u \n ", crf);
			// ======================== (cra,tra) ============================= =

				cra = F_C0(far,tfar);
				if(cra == cr)
				{
					cra = F_C1(far,tfar);
					tra = F_C1_THREAD(far,tfar);
				}
				else
				{
					tra = F_C0_THREAD(far,tfar);
				}
	//			Message(" cra = %u \n ", cra);	
			// ======================== (clf,tlf) ============================= =

				clf = F_C0(ffl,tffl);
				if(clf == cl)
				{
					clf = F_C1(ffl,tffl);
					tlf = F_C1_THREAD(ffl,tffl);
				}
				else
				{
					tlf = F_C0_THREAD(ffl,tffl);
				}
	//			Message(" clf = %u \n ", clf);
			// ======================== (cla,tla) ============================= =

				cla = F_C0(fal,tfal);
				if(cla == cl)
				{
					cla = F_C1(fal,tfal);
					tla = F_C1_THREAD(fal,tfal);
				}
				else
				{
					tla = F_C0_THREAD(fal,tfal);
				}
	//			Message(" cla = %u \n ", cla);
		
		}
		else if ( check_f )
		{
			
				frp = C_FACE(cf,tf,3);
				tfrp = C_FACE_THREAD(cf,tf,3);

				flp = C_FACE(cf,tf,1);
				tflp = C_FACE_THREAD(cf,tf,1);

				frm = C_FACE(ca,ta,1);
				tfrm = C_FACE_THREAD(ca,ta,1);

				flm = C_FACE(ca,ta,3);
				tflm = C_FACE_THREAD(ca,ta,3);

			// ======================== (crf,trf) ============================= =

				crf = F_C0(frp,tfrp);
				if(crf == cr)
				{
					crf = F_C1(frp,tfrp);
					trf = F_C1_THREAD(frp,tfrp);
				}
				else
				{
					trf = F_C0_THREAD(frp,tfrp);
				}

			// ======================== (clf,tlf) ============================= =

				clf = F_C0(flp,tflp);
				if(clf == cl)
				{
					clf = F_C1(flp,tflp);
					tlf = F_C1_THREAD(flp,tflp);
				}
				else
				{
					tlf = F_C0_THREAD(flp,tflp);
				}

			// ======================== (cra,tra) ============================= =

				cra = F_C0(frm,tfrm);
				if(cra == cr)
				{
					cra = F_C1(frm,tfrm);
					tra = F_C1_THREAD(frm,tfrm);
				}
				else
				{
					tra = F_C0_THREAD(frm,tfrm);
				}

			// ======================== (cla,tla) ============================= =

				cla = F_C0(flm,tflm);
				if(cla == cl)
				{
					cla = F_C1(flm,tflm);
					tla = F_C1_THREAD(flm,tflm);
				}
				else
				{
					tla = F_C0_THREAD(flm,tflm);
				}
			
		}
		else if ( check_l ) 
		{
			
				ffl = C_FACE(cl,tl,3);
				tffl = C_FACE_THREAD(cl,tl,3);

				fal = C_FACE(cl,tl,1);
				tfal = C_FACE_THREAD(cl,tl,1);

				ffr = C_FACE(cr,tr,2);
				tffr = C_FACE_THREAD(cr,tr,2);

				far = C_FACE(cr,tr,0);
				tfar = C_FACE_THREAD(cr,tr,0);

			// ======================== (crf,trf) ============================= =

				crf = F_C0(ffr,tffr);
				if(crf == cr)
				{
					crf = F_C1(ffr,tffr);
					trf = F_C1_THREAD(ffr,tffr);
				}
				else
				{
					trf = F_C0_THREAD(ffr,tffr);
				}
	//			Message(" crf = %u \n ", crf);
			// ======================== (cra,tra) ============================= =

				cra = F_C0(far,tfar);
				if(cra == cr)
				{
					cra = F_C1(far,tfar);
					tra = F_C1_THREAD(far,tfar);
				}
				else
				{
					tra = F_C0_THREAD(far,tfar);
				}
	//			Message(" cra = %u \n ", cra);	
			// ======================== (clf,tlf) ============================= =

				clf = F_C0(ffl,tffl);
				if(clf == cl)
				{
					clf = F_C1(ffl,tffl);
					tlf = F_C1_THREAD(ffl,tffl);
				}
				else
				{
					tlf = F_C0_THREAD(ffl,tffl);
				}
	//			Message(" clf = %u \n ", clf);
			// ======================== (cla,tla) ============================= =

				cla = F_C0(fal,tfal);
				if(cla == cl)
				{
					cla = F_C1(fal,tfal);
					tla = F_C1_THREAD(fal,tfal);
				}
				else
				{
					tla = F_C0_THREAD(fal,tfal);
				}
	//			Message(" cla = %u \n ", cla);
		
			
		}
		else if ( check_a )
		{
			
				frm = C_FACE(ca,ta,1);
				tfrm = C_FACE_THREAD(ca,ta,1);

				flm = C_FACE(ca,ta,3);
				tflm = C_FACE_THREAD(ca,ta,3);

				frp = C_FACE(cf,tf,1);
				tfrp = C_FACE_THREAD(cf,tf,1);

				flp = C_FACE(cf,tf,3);
				tflp = C_FACE_THREAD(cf,tf,3);
			
			// ======================== (crf,trf) ============================= =

				crf = F_C0(frp,tfrp);
				if(crf == cr)
				{
					crf = F_C1(frp,tfrp);
					trf = F_C1_THREAD(frp,tfrp);
				}
				else
				{
					trf = F_C0_THREAD(frp,tfrp);
				}

			// ======================== (clf,tlf) ============================= =
				clf = F_C0(flp,tflp);
				if(clf == cl)
				{
					clf = F_C1(flp,tflp);
					tlf = F_C1_THREAD(flp,tflp);
				}
				else
				{
					tlf = F_C0_THREAD(flp,tflp);
				}

			// ======================== (cra,tra) ============================= =

				cra = F_C0(frm,tfrm);
				if(cra == cr)
				{
					cra = F_C1(frm,tfrm);
					tra = F_C1_THREAD(frm,tfrm);
				}
				else
				{
					tra = F_C0_THREAD(frm,tfrm);
				}

			// ======================== (cla,tla) ============================= =

				cla = F_C0(flm,tflm);
				if(cla == cl)
				{
					cla = F_C1(flm,tflm);
					tla = F_C1_THREAD(flm,tflm);
				}
				else
				{
					tla = F_C0_THREAD(flm,tflm);
				}
		}
		else
		{
		// ============== DEFINITION OF SECONDARY NEIGHBOURS ============== =

 
			ffr = C_FACE(cr,tr,2);
			tffr = C_FACE_THREAD(cr,tr,2);

			far = C_FACE(cr,tr,0);
			tfar = C_FACE_THREAD(cr,tr,0);

			ffl = C_FACE(cl,tl,2);
			tffl = C_FACE_THREAD(cl,tl,2);

			fal = C_FACE(cl,tl,0);
			tfal = C_FACE_THREAD(cl,tl,0);

//		Message("  far, tfar, ffl, tffl, fal, tfal =  %u %u %u %u %u %u  \n ", far, tfar, ffl, tffl, fal, tfal); 



		// ======================== (crf,trf) ============================= =

			crf = F_C0(ffr,tffr);
			if(crf == cr)
			{
				crf = F_C1(ffr,tffr);
				trf = F_C1_THREAD(ffr,tffr);
			}
			else
			{
				trf = F_C0_THREAD(ffr,tffr);
			}
//			Message(" crf = %u \n ", crf);
		// ======================== (cra,tra) ============================= =

		cra = F_C0(far,tfar);
			if(cra == cr)
			{
				cra = F_C1(far,tfar);
				tra = F_C1_THREAD(far,tfar);
			}
			else
			{
				tra = F_C0_THREAD(far,tfar);
			}
//			Message(" cra = %u \n ", cra);	
		// ======================== (clf,tlf) ============================= =

			clf = F_C0(ffl,tffl);
			if(clf == cl)
			{
				clf = F_C1(ffl,tffl);
				tlf = F_C1_THREAD(ffl,tffl);
			}
			else
			{
				tlf = F_C0_THREAD(ffl,tffl);
			}
//			Message(" clf = %u \n ", clf);
		// ======================== (cla,tla) ============================= =

			cla = F_C0(fal,tfal);
			if(cla == cl)
			{
				cla = F_C1(fal,tfal);
				tla = F_C1_THREAD(fal,tfal);
			}
			else
			{
				tla = F_C0_THREAD(fal,tfal);
			}
//			Message(" cla = %u \n ", cla);
			
			}

//	Message(" clf = %u \t cf = %u \t crf = %u \n ", clf, cf, crf);		
//	Message(" cl = %u  \t c  = %u \t cr  = %u \n ", cl, c, cr   );	
//	Message(" cla = %u \t ca = %u \t cra = %u \n ", cla, ca, cra);
//	Message(" tlf = %u \t tf = %u \t trf = %u \n ", tlf, tf, trf);		
//	Message(" tl = %u  \t t  = %u \t tr  = %u \n ", tl, t, tr   );	
//	Message(" tla = %u \t ta = %u \t tra = %u \n ", tla, ta, tra);
					

		}
			

		


	
			//	Message(" X[ND_ND] , Xr[ND_ND] = \n %g %g \n %g %g \n ", xi, X[1], Xr[0], Xr[1]);

		

										t_f = C_FACE_THREAD(c,t,0);

  										C_CENTROID(XC,c,t);
	

										if(BOUNDARY_FACE_THREAD_P(t_f))
										{


											    if( fequal(XC[0], 0.00001135) && (XC[1] > 0.00003405) && (XC[1] < 0.0022473)  )			// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to left boundary.)
												{
													C_CENTROID(X,c,t);
													C_CENTROID(Xr,cr,tr);
													C_CENTROID(Xf,cf,tf);
													C_CENTROID(Xa,ca,ta);
													C_CENTROID(Xrf,crf,trf);		
													C_CENTROID(Xra,cra,tra);

													NV_D(S11 , = , (Xf[0] - xi) , (Xf[1] - yi) , 0.0 );
													NV_D(S12 , = , (Xrf[0]  - xi) , (Xrf[1]  - yi) , 0.0 );
													NV_D(S21 , = , (X[0]  - xi) , (X[1]  - yi) , 0.0 );
													NV_D(S22 , = , (Xr[0]   - xi) , (Xr[1]   - yi) , 0.0 );
													NV_D(S31 , = , (Xa[0] - xi) , (Xa[1] - yi) , 0.0 );
													NV_D(S32 , = , (Xra[0]  - xi) , (Xra[1]  - yi) , 0.0 );
		
													SX[1][1] = (Xf[0] - xi);
													SX[1][2] = (Xrf[0]  - xi);
													SX[2][1] = (X[0]  - xi);
													SX[2][2] = (Xr[0]   - xi);
													SX[3][1] = (Xa[0] - xi);
													SX[3][2] = (Xra[0]  - xi);
	
													SY[1][1] = (Xf[1] - yi);
													SY[1][2] = (Xrf[1]  - yi);
													SY[2][1] = (X[1]  - yi);
													SY[2][2] = (Xr[1]   - yi);
													SY[3][1] = (Xa[1] - yi);
													SY[3][2] = (Xra[1]  - yi);

													DS[1][1] = sqrt(SX[1][1]*SX[1][1] + SY[1][1]*SY[1][1]) ;
													DS[1][2] = sqrt(SX[1][2]*SX[1][2] + SY[1][2]*SY[1][2]) ;
												//	DS[1][3] = sqrt(SX[1][3]*SX[1][3] + SY[1][3]*SY[1][3]) ;
													DS[2][1] = sqrt(SX[2][1]*SX[2][1] + SY[2][1]*SY[2][1]) ;
													DS[2][2] = sqrt(SX[2][2]*SX[2][2] + SY[2][2]*SY[2][2]) ;
												//	DS[2][3] = sqrt(SX[2][3]*SX[2][3] + SY[2][3]*SY[2][3]) ;
													DS[3][1] = sqrt(SX[3][1]*SX[3][1] + SY[3][1]*SY[3][1]) ;
													DS[3][2] = sqrt(SX[3][2]*SX[3][2] + SY[3][2]*SY[3][2]) ;
												//	DS[3][3] = sqrt(SX[3][3]*SX[3][3] + SY[3][3]*SY[3][3]) ;

													SX[1][1] /= DS[1][1];
													SX[1][2] /= DS[1][2];
													SX[2][1] /= DS[2][1];
													SX[2][2] /= DS[2][2];
													SX[3][1] /= DS[3][1];
													SX[3][2] /= DS[3][2];
	
													SY[1][1] /= DS[1][1];
													SY[1][2] /= DS[1][2];
													SY[2][1] /= DS[2][1];
													SY[2][2] /= DS[2][2];
													SY[3][1] /= DS[3][1];
													SY[3][2] /= DS[3][2];

													dot_prod[1][1] = -( SX[1][1]*n[0] + SY[1][1]*n[1] ) ;//NV_DOT( S[1][1] , n );
													dot_prod[1][2] = -( SX[1][2]*n[0] + SY[1][2]*n[1] ) ;//NV_DOT( S[1][2] , n );
													dot_prod[2][1] = -( SX[2][1]*n[0] + SY[2][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[2][2] = -( SX[2][2]*n[0] + SY[2][2]*n[1] ) ;//NV_DOT( S[2][2] , n );
													dot_prod[3][1] = -( SX[3][1]*n[0] + SY[3][1]*n[1] ) ;//NV_DOT( S[3][1] , n );
													dot_prod[3][2] = -( SX[3][2]*n[0] + SY[3][2]*n[1] ) ;//NV_DOT( S[3][2] , n );

													big = -1.0;
																for( rr = 1; rr <= 3; rr++)
																	for( cc = 1; cc <= 2; cc++)
																	{
																		if (dot_prod[rr][cc] > dot_prod[rr + 1][cc + 1])
																		{
																			big = dot_prod[rr][cc] *100000.0 ;
																			n_row = rr;
																			n_col = cc;
						
																			if(big != 0)
																			{
																	//			Message( " big, rr, cc = %g %d %d \n ", big, rr, cc);
																			}

																			if(rr == 1 && cc == 1)
																			{
																				cs = cf;
																				ts = tf;
																			}
																			else if(rr == 1 && cc == 2)
																			{
																				cs = crf;
																				ts = trf;
																			}
																			else if(rr == 2 && cc == 1)
																			{
																				cs = c;
																				ts = t;
																			}
																			else if(rr == 2 && cc == 2)
																			{
																				cs = cr;
																				ts = tr;
																			}
																			else if(rr == 3 && cc == 1)
																			{
																				cs = ca;
																				ts = ta;
																			}
																			else if(rr == 3 && cc == 2)
																			{
																				cs = cra;
																				ts = tra;
																			}

																		}
																		else
																		{
																			big = big;
																			n_row = n_row ;
																			n_col = n_col ;
																			cs = cs;
																			ts = ts;


																		}
																	}
														Message(" LHS n_row, n_col = %d %d \n ", n_row, n_col );
												}
												else if( fequal(XC[0], 0.00112365) && (XC[1] > 0.00003405) && (XC[1] < 0.0022473)  )			// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to right boundary.)
												{
													C_CENTROID(X,c,t);
													C_CENTROID(Xf,cf,tf);
													C_CENTROID(Xl,cl,tl);		 
													C_CENTROID(Xa,ca,ta);
													C_CENTROID(Xlf,clf,tlf);
													C_CENTROID(Xla,cla,tla);		

													SX[1][1] = (X[0] - xi);
													SX[1][2] = (Xf[0]  - xi);
													SX[2][1] = (Xl[0]  - xi);
													SX[2][2] = (Xa[0]   - xi);
													SX[3][1] = (Xlf[0] - xi);
													SX[3][2] = (Xla[0]  - xi);
	
													SY[1][1] = (X[1] - yi);
													SY[1][2] = (Xf[1]  - yi);
													SY[2][1] = (Xl[1]  - yi);
													SY[2][2] = (Xa[1]   - yi);
													SY[3][1] = (Xlf[1] - yi);
													SY[3][2] = (Xla[1]  - yi);

													DS[1][1] = sqrt(SX[1][1]*SX[1][1] + SY[1][1]*SY[1][1]) ;
													DS[1][2] = sqrt(SX[1][2]*SX[1][2] + SY[1][2]*SY[1][2]) ;
												//	DS[1][3] = sqrt(SX[1][3]*SX[1][3] + SY[1][3]*SY[1][3]) ;
													DS[2][1] = sqrt(SX[2][1]*SX[2][1] + SY[2][1]*SY[2][1]) ;
													DS[2][2] = sqrt(SX[2][2]*SX[2][2] + SY[2][2]*SY[2][2]) ;
												//	DS[2][3] = sqrt(SX[2][3]*SX[2][3] + SY[2][3]*SY[2][3]) ;
													DS[3][1] = sqrt(SX[3][1]*SX[3][1] + SY[3][1]*SY[3][1]) ;
													DS[3][2] = sqrt(SX[3][2]*SX[3][2] + SY[3][2]*SY[3][2]) ;
												//	DS[3][3] = sqrt(SX[3][3]*SX[3][3] + SY[3][3]*SY[3][3]) ;

													SX[1][1] /= DS[1][1];
													SX[1][2] /= DS[1][2];
													SX[2][1] /= DS[2][1];
													SX[2][2] /= DS[2][2];
													SX[3][1] /= DS[3][1];
													SX[3][2] /= DS[3][2];
	
													SY[1][1] /= DS[1][1];
													SY[1][2] /= DS[1][2];
													SY[2][1] /= DS[2][1];
													SY[2][2] /= DS[2][2];
													SY[3][1] /= DS[3][1];
													SY[3][2] /= DS[3][2];

													dot_prod[1][1] = -( SX[1][1]*n[0] + SY[1][1]*n[1] ) ;//NV_DOT( S[1][1] , n );
													dot_prod[1][2] = -( SX[1][2]*n[0] + SY[1][2]*n[1] ) ;//NV_DOT( S[1][2] , n );
													dot_prod[2][1] = -( SX[2][1]*n[0] + SY[2][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[2][2] = -( SX[2][2]*n[0] + SY[2][2]*n[1] ) ;//NV_DOT( S[2][2] , n );
													dot_prod[3][1] = -( SX[3][1]*n[0] + SY[3][1]*n[1] ) ;//NV_DOT( S[3][1] , n );
													dot_prod[3][2] = -( SX[3][2]*n[0] + SY[3][2]*n[1] ) ;//NV_DOT( S[3][2] , n );

													big = 0.0;

																for( rr = 1; rr <= 3; rr++)
																	for( cc = 1; cc <= 2; cc++)
																	{
																		if (dot_prod[rr][cc] > big )
																		{
																			big = dot_prod[rr][cc] ;
																			n_row = rr;
																			n_col = cc;
						
																			if(big != 0)
																			{
																	//			Message( " big, rr, cc = %g %d %d \n ", big, rr, cc);
																			}

																			if(rr == 1 && cc == 1)
																			{
																				cs = clf;
																				ts = tlf;
																			}
																			else if(rr == 1 && cc == 2)
																			{
																				cs = cf;
																				ts = tf;
																			}
																			else if(rr == 2 && cc == 1)
																			{
																				cs = cl;
																				ts = tl;
																			}
																			else if(rr == 2 && cc == 2)
																			{
																				cs = c;
																				ts = t;
																			}
																			else if(rr == 3 && cc == 1)
																			{
																				cs = cla;
																				ts = tla;
																			}
																			else if(rr == 3 && cc == 2)
																			{
																				cs = ca;
																				ts = ta;
																			}

																		}
																		else
																		{
																			big = big;
																			n_row = n_row ;
																			n_col = n_col ;
																			cs = cs;
																			ts = ts;


																		}
																	}
														Message(" RHS n_row, n_col = %d %d \n ", n_row, n_col );

												}
												else if( fequal(XC[1], 0.00001135) && (XC[0] > 0.0000227) && (XC[0] < 0.00112365) )// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to bottom boundary.)
												{
													C_CENTROID(X,c,t);
													C_CENTROID(Xr,cr,tr);
													C_CENTROID(Xf,cf,tf);
													C_CENTROID(Xl,cl,tl);
													C_CENTROID(Xrf,crf,trf);
													C_CENTROID(Xlf,clf,tlf);
								
													SX[1][1] = (Xlf[0] - xi);
													SX[1][2] = (Xf[0]  - xi);
													SX[1][3] = (Xrf[0] - xi);
													SX[2][1] = (Xl[0]  - xi);
													SX[2][2] = (X[0]   - xi);
													SX[2][3] = (Xr[0]  - xi);
	
													SY[1][1] = (Xlf[1] - yi);
													SY[1][2] = (Xf[1]  - yi);
													SY[1][3] = (Xrf[1] - yi);
													SY[2][1] = (Xl[1]  - yi);
													SY[2][2] = (X[1]   - yi);
													SY[2][3] = (Xr[1]  - yi);


													DS[1][1] = sqrt(SX[1][1]*SX[1][1] + SY[1][1]*SY[1][1]) ;
													DS[1][2] = sqrt(SX[1][2]*SX[1][2] + SY[1][2]*SY[1][2]) ;
													DS[1][3] = sqrt(SX[1][3]*SX[1][3] + SY[1][3]*SY[1][3]) ;
													DS[2][1] = sqrt(SX[2][1]*SX[2][1] + SY[2][1]*SY[2][1]) ;
													DS[2][2] = sqrt(SX[2][2]*SX[2][2] + SY[2][2]*SY[2][2]) ;
													DS[2][3] = sqrt(SX[2][3]*SX[2][3] + SY[2][3]*SY[2][3]) ;
												//	DS[3][1] = sqrt(SX[3][1]*SX[3][1] + SY[3][1]*SY[3][1]) ;
												//	DS[3][2] = sqrt(SX[3][2]*SX[3][2] + SY[3][2]*SY[3][2]) ;
												//	DS[3][3] = sqrt(SX[3][3]*SX[3][3] + SY[3][3]*SY[3][3]) ;

													SX[1][1] /= DS[1][1];
													SX[1][2] /= DS[1][2];
													SX[1][3] /= DS[1][3];
													SX[2][1] /= DS[2][1];
													SX[2][2] /= DS[2][2];
													SX[2][3] /= DS[2][3];											
											
	
													SY[1][1] /= DS[1][1];
													SY[1][2] /= DS[1][2];
													SY[1][3] /= DS[1][3];
													SY[2][1] /= DS[2][1];
													SY[2][2] /= DS[2][2];
													SY[2][3] /= DS[2][3];											

													dot_prod[1][1] = -( SX[1][1]*n[0] + SY[1][1]*n[1] ) ;//NV_DOT( S[1][1] , n );
													dot_prod[1][2] = -( SX[1][2]*n[0] + SY[1][2]*n[1] ) ;//NV_DOT( S[1][2] , n );
													dot_prod[1][3] = -( SX[1][3]*n[0] + SY[1][3]*n[1] ) ;//NV_DOT( S[3][1] , n );
													dot_prod[2][1] = -( SX[2][1]*n[0] + SY[2][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[2][2] = -( SX[2][2]*n[0] + SY[2][2]*n[1] ) ;//NV_DOT( S[2][2] , n );
													dot_prod[2][3] = -( SX[2][3]*n[0] + SY[2][3]*n[1] ) ;//NV_DOT( S[3][2] , n );	

													

													big = -1.0;
													for( rr = 1; rr <= 2; rr++)
														for( cc = 1; cc <= 3; cc++)
														{
															if (dot_prod[rr][cc] > big)
															{
																big = dot_prod[rr][cc]  ;
																n_row = rr;
																n_col = cc;
						
																if(big != 0)
																{
														//			Message( " big, rr, cc = %g %d %d \n ", big, rr, cc);
																}

																if(rr == 1 && cc == 1)
																{
																	cs = clf;
																	ts = tlf;
																}
																else if(rr == 1 && cc == 2)
																{
																	cs = cf;
																	ts = tf;
																}
																else if(rr == 1 && cc == 3)
																{
																	cs = crf;
																	ts = trf;
																}
																else if(rr == 2 && cc == 1)
																{
																	cs = cl;
																	ts = tl;
																}
																else if(rr == 2 && cc == 2)
																{
																	cs = c;
																	ts = t;
																}
																else if(rr == 2 && cc == 3)
																{
																	cs = cr;
																	ts = tr;
																}

															}
															else
															{
																big = big;
																n_row = n_row;
																n_col = n_col;
																cs = cs;
																ts = ts;
										
															}
														}
													Message(" B.B n_row, n_col = %d %d \n ", n_row, n_col );
												}
												else if( fequal(XC[1], 0.00225865) && (XC[0] > 0.0000227) && (XC[0] < 0.00112365) )					// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to top boundary.)
												{
													C_CENTROID(X,c,t);
													C_CENTROID(Xr,cr,tr);
													C_CENTROID(Xl,cl,tl);		 
													C_CENTROID(Xa,ca,ta);
													C_CENTROID(Xla,cla,tla);				
													C_CENTROID(Xra,cra,tra);
											
													SX[1][1] = (Xl[0] - xi);
													SX[1][2] = (X[0]  - xi);
													SX[1][3] = (Xr[0] - xi);
													SX[2][1] = (Xla[0]  - xi);
													SX[2][2] = (Xa[0]   - xi);
													SX[2][3] = (Xra[0]  - xi);
	
													SY[1][1] = (Xl[1] - yi);
													SY[1][2] = (X[1]  - yi);
													SY[1][3] = (Xr[1] - yi);
													SY[2][1] = (Xla[1]  - yi);
													SY[2][2] = (Xa[1]   - yi);
													SY[2][3] = (Xra[1]  - yi);


													DS[1][1] = sqrt(SX[1][1]*SX[1][1] + SY[1][1]*SY[1][1]) ;
													DS[1][2] = sqrt(SX[1][2]*SX[1][2] + SY[1][2]*SY[1][2]) ;
													DS[1][3] = sqrt(SX[1][3]*SX[1][3] + SY[1][3]*SY[1][3]) ;
													DS[2][1] = sqrt(SX[2][1]*SX[2][1] + SY[2][1]*SY[2][1]) ;
													DS[2][2] = sqrt(SX[2][2]*SX[2][2] + SY[2][2]*SY[2][2]) ;
													DS[2][3] = sqrt(SX[2][3]*SX[2][3] + SY[2][3]*SY[2][3]) ;
												//	DS[3][1] = sqrt(SX[3][1]*SX[3][1] + SY[3][1]*SY[3][1]) ;
												//	DS[3][2] = sqrt(SX[3][2]*SX[3][2] + SY[3][2]*SY[3][2]) ;
												//	DS[3][3] = sqrt(SX[3][3]*SX[3][3] + SY[3][3]*SY[3][3]) ;

													SX[1][1] /= DS[1][1];
													SX[1][2] /= DS[1][2];
													SX[1][3] /= DS[1][3];
													SX[2][1] /= DS[2][1];
													SX[2][2] /= DS[2][2];
													SX[2][3] /= DS[2][3];											
											
	
													SY[1][1] /= DS[1][1];
													SY[1][2] /= DS[1][2];
													SY[1][3] /= DS[1][3];
													SY[2][1] /= DS[2][1];
													SY[2][2] /= DS[2][2];
													SY[2][3] /= DS[2][3];											

													dot_prod[1][1] = -( SX[1][1]*n[0] + SY[1][1]*n[1] ) ;//NV_DOT( S[1][1] , n );
													dot_prod[1][2] = -( SX[1][2]*n[0] + SY[1][2]*n[1] ) ;//NV_DOT( S[1][2] , n );
													dot_prod[1][3] = -( SX[1][3]*n[0] + SY[1][3]*n[1] ) ;//NV_DOT( S[3][1] , n );
													dot_prod[2][1] = -( SX[2][1]*n[0] + SY[2][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[2][2] = -( SX[2][2]*n[0] + SY[2][2]*n[1] ) ;//NV_DOT( S[2][2] , n );
													dot_prod[2][3] = -( SX[2][3]*n[0] + SY[2][3]*n[1] ) ;//NV_DOT( S[3][2] , n );	

													big = -1.0;

													for( rr = 1; rr <= 2; rr++)
														for( cc = 1; cc <= 3; cc++)
														{
															if (dot_prod[rr][cc] > big)
															{
																big = dot_prod[rr][cc]  ;
																n_row = rr;
																n_col = cc;
						
																if(big != 0)
																{
														//			Message( " big, rr, cc = %g %d %d \n ", big, rr, cc);
																}

																if(rr == 1 && cc == 1)
																{
																	cs = cl;
																	ts = tl;
																}
																else if(rr == 1 && cc == 2)
																{
																	cs = c;
																	ts = t;
																}
																else if(rr == 1 && cc == 3)
																{
																	cs = cr;
																	ts = tr;
																}
																else if(rr == 2 && cc == 1)
																{
																	cs = cla;
																	ts = tla;
																}
																else if(rr == 2 && cc == 2)
																{
																	cs = ca;
																	ts = ta;
																}
																else if(rr == 2 && cc == 3)
																{
																	cs = cra;
																	ts = tra;
																}

															}
															else
															{
																big = big ;
																n_row = n_row;
																n_col = n_col;
																cs = cs;
																ts = ts;
										
															}
														}
													Message(" T.B n_row, n_col = %d %d \n ", n_row, n_col );
												}	
										//		else
										//		{
										//			return 0.0;
										//		}

												
										}
										else								// PLEASE NOTE : THIS WILL REMAIN SAME FOR ALL GEOMETRIES. This part is for interior cells other than cells at boundaries.
										{		
														C_CENTROID(X,c,t);
														C_CENTROID(Xr,cr,tr);
														C_CENTROID(Xf,cf,tf);
														C_CENTROID(Xl,cl,tl);		 
														C_CENTROID(Xa,ca,ta);
														C_CENTROID(Xrf,crf,trf);		
														C_CENTROID(Xlf,clf,tlf);
														C_CENTROID(Xla,cla,tla);				
														C_CENTROID(Xra,cra,tra);

//														Message(" X (clf, cf, crf, cl, c, cr, cla, ca, cra) =  %.10f %.10f %.10f \n %.10f %.10f %.10f \n %.10f %.10f %.10f \n ", Xlf[0], Xf[0], Xrf[0], Xl[0], X[0], Xr[0], Xla[0], Xa[0], Xra[0]);
//														Message(" Y (clf, cf, crf, cl, c, cr, cla, ca, cra) =  %.10f %.10f %.10f \n %.10f %.10f %.10f \n %.10f %.10f %.10f \n ", Xlf[1], Xf[1], Xrf[1], Xl[1], X[1], Xr[1], Xla[1], Xa[1], Xra[1]);
//														Message(" xi, yi = %.10f %.10f \n ", xi, yi );
//														Message(" iphase = \n %f %f %f \n %f %f %f \n %f %f %f \n ", C_UDMI(clf,tlf,1),C_UDMI(cf,tf,1),C_UDMI(crf,trf,1),C_UDMI(cl,tl,1),C_UDMI(c,t,1),C_UDMI(cr,tr,1),C_UDMI(cla,tla,1),C_UDMI(ca,ta,1),C_UDMI(cra,tra,1));

														SX[1][1] = (Xlf[0] - xi);
														SX[1][2] = (Xf[0]  - xi);
														SX[1][3] = (Xrf[0] - xi);
														SX[2][1] = (Xl[0]  - xi);
														SX[2][2] = 0.0 ; // (X[0] -xi); // 0.0;
														SX[2][3] = (Xr[0]  - xi);
														SX[3][1] = (Xla[0] - xi);
														SX[3][2] = (Xa[0]  - xi);
														SX[3][3] = (Xra[0] - xi);

//														Message(" SX Matrix = \n %g %g %g \n %g %g %g \n %g %g %g \n ", SX[1][1],SX[1][2],SX[1][3],SX[2][1],SX[2][2],SX[2][3],SX[3][1],SX[3][2],SX[3][3]);

														SY[1][1] = (Xlf[1] - yi);
														SY[1][2] = (Xf[1]  - yi);
														SY[1][3] = (Xrf[1] - yi);
														SY[2][1] = (Xl[1]  - yi);
														SY[2][2] = 0.0; // (X[1] - yi); // 0.0;
														SY[2][3] = (Xr[1]  - yi);
														SY[3][1] = (Xla[1] - yi);
														SY[3][2] = (Xa[1]  - yi);
														SY[3][3] = (Xra[1] - yi);

//														Message(" SY Matrix = \n %g %g %g \n %g %g %g \n %g %g %g \n ", SY[1][1],SY[1][2],SY[1][3],SY[2][1],SY[2][2],SY[2][3],SY[3][1],SY[3][2],SY[3][3]);

													DS[1][1] = sqrt(SX[1][1]*SX[1][1] + SY[1][1]*SY[1][1]) ;
													DS[1][2] = sqrt(SX[1][2]*SX[1][2] + SY[1][2]*SY[1][2]) ;
													DS[1][3] = sqrt(SX[1][3]*SX[1][3] + SY[1][3]*SY[1][3]) ;
													DS[2][1] = sqrt(SX[2][1]*SX[2][1] + SY[2][1]*SY[2][1]) ;
													DS[2][2] = 0.0 ; // sqrt(SX[2][2]*SX[2][2] + SY[2][2]*SY[2][2]) ; 
													DS[2][3] = sqrt(SX[2][3]*SX[2][3] + SY[2][3]*SY[2][3]) ;
													DS[3][1] = sqrt(SX[3][1]*SX[3][1] + SY[3][1]*SY[3][1]) ;
													DS[3][2] = sqrt(SX[3][2]*SX[3][2] + SY[3][2]*SY[3][2]) ;
													DS[3][3] = sqrt(SX[3][3]*SX[3][3] + SY[3][3]*SY[3][3]) ;

													SX[1][1] /= DS[1][1];
													SX[1][2] /= DS[1][2];
													SX[1][3] /= DS[1][3];
													SX[2][1] /= DS[2][1];
													SX[2][2] = 0.0; 
													SX[2][3] /= DS[2][3];											
													SX[3][1] /= DS[3][1];
													SX[3][2] /= DS[3][2];
													SX[3][3] /= DS[3][3];												
	
													SY[1][1] /= DS[1][1];
													SY[1][2] /= DS[1][2];
													SY[1][3] /= DS[1][3];
													SY[2][1] /= DS[2][1];
													SY[2][2] = 0.0; 
													SY[2][3] /= DS[2][3];
													SY[3][1] /= DS[3][1];
													SY[3][2] /= DS[3][2];
													SY[3][3] /= DS[3][3];												

										

													dot_prod[1][1] = -( SX[1][1]*n[0] + SY[1][1]*n[1] ) ;//NV_DOT( S[1][1] , n );
													dot_prod[1][2] = -( SX[1][2]*n[0] + SY[1][2]*n[1] ) ;//NV_DOT( S[1][2] , n );
													dot_prod[1][3] = -( SX[1][3]*n[0] + SY[1][3]*n[1] ) ;//NV_DOT( S[3][1] , n );
													dot_prod[2][1] = -( SX[2][1]*n[0] + SY[2][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[2][2] = 0.0; //-( SX[2][2]*n[0] + SY[2][2]*n[1] ) ;//NV_DOT( S[2][2] , n );
													dot_prod[2][3] = -( SX[2][3]*n[0] + SY[2][3]*n[1] ) ;//NV_DOT( S[3][2] , n );	
													dot_prod[3][1] = -( SX[3][1]*n[0] + SY[3][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[3][2] = -( SX[3][2]*n[0] + SY[3][2]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[3][3] = -( SX[3][3]*n[0] + SY[3][3]*n[1] ) ;//NV_DOT( S[2][1] , n );
		
//			Message(" c, C_UDMI(c,t,1), n[0], n[1], DOT PROD = %u %f %.15f %.15f \n %g %g %g \n %g %g %g \n %g %g %g \n ", c, C_UDMI(c,t,1), n[0], n[1], dot_prod[1][1],dot_prod[1][2],dot_prod[1][3],dot_prod[2][1],dot_prod[2][2],dot_prod[2][3],dot_prod[3][1],dot_prod[3][2],dot_prod[3][3]);

	
													//	big = 0.0;
	
														big = -1.0;
	
														for( rr = 1; rr <= 3; rr++)
															for( cc = 1; cc <= 3; cc++)
															{
													//			Message("rr,cc= %d %d \n", rr, cc);

																if (dot_prod[rr][cc] > big)
																{
																	big = dot_prod[rr][cc] ;
																	n_row = rr;
																	n_col = cc;
						
																	if(big != 0.0)
																	{
															//			Message( " big, rr, cc = %g %d %d \n ", big, rr, cc);
																	}

																	if(rr == 1 && cc == 1)
																	{
																		cs = clf;
																		ts = tlf;
																	}
																	else if(rr == 1 && cc == 2)
																	{
																		cs = cf;
																		ts = tf;
																	}
																	else if(rr == 1 && cc == 3)
																	{
																		cs = crf;
																		ts = trf;
																	}
																	else if(rr == 2 && cc == 1)
																	{
																		cs = cl;
																		ts = tl;
																	}
																	else if(rr == 2 && cc == 2)
																	{
																		cs = c;
																		ts = t;
																	}
																	else if(rr == 2 && cc == 3)
																	{
																		cs = cr;
																		ts = tr;
																	}
																	else if(rr == 3 && cc == 1)
																	{
																		cs = cla;
																		ts = tla;
																	}
																	else if(rr == 3 && cc == 2)
																	{
																		cs = ca;
																		ts = ta;
																	}
																	else if(rr == 3 && cc == 3)
																	{
																		cs = cra;
																		ts = tra;
																	}
																}
																else
																{
																	big = big;
																	n_row = n_row;
																	n_col = n_col;
																	cs = cs;
																	ts = ts;

																}


															}
										//		Message(" c, n_row, n_col = %u %d %d \n ", c, n_row, n_col );

									}

//								Message(" c, n_row, n_col = %u %d %d \n ", c, n_row, n_col );

		if( n_row == 0 || n_col == 0 || n_row > 3 || n_col > 3 )
		{
			return  0.0;
		}
		else
		{
									sx = SX[n_row][n_col];
									sy = SY[n_row][n_col];
									ds = DS[n_row][n_col];	// sqrt(sx*sx + sy*sy); 
								//	sx = sx/ds;
								//	sy = sy/ds;

//			NV_D(s , = , SX[n_row][n_col] , SY[n_row][n_col] , 0.0 );

			kl = 0.5454;
			kg = 0.5383;
			keff = kl*C_VOF(c,t_liquid) + kg*C_VOF(c,t_vapour);

			latent_heat = 276400.0;

//			ds = NV_MAG(s);
			


			if ( fequal(ds , 0.0) )
			{
				source = 0.0;
			}
			else
			{
//				NV_VS(q_s, = , s , * , (kl*(TSAT - C_T(cs,ts))/ds) );

//				q_n = NV_DOT(q_s , n);
//			C_CENTROID(XCS, cs, ts);
//			C_CENTROID(XC,c,t);
//			Message(" c, cs, C_UDMI(cs,ts,1) , C_UDMI(c,t,1) = %u %u %f %f \n ", c, cs, C_UDMI(cs,t,1) , C_UDMI(c,t,1) );
				q_n = sx*(keff*(TSAT - C_T(cs,t))/ds)*nx + sy*(keff*(TSAT - C_T(cs,t))/ds)*ny ; 
				source = fabs(q_n / latent_heat ) ; 
				
//			Message("c, ds, C_T(cs,t), source  = %u %f %f %g \n ", c, ds, C_T(cs,t), source );
	//			C_UDMI(c,t,6) = source;
			}														
	//		Message(" c, source = %u %g  \n ", c, source );
	//		Message("last = %f %f %g %g %g %.20f \n ", SX[n_row][n_col], SY[n_row][n_col] , q_n, ((kl*(TSAT - C_T(cs,ts))/ds)/latent_heat) , ds , source );
			return    source;		
		}
		
			
	
	}
	else
	{
		return 0.0;
	}
}



DEFINE_SOURCE(liquid_mass_source, c, t_liquid, dS, eqn)
{
	Thread *t = THREAD_SUPER_THREAD(t_liquid);
	Thread *t_vapour = THREAD_SUB_THREAD(t,1);
	cell_t cs; 
	Thread *ts;
	
	/* =============== DECLARATION OF NEIGHBOURING CELL ID'S AND THREAD'S ================= */
	cell_t cr, cf, cl, ca, crf, cra, clf, cla ;
	Thread *tf, *ta, *tr, *tl, *trf, *tra, *tlf, *tla ;

	face_t fr,ff,fl,fa,ffr,far,ffl,fal,frp,flp,frm,flm;
	Thread *tfr, *tff, *tfl, *tfa, *tffr, *tfar, *tffl, *tfal, *tfrp, *tflp, *tfrm, *tflm;

	face_t f;
	Thread *t_f;
	Thread *t_fr, *t_ff, *t_fl, *t_fa;
	Node *node;
	int a;
	/* ------------------------------------------------------------------------------------ */
	cell_t CELL[3][3];
	Thread *THREAD[3][3];
	float NV_VEC(S11), NV_VEC(S12), NV_VEC(S13), NV_VEC(S21), NV_VEC(S22), NV_VEC(S23), NV_VEC(S31), NV_VEC(S32), NV_VEC(S33);
	
	float SX[3][3], SY[3][3], DS[3][3];

	float source;

	float NV_VEC(n), NV_VEC(s), NV_VEC(sr), NV_VEC(sf), NV_VEC(sl), NV_VEC(sa), NV_VEC(srf), NV_VEC(slf), NV_VEC(sla), NV_VEC(sra), sx , sy ;
	real  xl , xr , ya , yf; 
	float XR[ND_ND], XF[ND_ND], XL[ND_ND], XA[ND_ND] , xi , yi , xis , yis;
	real nx,ny,xint1, xint2 , yint1, yint2;
	float X[ND_ND], Xr[ND_ND], Xf[ND_ND], Xl[ND_ND], Xa[ND_ND], Xrf[ND_ND], Xlf[ND_ND], Xla[ND_ND], Xra[ND_ND], XC[ND_ND], XCS[ND_ND];
	real xcf[ND_ND],xca[ND_ND], xcr[ND_ND], xcl[ND_ND] ;
	real *ptl, *ptr, *pta, *ptf ;
	real xci[ND_ND];
	int N;
	int iface_int1, iface_int2;
	int iphs;
	float NV_VEC(q_s), q_n , ds , kl , kg, keff, latent_heat;
	float XS[ND_ND];
	int ii,jj;
	int rr, cc, n_row, n_col ;
	float dot_prod[3][3] , S[3][3]  ;
	float big;
	real ax, ay, bx, by;
	FILE *fp;
	char name[50];

	real dx,dy;
	real len, voll ;
	real sourcl, sourcv, tempn;
	
	real distance;
	
	cxboolean check_r ;
	cxboolean check_f ;
	cxboolean check_l ;
	cxboolean check_a ;
	cxboolean boundary;

	check_r = FALSE;
	check_f = FALSE;
	check_l = FALSE;
	check_a = FALSE;
	
	iphs = C_UDMI(c,t,1); //iphase[c];
	n[0] = C_UDMI(c,t,2); //nx;
	n[1] = C_UDMI(c,t,3); //ny;	

//	

if (iphs == 2 )
{

	t_f = C_FACE_THREAD(c,t,0);

  		C_CENTROID(XC,c,t);
//	Message(" iphs, n[0], n[1] = %d %f %f \n ", iphs, n[0], n[1] );

	if(BOUNDARY_FACE_THREAD_P(t_f))
	{													


					// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to left boundary.)
					if( fequal(XC[0], 0.00001135) && (XC[1] > 0.00003405) && (XC[1] < 0.0022473)  )
					{
						ff = C_FACE(c,t,3);					
						tff = C_FACE_THREAD(c,t,3);
						fa = C_FACE(c,t,1);
						tfa = C_FACE_THREAD(c,t,1);
							fr = C_FACE(c,t,2);
							tfr = C_FACE_THREAD(c,t,2);	
							fl = C_FACE(c,t,0);
							tfl = C_FACE_THREAD(c,t,0);	
							
//=====================================================================================================================================
							F_CENTROID(XR,fr,tfr);
							F_CENTROID(XF,ff,tff);
							F_CENTROID(XL,fl,tfl);
							F_CENTROID(XA,fa,tfa);

							xr = XR[0] ;
							yf = XF[1] ;
							xl = XL[0] ;
							ya = XA[1] ;

						// ================ GTM FUNCTION CALL =================== 

							delta(c,t, &dx, &dy); 
							nx = C_UDMI(c,t,2);
							ny = C_UDMI(c,t,3);
	
							linseg(c, t_liquid, xl, xr, ya, yf, &xint1, &xint2, &yint1, &yint2, &iface_int1, &iface_int2);
							lgvol( c, t_liquid, xl, xr, ya, yf, &voll );

						// =============== DEFINITION OF N-VECTOR ================ 

				//			n[0]  =  nx; 
				//			n[1]  =  ny;

						// =============== MODIFIED DEFINITION OF S-VECTOR ================ 


						if(xint1 > xint2)
						{
							xi = xint2 + fabs((xint1 - xint2)/2.0) ;
						}
						else
						{
							xi = xint1 + fabs((xint1 - xint2)/2.0) ;
						}

						if(yint1 > yint2)
						{
							yi = yint2 + fabs((yint1 - yint2)/2.0) ;								
						}
						else
						{
							yi = yint1 + fabs((yint1 - yint2)/2.0) ;								
						}							

//============================================================================================================================================						


					// ----------- FRONT FACE ------------ 

						cf = F_C0(ff,tff);
						if(cf == c)
						{
							cf = F_C1(ff,tff);
							tf = F_C1_THREAD(ff,tff);
						}
						else
						{
							tf = F_C0_THREAD(ff,tff);
						}
						
						// ----------- RIGHT FACE ----------- 

							cr = F_C0(fr,tfr);
							if(cr == c)
							{
								cr = F_C1(fr,tfr);
								tr = F_C1_THREAD(fr,tfr);
							}
							else
							{
								tr = F_C0_THREAD(fr,tfr);
							}   

					// ------------ AFTER FACE ------------ 

						ca = F_C0(fa,tfa);
						if(ca == c)
						{
							ca = F_C1(fa,tfa);
							ta = F_C1_THREAD(fa,tfa);
						}
						else
						{
							ta = F_C0_THREAD(fa,tfa);
						}

						C_CENTROID(xcf,cf,tf);
						C_CENTROID(xca,ca,ta);

							if ( fequal( xcf[1], 0.00225865 ) )
							{
								return 0.0;							
							}
							else if ( fequal(xca[1],0.00001135) )
							{
								return 0.0;
							}
							else
							{
									frm = C_FACE(ca,ta,2);
									tfrm = C_FACE_THREAD(ca,ta,2);

									frp = C_FACE(cf,tf,2);
									tfrp = C_FACE_THREAD(cf,tf,2);
			
								// ======================== (crf,trf) ============================= 

									crf = F_C0(frp,tfrp);
									if(crf == cr)
									{
										crf = F_C1(frp,tfrp);
										trf = F_C1_THREAD(frp,tfrp);
									}
									else
									{
										trf = F_C0_THREAD(frp,tfrp);
									}


								// ======================== (cra,tra) ============================= 

									cra = F_C0(frm,tfrm);
									if(cra == cr)
									{
										cra = F_C1(frm,tfrm);
										tra = F_C1_THREAD(frm,tfrm);
									}
									else
									{
										tra = F_C0_THREAD(frm,tfrm);
									}
							}
//			Message(" cf = %u \t crf = %u \n ", cf, crf);		
//			Message(" c  = %u \t cr  = %u \n ", c, cr   );	
//			Message(" ca = %u \t cra = %u \n ", ca, cra);

					}

					// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to right boundary.)
				    else if( fequal(XC[0], 0.00112365) && (XC[1] > 0.00003405) && (XC[1] < 0.0022473)  )
					{
						ff = C_FACE(c,t,1);					
						tff = C_FACE_THREAD(c,t,1);
						fa = C_FACE(c,t,3);
						tfa = C_FACE_THREAD(c,t,3);
						fl = C_FACE(c,t,2);
						tfl = C_FACE_THREAD(c,t,2);	
						fr = C_FACE(c,t,0);
						tfr = C_FACE_THREAD(c,t,0);	
					
			//			Message(" HI I am Right \n");

//=========================================================================================================================================
							F_CENTROID(XR,fr,tfr);
							F_CENTROID(XF,ff,tff);
							F_CENTROID(XL,fl,tfl);
							F_CENTROID(XA,fa,tfa);

							xr = XR[0] ;
							yf = XF[1] ;
							xl = XL[0] ;
							ya = XA[1] ;

						// ================ GTM FUNCTION CALL =================== 

							delta(c,t, &dx, &dy); 
							nx = C_UDMI(c,t,2);
							ny = C_UDMI(c,t,3);
	
							linseg(c, t_liquid, xl, xr, ya, yf, &xint1, &xint2, &yint1, &yint2, &iface_int1, &iface_int2);
							lgvol( c, t_liquid, xl, xr, ya, yf, &voll );

						// =============== DEFINITION OF N-VECTOR ================ 

				//			n[0]  =  nx; 
				//			n[1]  =  ny;

						// =============== MODIFIED DEFINITION OF S-VECTOR ================ 


						if(xint1 > xint2)
						{
							xi = xint2 + fabs((xint1 - xint2)/2.0) ;
						}
						else
						{
							xi = xint1 + fabs((xint1 - xint2)/2.0) ;
						}

						if(yint1 > yint2)
						{
							yi = yint2 + fabs((yint1 - yint2)/2.0) ;								
						}
						else
						{
							yi = yint1 + fabs((yint1 - yint2)/2.0) ;								
						}			

//============================================================================================================================================

							// ----------- FRONT FACE ------------ 

								cf = F_C0(ff,tff);
								if(cf == c)
								{
									cf = F_C1(ff,tff);
									tf = F_C1_THREAD(ff,tff);
								}
								else
								{
									tf = F_C0_THREAD(ff,tff);
								}

					// ----------- LEFT FACE ------------ 

							cl = F_C0(fl,tfl);
							if(cl == c)
							{
								cl = F_C1(fl,tfl);
								tl = F_C1_THREAD(fl,tfl);
							}
							else
							{
								tl = F_C0_THREAD(fl,tfl);
							}


							// ------------ AFTER FACE ------------ 

								ca = F_C0(fa,tfa);
								if(ca == c)
								{
									ca = F_C1(fa,tfa);
									ta = F_C1_THREAD(fa,tfa);
								}
								else
								{
									ta = F_C0_THREAD(fa,tfa);
								}

						C_CENTROID(xcf,cf,tf);
						C_CENTROID(xca,ca,ta);

							if ( fequal( xcf[1], 0.00225865 ) )
							{
								return 0.0;			
							}
							else if ( fequal(xca[1],0.00001135) )
							{
								return 0.0;
							}
							else
							{
									flp = C_FACE(cf,tf,2);
									tflp = C_FACE_THREAD(cf,tf,2);

									flm = C_FACE(ca,ta,2);
									tflm = C_FACE_THREAD(ca,ta,2);


								// ======================== (crf,trf) ============================= 

									clf = F_C0(flp,tflp);
									if(clf == cl)
									{
										clf = F_C1(flp,tflp);
										tlf = F_C1_THREAD(flp,tflp);
									}
									else
									{
										tlf = F_C0_THREAD(flp,tflp);
									}


								// ======================== (cra,tra) ============================= 

									cla = F_C0(flm,tflm);
									if(cla == cl)
									{
										cla = F_C1(flm,tflm);
										tla = F_C1_THREAD(flm,tflm);
									}
									else
									{
										tla = F_C0_THREAD(flm,tflm);
									}
							}
//			Message(" clf = %u \t cf = %u \n ", clf, cf);		
//			Message(" cl = %u  \t c  = %u \n ", cl, c   );	
//			Message(" cla = %u \t ca = %u \n ", cla, ca);




					}

					// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to bottom boundary.)
					else if( fequal(XC[1], 0.00001135) && (XC[0] > 0.0000227) && (XC[0] < 0.00112365) )
					{
						ff = C_FACE(c,t,2);					
						tff = C_FACE_THREAD(c,t,2);
						fr = C_FACE(c,t,1);
						tfr = C_FACE_THREAD(c,t,1);			
						fl = C_FACE(c,t,3);
						tfl = C_FACE_THREAD(c,t,3);
						fa = C_FACE(c,t,0);
						tfa = C_FACE_THREAD(c,t,0);


//=========================================================================================================================================
						F_CENTROID(XR,fr,tfr);
						F_CENTROID(XF,ff,tff);
						F_CENTROID(XL,fl,tfl);
						F_CENTROID(XA,fa,tfa);

						xr = XR[0] ;
						yf = XF[1] ;
						xl = XL[0] ;
						ya = XA[1] ;

					// ================ GTM FUNCTION CALL =================== 

						delta(c,t, &dx, &dy); 
						nx = C_UDMI(c,t,2);
						ny = C_UDMI(c,t,3);
	
						linseg(c, t_liquid, xl, xr, ya, yf, &xint1, &xint2, &yint1, &yint2, &iface_int1, &iface_int2);
						lgvol( c, t_liquid, xl, xr, ya, yf, &voll );

					// =============== DEFINITION OF N-VECTOR ================ 

			//				n[0]  =  nx; 
			//				n[1]  =  ny;

					// =============== MODIFIED DEFINITION OF S-VECTOR ================ 


						if(xint1 > xint2)
						{
							xi = xint2 + fabs((xint1 - xint2)/2.0) ;
						}
						else
						{
							xi = xint1 + fabs((xint1 - xint2)/2.0) ;
						}

						if(yint1 > yint2)
						{
							yi = yint2 + fabs((yint1 - yint2)/2.0) ;								
						}
						else
						{
							yi = yint1 + fabs((yint1 - yint2)/2.0) ;								
						}			

//============================================================================================================================================


						// ----------- RIGHT FACE ----------- 

							cr = F_C0(fr,tfr);
							if(cr == c)
							{
								cr = F_C1(fr,tfr);
								tr = F_C1_THREAD(fr,tfr);
							}
							else
							{
								tr = F_C0_THREAD(fr,tfr);
							}   

						// ----------- LEFT FACE ------------ =

							cl = F_C0(fl,tfl);
							if(cl == c)
							{
								cl = F_C1(fl,tfl);
								tl = F_C1_THREAD(fl,tfl);
							}
							else
							{
								tl = F_C0_THREAD(fl,tfl);
							}

						// ----------- FRONT FACE ------------ =

							cf = F_C0(ff,tff);
							if(cf == c)
							{
								cf = F_C1(ff,tff);
								tf = F_C1_THREAD(ff,tff);
							}
							else
							{
								tf = F_C0_THREAD(ff,tff);
							}

						c_face_loop(cr,tr,N)
						{
							t_fr = C_FACE_THREAD(cr,tr,N);
							if( BOUNDARY_FACE_THREAD_P(t_fr) )
							{
								check_r = TRUE;
							}
						}

					C_CENTROID(xcr, cr, tr);
					C_CENTROID(xcl, cl, tl);

							if (fequal(xcr[0], 0.00112365) )
							{
								return 0.0 ;

							}
							else if(fequal(xcl[0], 0.000011365) )
							{
								return 0.0 ;
							}
							else
							{

									ffr = C_FACE(cr,tr,2);
									tffr = C_FACE_THREAD(cr,tr,2);

									ffl = C_FACE(cl,tl,2);
									tffl = C_FACE_THREAD(cl,tl,2);

								// ======================== (crf,trf) ============================= 

									crf = F_C0(ffr,tffr);
									if(crf == cr)
									{
										crf = F_C1(ffr,tffr);
										trf = F_C1_THREAD(ffr,tffr);
									}
									else
									{
										trf = F_C0_THREAD(ffr,tffr);
									}
						//			Message(" crf = %u \n ", crf);

								// ======================== (clf,tlf) ============================= 

									clf = F_C0(ffl,tffl);
									if(clf == cl)
									{
										clf = F_C1(ffl,tffl);
										tlf = F_C1_THREAD(ffl,tffl);
									}
									else
									{
										tlf = F_C0_THREAD(ffl,tffl);
									}
						//			Message(" clf = %u \n ", clf);
							
							}

//								Message(" clf = %u \t cf = %u \t crf = %u \n ", clf, cf, crf);		
//								Message(" cl = %u  \t c  = %u \t cr  = %u \n ", cl, c, cr   );									

					}
					
					// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to top boundary.)
					else if( fequal(XC[1], 0.00225865) && (XC[0] > 0.0000227) && (XC[0] < 0.00112365) )
					{
						fa = C_FACE(c,t,2);
						tfa = C_FACE_THREAD(c,t,2);
						fr = C_FACE(c,t,3);
						tfr = C_FACE_THREAD(c,t,3);			
						fl = C_FACE(c,t,1);
						tfl = C_FACE_THREAD(c,t,1);
						ff = C_FACE(c,t,0);
						tff = C_FACE_THREAD(c,t,0);

	//					Message(" HI I am TOP \n");
					
//=========================================================================================================================================
						F_CENTROID(XR,fr,tfr);
						F_CENTROID(XF,ff,tff);
						F_CENTROID(XL,fl,tfl);
						F_CENTROID(XA,fa,tfa);

						xr = XR[0] ;
						yf = XF[1] ;
						xl = XL[0] ;
						ya = XA[1] ;

					// ================ GTM FUNCTION CALL =================== 

						delta(c,t, &dx, &dy); 
						nx = C_UDMI(c,t,2);
						ny = C_UDMI(c,t,3);
	
						linseg(c, t_liquid, xl, xr, ya, yf, &xint1, &xint2, &yint1, &yint2, &iface_int1, &iface_int2);
						lgvol( c, t_liquid, xl, xr, ya, yf, &voll );

					// =============== DEFINITION OF N-VECTOR ================ 

			//				n[0]  =  nx; 
			//				n[1]  =  ny;

					// =============== MODIFIED DEFINITION OF S-VECTOR ================ 


						if(xint1 > xint2)
						{
							xi = xint2 + fabs((xint1 - xint2)/2.0) ;
						}
						else
						{
							xi = xint1 + fabs((xint1 - xint2)/2.0) ;
						}

						if(yint1 > yint2)
						{
							yi = yint2 + fabs((yint1 - yint2)/2.0) ;								
						}
						else
						{
							yi = yint1 + fabs((yint1 - yint2)/2.0) ;								
						}			

//============================================================================================================================================

						// ----------- RIGHT FACE ----------- 

							cr = F_C0(fr,tfr);
							if(cr == c)
							{
								cr = F_C1(fr,tfr);
								tr = F_C1_THREAD(fr,tfr);
							}
							else
							{
								tr = F_C0_THREAD(fr,tfr);
							}   

						// ----------- LEFT FACE ------------ 

							cl = F_C0(fl,tfl);
							if(cl == c)
							{
								cl = F_C1(fl,tfl);
								tl = F_C1_THREAD(fl,tfl);
							}
							else
							{
								tl = F_C0_THREAD(fl,tfl);
							}

						// ----------- AFTER FACE ------------ 

							ca = F_C0(fa,tfa);
							if(ca == c)
							{
								ca = F_C1(fa,tfa);
								ta = F_C1_THREAD(fa,tfa);
							}
							else
							{
								ta = F_C0_THREAD(fa,tfa);
							}



							C_CENTROID(xcr,cr,tr);
							C_CENTROID(xcl,cl,tl);

							if (fequal(xcr[0] , 0.00112365))
							{
								return 0.0 ;
							}
							else if(fequal(xcl[0], 0.00001135))
							{
								return 0.0 ;
							}
							else
							{
									far = C_FACE(cr,tr,2);
									tfar = C_FACE_THREAD(cr,tr,2);

									fal = C_FACE(cl,tl,2);
									tfal = C_FACE_THREAD(cl,tl,2);

								// ======================== (cra,tra) ============================= 

									cra = F_C0(far,tfar);
									if(cra == cr)
									{
										cra = F_C1(far,tfar);
										tra = F_C1_THREAD(far,tfar);
									}
									else
									{
										tra = F_C0_THREAD(far,tfar);
									}
						//			Message(" crf = %u \n ", crf);

								// ======================== (cla,tla) ============================= 

									cla = F_C0(fal,tfal);
									if(cla == cl)
									{
										cla = F_C1(fal,tfal);
										tla = F_C1_THREAD(fal,tfal);
									}
									else
									{
										tla = F_C0_THREAD(fal,tfal);
									}
						//			Message(" clf = %u \n ", clf);

							}
//									Message(" cl = %u  \t c  = %u \t cr  = %u \n ", cl, c, cr   );
//									Message(" cla = %u \t ca = %u \t cra = %u \n ", cla, ca, cra);
					}				
					else
					{
						return 0.0;

						}
			
	}
	else
	{
	
		fr = C_FACE(c,t,1);
		tfr = C_FACE_THREAD(c,t,1);
		fl = C_FACE(c,t,3);					
		tfl = C_FACE_THREAD(c,t,3);			
		ff = C_FACE(c,t,2);					
		tff = C_FACE_THREAD(c,t,2);
		fa = C_FACE(c,t,0);
		tfa = C_FACE_THREAD(c,t,0);
	



	// ----------- RIGHT FACE ----------- =

		cr = F_C0(fr,tfr);
		if(cr == c)
		{
			cr = F_C1(fr,tfr);
			tr = F_C1_THREAD(fr,tfr);
		}
		else
		{
			tr = F_C0_THREAD(fr,tfr);
		}   

	// ----------- LEFT FACE ------------ =

		cl = F_C0(fl,tfl);
		if(cl == c)
		{
			cl = F_C1(fl,tfl);
			tl = F_C1_THREAD(fl,tfl);
		}
		else
		{
			tl = F_C0_THREAD(fl,tfl);
		}

	// ----------- FRONT FACE ------------ =

		cf = F_C0(ff,tff);
		if(cf == c)
		{
			cf = F_C1(ff,tff);
			tf = F_C1_THREAD(ff,tff);
		}
		else
		{
			tf = F_C0_THREAD(ff,tff);
		}

	// ------------ AFTER FACE ------------ =

		ca = F_C0(fa,tfa);
		if(ca == c)
		{
			ca = F_C1(fa,tfa);
			ta = F_C1_THREAD(fa,tfa);
		}
		else
		{
			ta = F_C0_THREAD(fa,tfa);
		}
//	Message("      cf    = \t \t %u \t \t  \n ", cf );
//	Message(" cl , c, cr = %u \t %u \t %u \n ", cl, c, cr );
//	Message("      ca    = \t \t %u \t \t  \n ", ca );

//=========================================================================================================================================
						F_CENTROID(XR,fr,tfr);
						F_CENTROID(XF,ff,tff);
						F_CENTROID(XL,fl,tfl);
						F_CENTROID(XA,fa,tfa);

						xr = XR[0] ;
						yf = XF[1] ;
						xl = XL[0] ;
						ya = XA[1] ;

					// ================ GTM FUNCTION CALL =================== 

						delta(c,t, &dx, &dy); 
						nx = C_UDMI(c,t,2);
						ny = C_UDMI(c,t,3);
	
						linseg(c, t_liquid, xl, xr, ya, yf, &xint1, &xint2, &yint1, &yint2, &iface_int1, &iface_int2);
						lgvol( c, t_liquid, xl, xr, ya, yf, &voll );

					// =============== DEFINITION OF N-VECTOR ================ 

		//					n[0]  =  nx; 
		//					n[1]  =  ny;

					// =============== MODIFIED DEFINITION OF S-VECTOR ================ 


						if(xint1 > xint2)
						{
							xi = xint2 + fabs((xint1 - xint2)/2.0) ;
						}
						else
						{
							xi = xint1 + fabs((xint1 - xint2)/2.0) ;
						}

						if(yint1 > yint2)
						{
							yi = yint2 + fabs((yint1 - yint2)/2.0) ;								
						}
						else
						{
							yi = yint1 + fabs((yint1 - yint2)/2.0) ;								
						}			

//============================================================================================================================================


		c_face_loop(cr,tr,N)
		{
			t_fr = C_FACE_THREAD(cr,tr,N);
			if( BOUNDARY_FACE_THREAD_P(t_fr) )
			{
				check_r = TRUE;
			}
		}

		c_face_loop(cf,tf,N)
		{
			t_ff = C_FACE_THREAD(cf,tf,N);
			if( BOUNDARY_FACE_THREAD_P(t_ff) )
			{
				check_f = TRUE;
			}
		}

		c_face_loop(cl,tl,N)
		{
			t_fl = C_FACE_THREAD(cl,tl,N);
			if( BOUNDARY_FACE_THREAD_P(t_fl) )
			{
				check_l = TRUE;
			}
		}

		c_face_loop(ca,ta,N)
		{
			t_fa = C_FACE_THREAD(ca,ta,N);
			if( BOUNDARY_FACE_THREAD_P(t_fa) )
			{
				check_a = TRUE;
			}
		}				

		if( check_r )
		{
//			Message(" BOUNDARY CELL ENCOUNTERED \n ");
			

				ffr = C_FACE(cr,tr,1);
				tffr = C_FACE_THREAD(cr,tr,1);

				far = C_FACE(cr,tr,3);
				tfar = C_FACE_THREAD(cr,tr,3);

				ffl = C_FACE(cl,tl,2);
				tffl = C_FACE_THREAD(cl,tl,2);

				fal = C_FACE(cl,tl,0);
				tfal = C_FACE_THREAD(cl,tl,0);

			// ======================== (crf,trf) ============================= =

				crf = F_C0(ffr,tffr);
				if(crf == cr)
				{
					crf = F_C1(ffr,tffr);
					trf = F_C1_THREAD(ffr,tffr);
				}
				else
				{
					trf = F_C0_THREAD(ffr,tffr);
				}
	//			Message(" crf = %u \n ", crf);
			// ======================== (cra,tra) ============================= =

				cra = F_C0(far,tfar);
				if(cra == cr)
				{
					cra = F_C1(far,tfar);
					tra = F_C1_THREAD(far,tfar);
				}
				else
				{
					tra = F_C0_THREAD(far,tfar);
				}
	//			Message(" cra = %u \n ", cra);	
			// ======================== (clf,tlf) ============================= =

				clf = F_C0(ffl,tffl);
				if(clf == cl)
				{
					clf = F_C1(ffl,tffl);
					tlf = F_C1_THREAD(ffl,tffl);
				}
				else
				{
					tlf = F_C0_THREAD(ffl,tffl);
				}
	//			Message(" clf = %u \n ", clf);
			// ======================== (cla,tla) ============================= =

				cla = F_C0(fal,tfal);
				if(cla == cl)
				{
					cla = F_C1(fal,tfal);
					tla = F_C1_THREAD(fal,tfal);
				}
				else
				{
					tla = F_C0_THREAD(fal,tfal);
				}
	//			Message(" cla = %u \n ", cla);
		
		}
		else if ( check_f )
		{
			
				frp = C_FACE(cf,tf,3);
				tfrp = C_FACE_THREAD(cf,tf,3);

				flp = C_FACE(cf,tf,1);
				tflp = C_FACE_THREAD(cf,tf,1);

				frm = C_FACE(ca,ta,1);
				tfrm = C_FACE_THREAD(ca,ta,1);

				flm = C_FACE(ca,ta,3);
				tflm = C_FACE_THREAD(ca,ta,3);

			// ======================== (crf,trf) ============================= =

				crf = F_C0(frp,tfrp);
				if(crf == cr)
				{
					crf = F_C1(frp,tfrp);
					trf = F_C1_THREAD(frp,tfrp);
				}
				else
				{
					trf = F_C0_THREAD(frp,tfrp);
				}

			// ======================== (clf,tlf) ============================= =

				clf = F_C0(flp,tflp);
				if(clf == cl)
				{
					clf = F_C1(flp,tflp);
					tlf = F_C1_THREAD(flp,tflp);
				}
				else
				{
					tlf = F_C0_THREAD(flp,tflp);
				}

			// ======================== (cra,tra) ============================= =

				cra = F_C0(frm,tfrm);
				if(cra == cr)
				{
					cra = F_C1(frm,tfrm);
					tra = F_C1_THREAD(frm,tfrm);
				}
				else
				{
					tra = F_C0_THREAD(frm,tfrm);
				}

			// ======================== (cla,tla) ============================= =

				cla = F_C0(flm,tflm);
				if(cla == cl)
				{
					cla = F_C1(flm,tflm);
					tla = F_C1_THREAD(flm,tflm);
				}
				else
				{
					tla = F_C0_THREAD(flm,tflm);
				}
			
		}
		else if ( check_l ) 
		{
			
				ffl = C_FACE(cl,tl,3);
				tffl = C_FACE_THREAD(cl,tl,3);

				fal = C_FACE(cl,tl,1);
				tfal = C_FACE_THREAD(cl,tl,1);

				ffr = C_FACE(cr,tr,2);
				tffr = C_FACE_THREAD(cr,tr,2);

				far = C_FACE(cr,tr,0);
				tfar = C_FACE_THREAD(cr,tr,0);

			// ======================== (crf,trf) ============================= =

				crf = F_C0(ffr,tffr);
				if(crf == cr)
				{
					crf = F_C1(ffr,tffr);
					trf = F_C1_THREAD(ffr,tffr);
				}
				else
				{
					trf = F_C0_THREAD(ffr,tffr);
				}
	//			Message(" crf = %u \n ", crf);
			// ======================== (cra,tra) ============================= =

				cra = F_C0(far,tfar);
				if(cra == cr)
				{
					cra = F_C1(far,tfar);
					tra = F_C1_THREAD(far,tfar);
				}
				else
				{
					tra = F_C0_THREAD(far,tfar);
				}
	//			Message(" cra = %u \n ", cra);	
			// ======================== (clf,tlf) ============================= =

				clf = F_C0(ffl,tffl);
				if(clf == cl)
				{
					clf = F_C1(ffl,tffl);
					tlf = F_C1_THREAD(ffl,tffl);
				}
				else
				{
					tlf = F_C0_THREAD(ffl,tffl);
				}
	//			Message(" clf = %u \n ", clf);
			// ======================== (cla,tla) ============================= =

				cla = F_C0(fal,tfal);
				if(cla == cl)
				{
					cla = F_C1(fal,tfal);
					tla = F_C1_THREAD(fal,tfal);
				}
				else
				{
					tla = F_C0_THREAD(fal,tfal);
				}
	//			Message(" cla = %u \n ", cla);
		
			
		}
		else if ( check_a )
		{
			
				frm = C_FACE(ca,ta,1);
				tfrm = C_FACE_THREAD(ca,ta,1);

				flm = C_FACE(ca,ta,3);
				tflm = C_FACE_THREAD(ca,ta,3);

				frp = C_FACE(cf,tf,1);
				tfrp = C_FACE_THREAD(cf,tf,1);

				flp = C_FACE(cf,tf,3);
				tflp = C_FACE_THREAD(cf,tf,3);
			
			// ======================== (crf,trf) ============================= =

				crf = F_C0(frp,tfrp);
				if(crf == cr)
				{
					crf = F_C1(frp,tfrp);
					trf = F_C1_THREAD(frp,tfrp);
				}
				else
				{
					trf = F_C0_THREAD(frp,tfrp);
				}

			// ======================== (clf,tlf) ============================= =
				clf = F_C0(flp,tflp);
				if(clf == cl)
				{
					clf = F_C1(flp,tflp);
					tlf = F_C1_THREAD(flp,tflp);
				}
				else
				{
					tlf = F_C0_THREAD(flp,tflp);
				}

			// ======================== (cra,tra) ============================= =

				cra = F_C0(frm,tfrm);
				if(cra == cr)
				{
					cra = F_C1(frm,tfrm);
					tra = F_C1_THREAD(frm,tfrm);
				}
				else
				{
					tra = F_C0_THREAD(frm,tfrm);
				}

			// ======================== (cla,tla) ============================= =

				cla = F_C0(flm,tflm);
				if(cla == cl)
				{
					cla = F_C1(flm,tflm);
					tla = F_C1_THREAD(flm,tflm);
				}
				else
				{
					tla = F_C0_THREAD(flm,tflm);
				}
		}
		else
		{
		// ============== DEFINITION OF SECONDARY NEIGHBOURS ============== =

 
			ffr = C_FACE(cr,tr,2);
			tffr = C_FACE_THREAD(cr,tr,2);

			far = C_FACE(cr,tr,0);
			tfar = C_FACE_THREAD(cr,tr,0);

			ffl = C_FACE(cl,tl,2);
			tffl = C_FACE_THREAD(cl,tl,2);

			fal = C_FACE(cl,tl,0);
			tfal = C_FACE_THREAD(cl,tl,0);

//		Message("  far, tfar, ffl, tffl, fal, tfal =  %u %u %u %u %u %u  \n ", far, tfar, ffl, tffl, fal, tfal); 



		// ======================== (crf,trf) ============================= =

			crf = F_C0(ffr,tffr);
			if(crf == cr)
			{
				crf = F_C1(ffr,tffr);
				trf = F_C1_THREAD(ffr,tffr);
			}
			else
			{
				trf = F_C0_THREAD(ffr,tffr);
			}
//			Message(" crf = %u \n ", crf);
		// ======================== (cra,tra) ============================= =

		cra = F_C0(far,tfar);
			if(cra == cr)
			{
				cra = F_C1(far,tfar);
				tra = F_C1_THREAD(far,tfar);
			}
			else
			{
				tra = F_C0_THREAD(far,tfar);
			}
//			Message(" cra = %u \n ", cra);	
		// ======================== (clf,tlf) ============================= =

			clf = F_C0(ffl,tffl);
			if(clf == cl)
			{
				clf = F_C1(ffl,tffl);
				tlf = F_C1_THREAD(ffl,tffl);
			}
			else
			{
				tlf = F_C0_THREAD(ffl,tffl);
			}
//			Message(" clf = %u \n ", clf);
		// ======================== (cla,tla) ============================= =

			cla = F_C0(fal,tfal);
			if(cla == cl)
			{
				cla = F_C1(fal,tfal);
				tla = F_C1_THREAD(fal,tfal);
			}
			else
			{
				tla = F_C0_THREAD(fal,tfal);
			}
//			Message(" cla = %u \n ", cla);
			
			}

//	Message(" clf = %u \t cf = %u \t crf = %u \n ", clf, cf, crf);		
//	Message(" cl = %u  \t c  = %u \t cr  = %u \n ", cl, c, cr   );	
//	Message(" cla = %u \t ca = %u \t cra = %u \n ", cla, ca, cra);
//	Message(" tlf = %u \t tf = %u \t trf = %u \n ", tlf, tf, trf);		
//	Message(" tl = %u  \t t  = %u \t tr  = %u \n ", tl, t, tr   );	
//	Message(" tla = %u \t ta = %u \t tra = %u \n ", tla, ta, tra);
					

		}
			

		


	
			//	Message(" X[ND_ND] , Xr[ND_ND] = \n %g %g \n %g %g \n ", xi, X[1], Xr[0], Xr[1]);

		

										t_f = C_FACE_THREAD(c,t,0);

  										C_CENTROID(XC,c,t);
	

										if(BOUNDARY_FACE_THREAD_P(t_f))
										{


											    if( fequal(XC[0], 0.00001135) && (XC[1] > 0.00003405) && (XC[1] < 0.0022473)  )			// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to left boundary.)
												{
													C_CENTROID(X,c,t);
													C_CENTROID(Xr,cr,tr);
													C_CENTROID(Xf,cf,tf);
													C_CENTROID(Xa,ca,ta);
													C_CENTROID(Xrf,crf,trf);		
													C_CENTROID(Xra,cra,tra);

													NV_D(S11 , = , (Xf[0] - xi) , (Xf[1] - yi) , 0.0 );
													NV_D(S12 , = , (Xrf[0]  - xi) , (Xrf[1]  - yi) , 0.0 );
													NV_D(S21 , = , (X[0]  - xi) , (X[1]  - yi) , 0.0 );
													NV_D(S22 , = , (Xr[0]   - xi) , (Xr[1]   - yi) , 0.0 );
													NV_D(S31 , = , (Xa[0] - xi) , (Xa[1] - yi) , 0.0 );
													NV_D(S32 , = , (Xra[0]  - xi) , (Xra[1]  - yi) , 0.0 );
		
													SX[1][1] = (Xf[0] - xi);
													SX[1][2] = (Xrf[0]  - xi);
													SX[2][1] = (X[0]  - xi);
													SX[2][2] = (Xr[0]   - xi);
													SX[3][1] = (Xa[0] - xi);
													SX[3][2] = (Xra[0]  - xi);
	
													SY[1][1] = (Xf[1] - yi);
													SY[1][2] = (Xrf[1]  - yi);
													SY[2][1] = (X[1]  - yi);
													SY[2][2] = (Xr[1]   - yi);
													SY[3][1] = (Xa[1] - yi);
													SY[3][2] = (Xra[1]  - yi);

													DS[1][1] = sqrt(SX[1][1]*SX[1][1] + SY[1][1]*SY[1][1]) ;
													DS[1][2] = sqrt(SX[1][2]*SX[1][2] + SY[1][2]*SY[1][2]) ;
												//	DS[1][3] = sqrt(SX[1][3]*SX[1][3] + SY[1][3]*SY[1][3]) ;
													DS[2][1] = sqrt(SX[2][1]*SX[2][1] + SY[2][1]*SY[2][1]) ;
													DS[2][2] = sqrt(SX[2][2]*SX[2][2] + SY[2][2]*SY[2][2]) ;
												//	DS[2][3] = sqrt(SX[2][3]*SX[2][3] + SY[2][3]*SY[2][3]) ;
													DS[3][1] = sqrt(SX[3][1]*SX[3][1] + SY[3][1]*SY[3][1]) ;
													DS[3][2] = sqrt(SX[3][2]*SX[3][2] + SY[3][2]*SY[3][2]) ;
												//	DS[3][3] = sqrt(SX[3][3]*SX[3][3] + SY[3][3]*SY[3][3]) ;

													SX[1][1] /= DS[1][1];
													SX[1][2] /= DS[1][2];
													SX[2][1] /= DS[2][1];
													SX[2][2] /= DS[2][2];
													SX[3][1] /= DS[3][1];
													SX[3][2] /= DS[3][2];
	
													SY[1][1] /= DS[1][1];
													SY[1][2] /= DS[1][2];
													SY[2][1] /= DS[2][1];
													SY[2][2] /= DS[2][2];
													SY[3][1] /= DS[3][1];
													SY[3][2] /= DS[3][2];

													dot_prod[1][1] = -( SX[1][1]*n[0] + SY[1][1]*n[1] ) ;//NV_DOT( S[1][1] , n );
													dot_prod[1][2] = -( SX[1][2]*n[0] + SY[1][2]*n[1] ) ;//NV_DOT( S[1][2] , n );
													dot_prod[2][1] = -( SX[2][1]*n[0] + SY[2][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[2][2] = -( SX[2][2]*n[0] + SY[2][2]*n[1] ) ;//NV_DOT( S[2][2] , n );
													dot_prod[3][1] = -( SX[3][1]*n[0] + SY[3][1]*n[1] ) ;//NV_DOT( S[3][1] , n );
													dot_prod[3][2] = -( SX[3][2]*n[0] + SY[3][2]*n[1] ) ;//NV_DOT( S[3][2] , n );

													big = -1.0;
																for( rr = 1; rr <= 3; rr++)
																	for( cc = 1; cc <= 2; cc++)
																	{
																		if (dot_prod[rr][cc] > dot_prod[rr + 1][cc + 1])
																		{
																			big = dot_prod[rr][cc] *100000.0 ;
																			n_row = rr;
																			n_col = cc;
						
																			if(big != 0)
																			{
																	//			Message( " big, rr, cc = %g %d %d \n ", big, rr, cc);
																			}

																			if(rr == 1 && cc == 1)
																			{
																				cs = cf;
																				ts = tf;
																			}
																			else if(rr == 1 && cc == 2)
																			{
																				cs = crf;
																				ts = trf;
																			}
																			else if(rr == 2 && cc == 1)
																			{
																				cs = c;
																				ts = t;
																			}
																			else if(rr == 2 && cc == 2)
																			{
																				cs = cr;
																				ts = tr;
																			}
																			else if(rr == 3 && cc == 1)
																			{
																				cs = ca;
																				ts = ta;
																			}
																			else if(rr == 3 && cc == 2)
																			{
																				cs = cra;
																				ts = tra;
																			}

																		}
																		else
																		{
																			big = big;
																			n_row = n_row ;
																			n_col = n_col ;
																			cs = cs;
																			ts = ts;


																		}
																	}
														Message(" LHS n_row, n_col = %d %d \n ", n_row, n_col );
												}
												else if( fequal(XC[0], 0.00112365) && (XC[1] > 0.00003405) && (XC[1] < 0.0022473)  )			// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to right boundary.)
												{
													C_CENTROID(X,c,t);
													C_CENTROID(Xf,cf,tf);
													C_CENTROID(Xl,cl,tl);		 
													C_CENTROID(Xa,ca,ta);
													C_CENTROID(Xlf,clf,tlf);
													C_CENTROID(Xla,cla,tla);		

													SX[1][1] = (X[0] - xi);
													SX[1][2] = (Xf[0]  - xi);
													SX[2][1] = (Xl[0]  - xi);
													SX[2][2] = (Xa[0]   - xi);
													SX[3][1] = (Xlf[0] - xi);
													SX[3][2] = (Xla[0]  - xi);
	
													SY[1][1] = (X[1] - yi);
													SY[1][2] = (Xf[1]  - yi);
													SY[2][1] = (Xl[1]  - yi);
													SY[2][2] = (Xa[1]   - yi);
													SY[3][1] = (Xlf[1] - yi);
													SY[3][2] = (Xla[1]  - yi);

													DS[1][1] = sqrt(SX[1][1]*SX[1][1] + SY[1][1]*SY[1][1]) ;
													DS[1][2] = sqrt(SX[1][2]*SX[1][2] + SY[1][2]*SY[1][2]) ;
												//	DS[1][3] = sqrt(SX[1][3]*SX[1][3] + SY[1][3]*SY[1][3]) ;
													DS[2][1] = sqrt(SX[2][1]*SX[2][1] + SY[2][1]*SY[2][1]) ;
													DS[2][2] = sqrt(SX[2][2]*SX[2][2] + SY[2][2]*SY[2][2]) ;
												//	DS[2][3] = sqrt(SX[2][3]*SX[2][3] + SY[2][3]*SY[2][3]) ;
													DS[3][1] = sqrt(SX[3][1]*SX[3][1] + SY[3][1]*SY[3][1]) ;
													DS[3][2] = sqrt(SX[3][2]*SX[3][2] + SY[3][2]*SY[3][2]) ;
												//	DS[3][3] = sqrt(SX[3][3]*SX[3][3] + SY[3][3]*SY[3][3]) ;

													SX[1][1] /= DS[1][1];
													SX[1][2] /= DS[1][2];
													SX[2][1] /= DS[2][1];
													SX[2][2] /= DS[2][2];
													SX[3][1] /= DS[3][1];
													SX[3][2] /= DS[3][2];
	
													SY[1][1] /= DS[1][1];
													SY[1][2] /= DS[1][2];
													SY[2][1] /= DS[2][1];
													SY[2][2] /= DS[2][2];
													SY[3][1] /= DS[3][1];
													SY[3][2] /= DS[3][2];

													dot_prod[1][1] = -( SX[1][1]*n[0] + SY[1][1]*n[1] ) ;//NV_DOT( S[1][1] , n );
													dot_prod[1][2] = -( SX[1][2]*n[0] + SY[1][2]*n[1] ) ;//NV_DOT( S[1][2] , n );
													dot_prod[2][1] = -( SX[2][1]*n[0] + SY[2][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[2][2] = -( SX[2][2]*n[0] + SY[2][2]*n[1] ) ;//NV_DOT( S[2][2] , n );
													dot_prod[3][1] = -( SX[3][1]*n[0] + SY[3][1]*n[1] ) ;//NV_DOT( S[3][1] , n );
													dot_prod[3][2] = -( SX[3][2]*n[0] + SY[3][2]*n[1] ) ;//NV_DOT( S[3][2] , n );

													big = 0.0;

																for( rr = 1; rr <= 3; rr++)
																	for( cc = 1; cc <= 2; cc++)
																	{
																		if (dot_prod[rr][cc] > big )
																		{
																			big = dot_prod[rr][cc] ;
																			n_row = rr;
																			n_col = cc;
						
																			if(big != 0)
																			{
																	//			Message( " big, rr, cc = %g %d %d \n ", big, rr, cc);
																			}

																			if(rr == 1 && cc == 1)
																			{
																				cs = clf;
																				ts = tlf;
																			}
																			else if(rr == 1 && cc == 2)
																			{
																				cs = cf;
																				ts = tf;
																			}
																			else if(rr == 2 && cc == 1)
																			{
																				cs = cl;
																				ts = tl;
																			}
																			else if(rr == 2 && cc == 2)
																			{
																				cs = c;
																				ts = t;
																			}
																			else if(rr == 3 && cc == 1)
																			{
																				cs = cla;
																				ts = tla;
																			}
																			else if(rr == 3 && cc == 2)
																			{
																				cs = ca;
																				ts = ta;
																			}

																		}
																		else
																		{
																			big = big;
																			n_row = n_row ;
																			n_col = n_col ;
																			cs = cs;
																			ts = ts;


																		}
																	}
														Message(" RHS n_row, n_col = %d %d \n ", n_row, n_col );

												}
												else if( fequal(XC[1], 0.00001135) && (XC[0] > 0.0000227) && (XC[0] < 0.00112365) )// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to bottom boundary.)
												{
													C_CENTROID(X,c,t);
													C_CENTROID(Xr,cr,tr);
													C_CENTROID(Xf,cf,tf);
													C_CENTROID(Xl,cl,tl);
													C_CENTROID(Xrf,crf,trf);
													C_CENTROID(Xlf,clf,tlf);
								
													SX[1][1] = (Xlf[0] - xi);
													SX[1][2] = (Xf[0]  - xi);
													SX[1][3] = (Xrf[0] - xi);
													SX[2][1] = (Xl[0]  - xi);
													SX[2][2] = (X[0]   - xi);
													SX[2][3] = (Xr[0]  - xi);
	
													SY[1][1] = (Xlf[1] - yi);
													SY[1][2] = (Xf[1]  - yi);
													SY[1][3] = (Xrf[1] - yi);
													SY[2][1] = (Xl[1]  - yi);
													SY[2][2] = (X[1]   - yi);
													SY[2][3] = (Xr[1]  - yi);


													DS[1][1] = sqrt(SX[1][1]*SX[1][1] + SY[1][1]*SY[1][1]) ;
													DS[1][2] = sqrt(SX[1][2]*SX[1][2] + SY[1][2]*SY[1][2]) ;
													DS[1][3] = sqrt(SX[1][3]*SX[1][3] + SY[1][3]*SY[1][3]) ;
													DS[2][1] = sqrt(SX[2][1]*SX[2][1] + SY[2][1]*SY[2][1]) ;
													DS[2][2] = sqrt(SX[2][2]*SX[2][2] + SY[2][2]*SY[2][2]) ;
													DS[2][3] = sqrt(SX[2][3]*SX[2][3] + SY[2][3]*SY[2][3]) ;
												//	DS[3][1] = sqrt(SX[3][1]*SX[3][1] + SY[3][1]*SY[3][1]) ;
												//	DS[3][2] = sqrt(SX[3][2]*SX[3][2] + SY[3][2]*SY[3][2]) ;
												//	DS[3][3] = sqrt(SX[3][3]*SX[3][3] + SY[3][3]*SY[3][3]) ;

													SX[1][1] /= DS[1][1];
													SX[1][2] /= DS[1][2];
													SX[1][3] /= DS[1][3];
													SX[2][1] /= DS[2][1];
													SX[2][2] /= DS[2][2];
													SX[2][3] /= DS[2][3];											
											
	
													SY[1][1] /= DS[1][1];
													SY[1][2] /= DS[1][2];
													SY[1][3] /= DS[1][3];
													SY[2][1] /= DS[2][1];
													SY[2][2] /= DS[2][2];
													SY[2][3] /= DS[2][3];											

													dot_prod[1][1] = -( SX[1][1]*n[0] + SY[1][1]*n[1] ) ;//NV_DOT( S[1][1] , n );
													dot_prod[1][2] = -( SX[1][2]*n[0] + SY[1][2]*n[1] ) ;//NV_DOT( S[1][2] , n );
													dot_prod[1][3] = -( SX[1][3]*n[0] + SY[1][3]*n[1] ) ;//NV_DOT( S[3][1] , n );
													dot_prod[2][1] = -( SX[2][1]*n[0] + SY[2][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[2][2] = -( SX[2][2]*n[0] + SY[2][2]*n[1] ) ;//NV_DOT( S[2][2] , n );
													dot_prod[2][3] = -( SX[2][3]*n[0] + SY[2][3]*n[1] ) ;//NV_DOT( S[3][2] , n );	

													

													big = -1.0;
													for( rr = 1; rr <= 2; rr++)
														for( cc = 1; cc <= 3; cc++)
														{
															if (dot_prod[rr][cc] > big)
															{
																big = dot_prod[rr][cc]  ;
																n_row = rr;
																n_col = cc;
						
																if(big != 0)
																{
														//			Message( " big, rr, cc = %g %d %d \n ", big, rr, cc);
																}

																if(rr == 1 && cc == 1)
																{
																	cs = clf;
																	ts = tlf;
																}
																else if(rr == 1 && cc == 2)
																{
																	cs = cf;
																	ts = tf;
																}
																else if(rr == 1 && cc == 3)
																{
																	cs = crf;
																	ts = trf;
																}
																else if(rr == 2 && cc == 1)
																{
																	cs = cl;
																	ts = tl;
																}
																else if(rr == 2 && cc == 2)
																{
																	cs = c;
																	ts = t;
																}
																else if(rr == 2 && cc == 3)
																{
																	cs = cr;
																	ts = tr;
																}

															}
															else
															{
																big = big;
																n_row = n_row;
																n_col = n_col;
																cs = cs;
																ts = ts;
										
															}
														}
													Message(" B.B n_row, n_col = %d %d \n ", n_row, n_col );
												}
												else if( fequal(XC[1], 0.00225865) && (XC[0] > 0.0000227) && (XC[0] < 0.00112365) )					// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to top boundary.)
												{
													C_CENTROID(X,c,t);
													C_CENTROID(Xr,cr,tr);
													C_CENTROID(Xl,cl,tl);		 
													C_CENTROID(Xa,ca,ta);
													C_CENTROID(Xla,cla,tla);				
													C_CENTROID(Xra,cra,tra);
											
													SX[1][1] = (Xl[0] - xi);
													SX[1][2] = (X[0]  - xi);
													SX[1][3] = (Xr[0] - xi);
													SX[2][1] = (Xla[0]  - xi);
													SX[2][2] = (Xa[0]   - xi);
													SX[2][3] = (Xra[0]  - xi);
	
													SY[1][1] = (Xl[1] - yi);
													SY[1][2] = (X[1]  - yi);
													SY[1][3] = (Xr[1] - yi);
													SY[2][1] = (Xla[1]  - yi);
													SY[2][2] = (Xa[1]   - yi);
													SY[2][3] = (Xra[1]  - yi);


													DS[1][1] = sqrt(SX[1][1]*SX[1][1] + SY[1][1]*SY[1][1]) ;
													DS[1][2] = sqrt(SX[1][2]*SX[1][2] + SY[1][2]*SY[1][2]) ;
													DS[1][3] = sqrt(SX[1][3]*SX[1][3] + SY[1][3]*SY[1][3]) ;
													DS[2][1] = sqrt(SX[2][1]*SX[2][1] + SY[2][1]*SY[2][1]) ;
													DS[2][2] = sqrt(SX[2][2]*SX[2][2] + SY[2][2]*SY[2][2]) ;
													DS[2][3] = sqrt(SX[2][3]*SX[2][3] + SY[2][3]*SY[2][3]) ;
												//	DS[3][1] = sqrt(SX[3][1]*SX[3][1] + SY[3][1]*SY[3][1]) ;
												//	DS[3][2] = sqrt(SX[3][2]*SX[3][2] + SY[3][2]*SY[3][2]) ;
												//	DS[3][3] = sqrt(SX[3][3]*SX[3][3] + SY[3][3]*SY[3][3]) ;

													SX[1][1] /= DS[1][1];
													SX[1][2] /= DS[1][2];
													SX[1][3] /= DS[1][3];
													SX[2][1] /= DS[2][1];
													SX[2][2] /= DS[2][2];
													SX[2][3] /= DS[2][3];											
											
	
													SY[1][1] /= DS[1][1];
													SY[1][2] /= DS[1][2];
													SY[1][3] /= DS[1][3];
													SY[2][1] /= DS[2][1];
													SY[2][2] /= DS[2][2];
													SY[2][3] /= DS[2][3];											

													dot_prod[1][1] = -( SX[1][1]*n[0] + SY[1][1]*n[1] ) ;//NV_DOT( S[1][1] , n );
													dot_prod[1][2] = -( SX[1][2]*n[0] + SY[1][2]*n[1] ) ;//NV_DOT( S[1][2] , n );
													dot_prod[1][3] = -( SX[1][3]*n[0] + SY[1][3]*n[1] ) ;//NV_DOT( S[3][1] , n );
													dot_prod[2][1] = -( SX[2][1]*n[0] + SY[2][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[2][2] = -( SX[2][2]*n[0] + SY[2][2]*n[1] ) ;//NV_DOT( S[2][2] , n );
													dot_prod[2][3] = -( SX[2][3]*n[0] + SY[2][3]*n[1] ) ;//NV_DOT( S[3][2] , n );	

													big = -1.0;

													for( rr = 1; rr <= 2; rr++)
														for( cc = 1; cc <= 3; cc++)
														{
															if (dot_prod[rr][cc] > big)
															{
																big = dot_prod[rr][cc]  ;
																n_row = rr;
																n_col = cc;
						
																if(big != 0)
																{
														//			Message( " big, rr, cc = %g %d %d \n ", big, rr, cc);
																}

																if(rr == 1 && cc == 1)
																{
																	cs = cl;
																	ts = tl;
																}
																else if(rr == 1 && cc == 2)
																{
																	cs = c;
																	ts = t;
																}
																else if(rr == 1 && cc == 3)
																{
																	cs = cr;
																	ts = tr;
																}
																else if(rr == 2 && cc == 1)
																{
																	cs = cla;
																	ts = tla;
																}
																else if(rr == 2 && cc == 2)
																{
																	cs = ca;
																	ts = ta;
																}
																else if(rr == 2 && cc == 3)
																{
																	cs = cra;
																	ts = tra;
																}

															}
															else
															{
																big = big ;
																n_row = n_row;
																n_col = n_col;
																cs = cs;
																ts = ts;
										
															}
														}
													Message(" T.B n_row, n_col = %d %d \n ", n_row, n_col );
												}	
										//		else
										//		{
										//			return 0.0;
										//		}

												
										}
										else								// PLEASE NOTE : THIS WILL REMAIN SAME FOR ALL GEOMETRIES. This part is for interior cells other than cells at boundaries.
										{		
														C_CENTROID(X,c,t);
														C_CENTROID(Xr,cr,tr);
														C_CENTROID(Xf,cf,tf);
														C_CENTROID(Xl,cl,tl);		 
														C_CENTROID(Xa,ca,ta);
														C_CENTROID(Xrf,crf,trf);		
														C_CENTROID(Xlf,clf,tlf);
														C_CENTROID(Xla,cla,tla);				
														C_CENTROID(Xra,cra,tra);

//														Message(" X (clf, cf, crf, cl, c, cr, cla, ca, cra) =  %.10f %.10f %.10f \n %.10f %.10f %.10f \n %.10f %.10f %.10f \n ", Xlf[0], Xf[0], Xrf[0], Xl[0], X[0], Xr[0], Xla[0], Xa[0], Xra[0]);
//														Message(" Y (clf, cf, crf, cl, c, cr, cla, ca, cra) =  %.10f %.10f %.10f \n %.10f %.10f %.10f \n %.10f %.10f %.10f \n ", Xlf[1], Xf[1], Xrf[1], Xl[1], X[1], Xr[1], Xla[1], Xa[1], Xra[1]);
//														Message(" xi, yi = %.10f %.10f \n ", xi, yi );
//														Message(" iphase = \n %f %f %f \n %f %f %f \n %f %f %f \n ", C_UDMI(clf,tlf,1),C_UDMI(cf,tf,1),C_UDMI(crf,trf,1),C_UDMI(cl,tl,1),C_UDMI(c,t,1),C_UDMI(cr,tr,1),C_UDMI(cla,tla,1),C_UDMI(ca,ta,1),C_UDMI(cra,tra,1));

														SX[1][1] = (Xlf[0] - xi);
														SX[1][2] = (Xf[0]  - xi);
														SX[1][3] = (Xrf[0] - xi);
														SX[2][1] = (Xl[0]  - xi);
														SX[2][2] = 0.0 ; // (X[0] -xi); // 0.0;
														SX[2][3] = (Xr[0]  - xi);
														SX[3][1] = (Xla[0] - xi);
														SX[3][2] = (Xa[0]  - xi);
														SX[3][3] = (Xra[0] - xi);

//														Message(" SX Matrix = \n %g %g %g \n %g %g %g \n %g %g %g \n ", SX[1][1],SX[1][2],SX[1][3],SX[2][1],SX[2][2],SX[2][3],SX[3][1],SX[3][2],SX[3][3]);

														SY[1][1] = (Xlf[1] - yi);
														SY[1][2] = (Xf[1]  - yi);
														SY[1][3] = (Xrf[1] - yi);
														SY[2][1] = (Xl[1]  - yi);
														SY[2][2] = 0.0; // (X[1] - yi); // 0.0;
														SY[2][3] = (Xr[1]  - yi);
														SY[3][1] = (Xla[1] - yi);
														SY[3][2] = (Xa[1]  - yi);
														SY[3][3] = (Xra[1] - yi);

//														Message(" SY Matrix = \n %g %g %g \n %g %g %g \n %g %g %g \n ", SY[1][1],SY[1][2],SY[1][3],SY[2][1],SY[2][2],SY[2][3],SY[3][1],SY[3][2],SY[3][3]);

													DS[1][1] = sqrt(SX[1][1]*SX[1][1] + SY[1][1]*SY[1][1]) ;
													DS[1][2] = sqrt(SX[1][2]*SX[1][2] + SY[1][2]*SY[1][2]) ;
													DS[1][3] = sqrt(SX[1][3]*SX[1][3] + SY[1][3]*SY[1][3]) ;
													DS[2][1] = sqrt(SX[2][1]*SX[2][1] + SY[2][1]*SY[2][1]) ;
													DS[2][2] = 0.0 ; // sqrt(SX[2][2]*SX[2][2] + SY[2][2]*SY[2][2]) ; 
													DS[2][3] = sqrt(SX[2][3]*SX[2][3] + SY[2][3]*SY[2][3]) ;
													DS[3][1] = sqrt(SX[3][1]*SX[3][1] + SY[3][1]*SY[3][1]) ;
													DS[3][2] = sqrt(SX[3][2]*SX[3][2] + SY[3][2]*SY[3][2]) ;
													DS[3][3] = sqrt(SX[3][3]*SX[3][3] + SY[3][3]*SY[3][3]) ;

													SX[1][1] /= DS[1][1];
													SX[1][2] /= DS[1][2];
													SX[1][3] /= DS[1][3];
													SX[2][1] /= DS[2][1];
													SX[2][2] = 0.0; 
													SX[2][3] /= DS[2][3];											
													SX[3][1] /= DS[3][1];
													SX[3][2] /= DS[3][2];
													SX[3][3] /= DS[3][3];												
	
													SY[1][1] /= DS[1][1];
													SY[1][2] /= DS[1][2];
													SY[1][3] /= DS[1][3];
													SY[2][1] /= DS[2][1];
													SY[2][2] = 0.0; 
													SY[2][3] /= DS[2][3];
													SY[3][1] /= DS[3][1];
													SY[3][2] /= DS[3][2];
													SY[3][3] /= DS[3][3];												

										

													dot_prod[1][1] = -( SX[1][1]*n[0] + SY[1][1]*n[1] ) ;//NV_DOT( S[1][1] , n );
													dot_prod[1][2] = -( SX[1][2]*n[0] + SY[1][2]*n[1] ) ;//NV_DOT( S[1][2] , n );
													dot_prod[1][3] = -( SX[1][3]*n[0] + SY[1][3]*n[1] ) ;//NV_DOT( S[3][1] , n );
													dot_prod[2][1] = -( SX[2][1]*n[0] + SY[2][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[2][2] = 0.0; //-( SX[2][2]*n[0] + SY[2][2]*n[1] ) ;//NV_DOT( S[2][2] , n );
													dot_prod[2][3] = -( SX[2][3]*n[0] + SY[2][3]*n[1] ) ;//NV_DOT( S[3][2] , n );	
													dot_prod[3][1] = -( SX[3][1]*n[0] + SY[3][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[3][2] = -( SX[3][2]*n[0] + SY[3][2]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[3][3] = -( SX[3][3]*n[0] + SY[3][3]*n[1] ) ;//NV_DOT( S[2][1] , n );
		
//			Message(" c, C_UDMI(c,t,1), n[0], n[1], DOT PROD = %u %f %.15f %.15f \n %g %g %g \n %g %g %g \n %g %g %g \n ", c, C_UDMI(c,t,1), n[0], n[1], dot_prod[1][1],dot_prod[1][2],dot_prod[1][3],dot_prod[2][1],dot_prod[2][2],dot_prod[2][3],dot_prod[3][1],dot_prod[3][2],dot_prod[3][3]);

	
													//	big = 0.0;
	
														big = -1.0;
	
														for( rr = 1; rr <= 3; rr++)
															for( cc = 1; cc <= 3; cc++)
															{
													//			Message("rr,cc= %d %d \n", rr, cc);

																if (dot_prod[rr][cc] > big)
																{
																	big = dot_prod[rr][cc] ;
																	n_row = rr;
																	n_col = cc;
						
																	if(big != 0.0)
																	{
															//			Message( " big, rr, cc = %g %d %d \n ", big, rr, cc);
																	}

																	if(rr == 1 && cc == 1)
																	{
																		cs = clf;
																		ts = tlf;
																	}
																	else if(rr == 1 && cc == 2)
																	{
																		cs = cf;
																		ts = tf;
																	}
																	else if(rr == 1 && cc == 3)
																	{
																		cs = crf;
																		ts = trf;
																	}
																	else if(rr == 2 && cc == 1)
																	{
																		cs = cl;
																		ts = tl;
																	}
																	else if(rr == 2 && cc == 2)
																	{
																		cs = c;
																		ts = t;
																	}
																	else if(rr == 2 && cc == 3)
																	{
																		cs = cr;
																		ts = tr;
																	}
																	else if(rr == 3 && cc == 1)
																	{
																		cs = cla;
																		ts = tla;
																	}
																	else if(rr == 3 && cc == 2)
																	{
																		cs = ca;
																		ts = ta;
																	}
																	else if(rr == 3 && cc == 3)
																	{
																		cs = cra;
																		ts = tra;
																	}
																}
																else
																{
																	big = big;
																	n_row = n_row;
																	n_col = n_col;
																	cs = cs;
																	ts = ts;

																}


															}
										//		Message(" c, n_row, n_col = %u %d %d \n ", c, n_row, n_col );

									}

//								Message(" c, n_row, n_col = %u %d %d \n ", c, n_row, n_col );

		if( n_row == 0 || n_col == 0 || n_row > 3 || n_col > 3 )
		{
			return  0.0;
		}
		else
		{
									sx = SX[n_row][n_col];
									sy = SY[n_row][n_col];
									ds = DS[n_row][n_col];	// sqrt(sx*sx + sy*sy); 
								//	sx = sx/ds;
								//	sy = sy/ds;

//			NV_D(s , = , SX[n_row][n_col] , SY[n_row][n_col] , 0.0 );

			kl = 0.5454;
			kg = 0.5383;
			keff = kl*C_VOF(c,t_liquid) + kg*C_VOF(c,t_vapour);

			latent_heat = 276400.0;

//			ds = NV_MAG(s);
			


			if ( fequal(ds , 0.0) )
			{
				source = 0.0;
			}
			else
			{
//				NV_VS(q_s, = , s , * , (kl*(TSAT - C_T(cs,ts))/ds) );

//				q_n = NV_DOT(q_s , n);
//			C_CENTROID(XCS, cs, ts);
//			C_CENTROID(XC,c,t);
//			Message(" c, cs, C_UDMI(cs,ts,1) , C_UDMI(c,t,1) = %u %u %f %f \n ", c, cs, C_UDMI(cs,t,1) , C_UDMI(c,t,1) );
				q_n = sx*(keff*(TSAT - C_T(cs,t))/ds)*C_VOF_RG(c,t_liquid)[0] + sy*(keff*(TSAT - C_T(cs,t))/ds)*C_VOF_RG(c,t_liquid)[1] ; 
				source = - fabs(q_n / latent_heat ) ; 
//			Message("c, ds, C_T(cs,t), source  = %u %f %f %g \n ", c, ds, C_T(cs,t), source );
				C_UDMI(c,t,6) = source;
			}			

			dS[eqn] = 0.0;
	//		Message(" c, source = %u %g  \n ", c, source );
	//		Message("last = %f %f %g %g %g %.20f \n ", SX[n_row][n_col], SY[n_row][n_col] , q_n, ((kl*(TSAT - C_T(cs,ts))/ds)/latent_heat) , ds , source );
			return    source;		
		}
		
			
	
	}
	else
	{
		return 0.0;
	}
}

DEFINE_SOURCE(vapor_mass_source, c, t_vapour, dS, eqn)
{
	Thread *t = THREAD_SUPER_THREAD(t_vapour);
	Thread *t_liquid = THREAD_SUB_THREAD(t,0);
	cell_t cs; 
	Thread *ts;
	
	/* =============== DECLARATION OF NEIGHBOURING CELL ID'S AND THREAD'S ================= */
	cell_t cr, cf, cl, ca, crf, cra, clf, cla ;
	Thread *tf, *ta, *tr, *tl, *trf, *tra, *tlf, *tla ;

	face_t fr,ff,fl,fa,ffr,far,ffl,fal,frp,flp,frm,flm;
	Thread *tfr, *tff, *tfl, *tfa, *tffr, *tfar, *tffl, *tfal, *tfrp, *tflp, *tfrm, *tflm;

	face_t f;
	Thread *t_f;
	Thread *t_fr, *t_ff, *t_fl, *t_fa;
	Node *node;
	int a;
	/* ------------------------------------------------------------------------------------ */
	cell_t CELL[3][3];
	Thread *THREAD[3][3];
	float NV_VEC(S11), NV_VEC(S12), NV_VEC(S13), NV_VEC(S21), NV_VEC(S22), NV_VEC(S23), NV_VEC(S31), NV_VEC(S32), NV_VEC(S33);
	
	float SX[3][3], SY[3][3], DS[3][3];

	float source;

	float NV_VEC(n), NV_VEC(s), NV_VEC(sr), NV_VEC(sf), NV_VEC(sl), NV_VEC(sa), NV_VEC(srf), NV_VEC(slf), NV_VEC(sla), NV_VEC(sra), sx , sy ;
	real  xl , xr , ya , yf; 
	float XR[ND_ND], XF[ND_ND], XL[ND_ND], XA[ND_ND] , xi , yi , xis , yis;
	real nx,ny,xint1, xint2 , yint1, yint2;
	float X[ND_ND], Xr[ND_ND], Xf[ND_ND], Xl[ND_ND], Xa[ND_ND], Xrf[ND_ND], Xlf[ND_ND], Xla[ND_ND], Xra[ND_ND], XC[ND_ND], XCS[ND_ND];
	real xcf[ND_ND],xca[ND_ND], xcr[ND_ND], xcl[ND_ND] ;
	real *ptl, *ptr, *pta, *ptf ;
	real xci[ND_ND];
	int N;
	int iface_int1, iface_int2;
	int iphs;
	float NV_VEC(q_s), q_n , ds , kl , kg, keff, latent_heat;
	float XS[ND_ND];
	int ii,jj;
	int rr, cc, n_row, n_col ;
	float dot_prod[3][3] , S[3][3]  ;
	float big;
	real ax, ay, bx, by;
	FILE *fp;
	char name[50];

	real dx,dy;
	real len, voll ;
	real sourcl, sourcv, tempn;
	
	real distance;
	
	cxboolean check_r ;
	cxboolean check_f ;
	cxboolean check_l ;
	cxboolean check_a ;
	cxboolean boundary;

	check_r = FALSE;
	check_f = FALSE;
	check_l = FALSE;
	check_a = FALSE;
	
	iphs = C_UDMI(c,t,1); //iphase[c];
	n[0] = C_UDMI(c,t,2); //nx;
	n[1] = C_UDMI(c,t,3); //ny;	

//	

if (iphs == 2 )
{

	t_f = C_FACE_THREAD(c,t,0);

  		C_CENTROID(XC,c,t);
//	Message(" iphs, n[0], n[1] = %d %f %f \n ", iphs, n[0], n[1] );

	if(BOUNDARY_FACE_THREAD_P(t_f))
	{													


					// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to left boundary.)
					if( fequal(XC[0], 0.00001135) && (XC[1] > 0.00003405) && (XC[1] < 0.0022473)  )
					{
						ff = C_FACE(c,t,3);					
						tff = C_FACE_THREAD(c,t,3);
						fa = C_FACE(c,t,1);
						tfa = C_FACE_THREAD(c,t,1);
							fr = C_FACE(c,t,2);
							tfr = C_FACE_THREAD(c,t,2);	
							fl = C_FACE(c,t,0);
							tfl = C_FACE_THREAD(c,t,0);	
							
//=====================================================================================================================================
							F_CENTROID(XR,fr,tfr);
							F_CENTROID(XF,ff,tff);
							F_CENTROID(XL,fl,tfl);
							F_CENTROID(XA,fa,tfa);

							xr = XR[0] ;
							yf = XF[1] ;
							xl = XL[0] ;
							ya = XA[1] ;

						// ================ GTM FUNCTION CALL =================== 

							delta(c,t, &dx, &dy); 
							nx = C_UDMI(c,t,2);
							ny = C_UDMI(c,t,3);
	
							linseg(c, t_liquid, xl, xr, ya, yf, &xint1, &xint2, &yint1, &yint2, &iface_int1, &iface_int2);
							lgvol( c, t_liquid, xl, xr, ya, yf, &voll );

						// =============== DEFINITION OF N-VECTOR ================ 

				//			n[0]  =  nx; 
				//			n[1]  =  ny;

						// =============== MODIFIED DEFINITION OF S-VECTOR ================ 


						if(xint1 > xint2)
						{
							xi = xint2 + fabs((xint1 - xint2)/2.0) ;
						}
						else
						{
							xi = xint1 + fabs((xint1 - xint2)/2.0) ;
						}

						if(yint1 > yint2)
						{
							yi = yint2 + fabs((yint1 - yint2)/2.0) ;								
						}
						else
						{
							yi = yint1 + fabs((yint1 - yint2)/2.0) ;								
						}							

//============================================================================================================================================						


					// ----------- FRONT FACE ------------ 

						cf = F_C0(ff,tff);
						if(cf == c)
						{
							cf = F_C1(ff,tff);
							tf = F_C1_THREAD(ff,tff);
						}
						else
						{
							tf = F_C0_THREAD(ff,tff);
						}
						
						// ----------- RIGHT FACE ----------- 

							cr = F_C0(fr,tfr);
							if(cr == c)
							{
								cr = F_C1(fr,tfr);
								tr = F_C1_THREAD(fr,tfr);
							}
							else
							{
								tr = F_C0_THREAD(fr,tfr);
							}   

					// ------------ AFTER FACE ------------ 

						ca = F_C0(fa,tfa);
						if(ca == c)
						{
							ca = F_C1(fa,tfa);
							ta = F_C1_THREAD(fa,tfa);
						}
						else
						{
							ta = F_C0_THREAD(fa,tfa);
						}

						C_CENTROID(xcf,cf,tf);
						C_CENTROID(xca,ca,ta);

							if ( fequal( xcf[1], 0.00225865 ) )
							{
								return 0.0;							
							}
							else if ( fequal(xca[1],0.00001135) )
							{
								return 0.0;
							}
							else
							{
									frm = C_FACE(ca,ta,2);
									tfrm = C_FACE_THREAD(ca,ta,2);

									frp = C_FACE(cf,tf,2);
									tfrp = C_FACE_THREAD(cf,tf,2);
			
								// ======================== (crf,trf) ============================= 

									crf = F_C0(frp,tfrp);
									if(crf == cr)
									{
										crf = F_C1(frp,tfrp);
										trf = F_C1_THREAD(frp,tfrp);
									}
									else
									{
										trf = F_C0_THREAD(frp,tfrp);
									}


								// ======================== (cra,tra) ============================= 

									cra = F_C0(frm,tfrm);
									if(cra == cr)
									{
										cra = F_C1(frm,tfrm);
										tra = F_C1_THREAD(frm,tfrm);
									}
									else
									{
										tra = F_C0_THREAD(frm,tfrm);
									}
							}
//			Message(" cf = %u \t crf = %u \n ", cf, crf);		
//			Message(" c  = %u \t cr  = %u \n ", c, cr   );	
//			Message(" ca = %u \t cra = %u \n ", ca, cra);

					}

					// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to right boundary.)
				    else if( fequal(XC[0], 0.00112365) && (XC[1] > 0.00003405) && (XC[1] < 0.0022473)  )
					{
						ff = C_FACE(c,t,1);					
						tff = C_FACE_THREAD(c,t,1);
						fa = C_FACE(c,t,3);
						tfa = C_FACE_THREAD(c,t,3);
						fl = C_FACE(c,t,2);
						tfl = C_FACE_THREAD(c,t,2);	
						fr = C_FACE(c,t,0);
						tfr = C_FACE_THREAD(c,t,0);	
					
			//			Message(" HI I am Right \n");

//=========================================================================================================================================
							F_CENTROID(XR,fr,tfr);
							F_CENTROID(XF,ff,tff);
							F_CENTROID(XL,fl,tfl);
							F_CENTROID(XA,fa,tfa);

							xr = XR[0] ;
							yf = XF[1] ;
							xl = XL[0] ;
							ya = XA[1] ;

						// ================ GTM FUNCTION CALL =================== 

							delta(c,t, &dx, &dy); 
							nx = C_UDMI(c,t,2);
							ny = C_UDMI(c,t,3);
	
							linseg(c, t_liquid, xl, xr, ya, yf, &xint1, &xint2, &yint1, &yint2, &iface_int1, &iface_int2);
							lgvol( c, t_liquid, xl, xr, ya, yf, &voll );

						// =============== DEFINITION OF N-VECTOR ================ 

				//			n[0]  =  nx; 
				//			n[1]  =  ny;

						// =============== MODIFIED DEFINITION OF S-VECTOR ================ 


						if(xint1 > xint2)
						{
							xi = xint2 + fabs((xint1 - xint2)/2.0) ;
						}
						else
						{
							xi = xint1 + fabs((xint1 - xint2)/2.0) ;
						}

						if(yint1 > yint2)
						{
							yi = yint2 + fabs((yint1 - yint2)/2.0) ;								
						}
						else
						{
							yi = yint1 + fabs((yint1 - yint2)/2.0) ;								
						}			

//============================================================================================================================================

							// ----------- FRONT FACE ------------ 

								cf = F_C0(ff,tff);
								if(cf == c)
								{
									cf = F_C1(ff,tff);
									tf = F_C1_THREAD(ff,tff);
								}
								else
								{
									tf = F_C0_THREAD(ff,tff);
								}

					// ----------- LEFT FACE ------------ 

							cl = F_C0(fl,tfl);
							if(cl == c)
							{
								cl = F_C1(fl,tfl);
								tl = F_C1_THREAD(fl,tfl);
							}
							else
							{
								tl = F_C0_THREAD(fl,tfl);
							}


							// ------------ AFTER FACE ------------ 

								ca = F_C0(fa,tfa);
								if(ca == c)
								{
									ca = F_C1(fa,tfa);
									ta = F_C1_THREAD(fa,tfa);
								}
								else
								{
									ta = F_C0_THREAD(fa,tfa);
								}

						C_CENTROID(xcf,cf,tf);
						C_CENTROID(xca,ca,ta);

							if ( fequal( xcf[1], 0.00225865 ) )
							{
								return 0.0;			
							}
							else if ( fequal(xca[1],0.00001135) )
							{
								return 0.0;
							}
							else
							{
									flp = C_FACE(cf,tf,2);
									tflp = C_FACE_THREAD(cf,tf,2);

									flm = C_FACE(ca,ta,2);
									tflm = C_FACE_THREAD(ca,ta,2);


								// ======================== (crf,trf) ============================= 

									clf = F_C0(flp,tflp);
									if(clf == cl)
									{
										clf = F_C1(flp,tflp);
										tlf = F_C1_THREAD(flp,tflp);
									}
									else
									{
										tlf = F_C0_THREAD(flp,tflp);
									}


								// ======================== (cra,tra) ============================= 

									cla = F_C0(flm,tflm);
									if(cla == cl)
									{
										cla = F_C1(flm,tflm);
										tla = F_C1_THREAD(flm,tflm);
									}
									else
									{
										tla = F_C0_THREAD(flm,tflm);
									}
							}
//			Message(" clf = %u \t cf = %u \n ", clf, cf);		
//			Message(" cl = %u  \t c  = %u \n ", cl, c   );	
//			Message(" cla = %u \t ca = %u \n ", cla, ca);




					}

					// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to bottom boundary.)
					else if( fequal(XC[1], 0.00001135) && (XC[0] > 0.0000227) && (XC[0] < 0.00112365) )
					{
						ff = C_FACE(c,t,2);					
						tff = C_FACE_THREAD(c,t,2);
						fr = C_FACE(c,t,1);
						tfr = C_FACE_THREAD(c,t,1);			
						fl = C_FACE(c,t,3);
						tfl = C_FACE_THREAD(c,t,3);
						fa = C_FACE(c,t,0);
						tfa = C_FACE_THREAD(c,t,0);


//=========================================================================================================================================
						F_CENTROID(XR,fr,tfr);
						F_CENTROID(XF,ff,tff);
						F_CENTROID(XL,fl,tfl);
						F_CENTROID(XA,fa,tfa);

						xr = XR[0] ;
						yf = XF[1] ;
						xl = XL[0] ;
						ya = XA[1] ;

					// ================ GTM FUNCTION CALL =================== 

						delta(c,t, &dx, &dy); 
						nx = C_UDMI(c,t,2);
						ny = C_UDMI(c,t,3);
	
						linseg(c, t_liquid, xl, xr, ya, yf, &xint1, &xint2, &yint1, &yint2, &iface_int1, &iface_int2);
						lgvol( c, t_liquid, xl, xr, ya, yf, &voll );

					// =============== DEFINITION OF N-VECTOR ================ 

			//				n[0]  =  nx; 
			//				n[1]  =  ny;

					// =============== MODIFIED DEFINITION OF S-VECTOR ================ 


						if(xint1 > xint2)
						{
							xi = xint2 + fabs((xint1 - xint2)/2.0) ;
						}
						else
						{
							xi = xint1 + fabs((xint1 - xint2)/2.0) ;
						}

						if(yint1 > yint2)
						{
							yi = yint2 + fabs((yint1 - yint2)/2.0) ;								
						}
						else
						{
							yi = yint1 + fabs((yint1 - yint2)/2.0) ;								
						}			

//============================================================================================================================================


						// ----------- RIGHT FACE ----------- 

							cr = F_C0(fr,tfr);
							if(cr == c)
							{
								cr = F_C1(fr,tfr);
								tr = F_C1_THREAD(fr,tfr);
							}
							else
							{
								tr = F_C0_THREAD(fr,tfr);
							}   

						// ----------- LEFT FACE ------------ =

							cl = F_C0(fl,tfl);
							if(cl == c)
							{
								cl = F_C1(fl,tfl);
								tl = F_C1_THREAD(fl,tfl);
							}
							else
							{
								tl = F_C0_THREAD(fl,tfl);
							}

						// ----------- FRONT FACE ------------ =

							cf = F_C0(ff,tff);
							if(cf == c)
							{
								cf = F_C1(ff,tff);
								tf = F_C1_THREAD(ff,tff);
							}
							else
							{
								tf = F_C0_THREAD(ff,tff);
							}

						c_face_loop(cr,tr,N)
						{
							t_fr = C_FACE_THREAD(cr,tr,N);
							if( BOUNDARY_FACE_THREAD_P(t_fr) )
							{
								check_r = TRUE;
							}
						}

					C_CENTROID(xcr, cr, tr);
					C_CENTROID(xcl, cl, tl);

							if (fequal(xcr[0], 0.00112365) )
							{
								return 0.0 ;

							}
							else if(fequal(xcl[0], 0.000011365) )
							{
								return 0.0 ;
							}
							else
							{

									ffr = C_FACE(cr,tr,2);
									tffr = C_FACE_THREAD(cr,tr,2);

									ffl = C_FACE(cl,tl,2);
									tffl = C_FACE_THREAD(cl,tl,2);

								// ======================== (crf,trf) ============================= 

									crf = F_C0(ffr,tffr);
									if(crf == cr)
									{
										crf = F_C1(ffr,tffr);
										trf = F_C1_THREAD(ffr,tffr);
									}
									else
									{
										trf = F_C0_THREAD(ffr,tffr);
									}
						//			Message(" crf = %u \n ", crf);

								// ======================== (clf,tlf) ============================= 

									clf = F_C0(ffl,tffl);
									if(clf == cl)
									{
										clf = F_C1(ffl,tffl);
										tlf = F_C1_THREAD(ffl,tffl);
									}
									else
									{
										tlf = F_C0_THREAD(ffl,tffl);
									}
						//			Message(" clf = %u \n ", clf);
							
							}

//								Message(" clf = %u \t cf = %u \t crf = %u \n ", clf, cf, crf);		
//								Message(" cl = %u  \t c  = %u \t cr  = %u \n ", cl, c, cr   );									

					}
					
					// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to top boundary.)
					else if( fequal(XC[1], 0.00225865) && (XC[0] > 0.0000227) && (XC[0] < 0.00112365) )
					{
						fa = C_FACE(c,t,2);
						tfa = C_FACE_THREAD(c,t,2);
						fr = C_FACE(c,t,3);
						tfr = C_FACE_THREAD(c,t,3);			
						fl = C_FACE(c,t,1);
						tfl = C_FACE_THREAD(c,t,1);
						ff = C_FACE(c,t,0);
						tff = C_FACE_THREAD(c,t,0);

	//					Message(" HI I am TOP \n");
					
//=========================================================================================================================================
						F_CENTROID(XR,fr,tfr);
						F_CENTROID(XF,ff,tff);
						F_CENTROID(XL,fl,tfl);
						F_CENTROID(XA,fa,tfa);

						xr = XR[0] ;
						yf = XF[1] ;
						xl = XL[0] ;
						ya = XA[1] ;

					// ================ GTM FUNCTION CALL =================== 

						delta(c,t, &dx, &dy); 
						nx = C_UDMI(c,t,2);
						ny = C_UDMI(c,t,3);
	
						linseg(c, t_liquid, xl, xr, ya, yf, &xint1, &xint2, &yint1, &yint2, &iface_int1, &iface_int2);
						lgvol( c, t_liquid, xl, xr, ya, yf, &voll );

					// =============== DEFINITION OF N-VECTOR ================ 

			//				n[0]  =  nx; 
			//				n[1]  =  ny;

					// =============== MODIFIED DEFINITION OF S-VECTOR ================ 


						if(xint1 > xint2)
						{
							xi = xint2 + fabs((xint1 - xint2)/2.0) ;
						}
						else
						{
							xi = xint1 + fabs((xint1 - xint2)/2.0) ;
						}

						if(yint1 > yint2)
						{
							yi = yint2 + fabs((yint1 - yint2)/2.0) ;								
						}
						else
						{
							yi = yint1 + fabs((yint1 - yint2)/2.0) ;								
						}			

//============================================================================================================================================

						// ----------- RIGHT FACE ----------- 

							cr = F_C0(fr,tfr);
							if(cr == c)
							{
								cr = F_C1(fr,tfr);
								tr = F_C1_THREAD(fr,tfr);
							}
							else
							{
								tr = F_C0_THREAD(fr,tfr);
							}   

						// ----------- LEFT FACE ------------ 

							cl = F_C0(fl,tfl);
							if(cl == c)
							{
								cl = F_C1(fl,tfl);
								tl = F_C1_THREAD(fl,tfl);
							}
							else
							{
								tl = F_C0_THREAD(fl,tfl);
							}

						// ----------- AFTER FACE ------------ 

							ca = F_C0(fa,tfa);
							if(ca == c)
							{
								ca = F_C1(fa,tfa);
								ta = F_C1_THREAD(fa,tfa);
							}
							else
							{
								ta = F_C0_THREAD(fa,tfa);
							}



							C_CENTROID(xcr,cr,tr);
							C_CENTROID(xcl,cl,tl);

							if (fequal(xcr[0] , 0.00112365))
							{
								return 0.0 ;
							}
							else if(fequal(xcl[0], 0.00001135))
							{
								return 0.0 ;
							}
							else
							{
									far = C_FACE(cr,tr,2);
									tfar = C_FACE_THREAD(cr,tr,2);

									fal = C_FACE(cl,tl,2);
									tfal = C_FACE_THREAD(cl,tl,2);

								// ======================== (cra,tra) ============================= 

									cra = F_C0(far,tfar);
									if(cra == cr)
									{
										cra = F_C1(far,tfar);
										tra = F_C1_THREAD(far,tfar);
									}
									else
									{
										tra = F_C0_THREAD(far,tfar);
									}
						//			Message(" crf = %u \n ", crf);

								// ======================== (cla,tla) ============================= 

									cla = F_C0(fal,tfal);
									if(cla == cl)
									{
										cla = F_C1(fal,tfal);
										tla = F_C1_THREAD(fal,tfal);
									}
									else
									{
										tla = F_C0_THREAD(fal,tfal);
									}
						//			Message(" clf = %u \n ", clf);

							}
//									Message(" cl = %u  \t c  = %u \t cr  = %u \n ", cl, c, cr   );
//									Message(" cla = %u \t ca = %u \t cra = %u \n ", cla, ca, cra);
					}				
					else
					{
						return 0.0;

						}
			
	}
	else
	{
	
		fr = C_FACE(c,t,1);
		tfr = C_FACE_THREAD(c,t,1);
		fl = C_FACE(c,t,3);					
		tfl = C_FACE_THREAD(c,t,3);			
		ff = C_FACE(c,t,2);					
		tff = C_FACE_THREAD(c,t,2);
		fa = C_FACE(c,t,0);
		tfa = C_FACE_THREAD(c,t,0);
	



	// ----------- RIGHT FACE ----------- =

		cr = F_C0(fr,tfr);
		if(cr == c)
		{
			cr = F_C1(fr,tfr);
			tr = F_C1_THREAD(fr,tfr);
		}
		else
		{
			tr = F_C0_THREAD(fr,tfr);
		}   

	// ----------- LEFT FACE ------------ =

		cl = F_C0(fl,tfl);
		if(cl == c)
		{
			cl = F_C1(fl,tfl);
			tl = F_C1_THREAD(fl,tfl);
		}
		else
		{
			tl = F_C0_THREAD(fl,tfl);
		}

	// ----------- FRONT FACE ------------ =

		cf = F_C0(ff,tff);
		if(cf == c)
		{
			cf = F_C1(ff,tff);
			tf = F_C1_THREAD(ff,tff);
		}
		else
		{
			tf = F_C0_THREAD(ff,tff);
		}

	// ------------ AFTER FACE ------------ =

		ca = F_C0(fa,tfa);
		if(ca == c)
		{
			ca = F_C1(fa,tfa);
			ta = F_C1_THREAD(fa,tfa);
		}
		else
		{
			ta = F_C0_THREAD(fa,tfa);
		}
//	Message("      cf    = \t \t %u \t \t  \n ", cf );
//	Message(" cl , c, cr = %u \t %u \t %u \n ", cl, c, cr );
//	Message("      ca    = \t \t %u \t \t  \n ", ca );

//=========================================================================================================================================
						F_CENTROID(XR,fr,tfr);
						F_CENTROID(XF,ff,tff);
						F_CENTROID(XL,fl,tfl);
						F_CENTROID(XA,fa,tfa);

						xr = XR[0] ;
						yf = XF[1] ;
						xl = XL[0] ;
						ya = XA[1] ;

					// ================ GTM FUNCTION CALL =================== 

						delta(c,t, &dx, &dy); 
						nx = C_UDMI(c,t,2);
						ny = C_UDMI(c,t,3);
	
						linseg(c, t_liquid, xl, xr, ya, yf, &xint1, &xint2, &yint1, &yint2, &iface_int1, &iface_int2);
						lgvol( c, t_liquid, xl, xr, ya, yf, &voll );

					// =============== DEFINITION OF N-VECTOR ================ 

		//					n[0]  =  nx; 
		//					n[1]  =  ny;

					// =============== MODIFIED DEFINITION OF S-VECTOR ================ 


						if(xint1 > xint2)
						{
							xi = xint2 + fabs((xint1 - xint2)/2.0) ;
						}
						else
						{
							xi = xint1 + fabs((xint1 - xint2)/2.0) ;
						}

						if(yint1 > yint2)
						{
							yi = yint2 + fabs((yint1 - yint2)/2.0) ;								
						}
						else
						{
							yi = yint1 + fabs((yint1 - yint2)/2.0) ;								
						}			

//============================================================================================================================================


		c_face_loop(cr,tr,N)
		{
			t_fr = C_FACE_THREAD(cr,tr,N);
			if( BOUNDARY_FACE_THREAD_P(t_fr) )
			{
				check_r = TRUE;
			}
		}

		c_face_loop(cf,tf,N)
		{
			t_ff = C_FACE_THREAD(cf,tf,N);
			if( BOUNDARY_FACE_THREAD_P(t_ff) )
			{
				check_f = TRUE;
			}
		}

		c_face_loop(cl,tl,N)
		{
			t_fl = C_FACE_THREAD(cl,tl,N);
			if( BOUNDARY_FACE_THREAD_P(t_fl) )
			{
				check_l = TRUE;
			}
		}

		c_face_loop(ca,ta,N)
		{
			t_fa = C_FACE_THREAD(ca,ta,N);
			if( BOUNDARY_FACE_THREAD_P(t_fa) )
			{
				check_a = TRUE;
			}
		}				

		if( check_r )
		{
//			Message(" BOUNDARY CELL ENCOUNTERED \n ");
			

				ffr = C_FACE(cr,tr,1);
				tffr = C_FACE_THREAD(cr,tr,1);

				far = C_FACE(cr,tr,3);
				tfar = C_FACE_THREAD(cr,tr,3);

				ffl = C_FACE(cl,tl,2);
				tffl = C_FACE_THREAD(cl,tl,2);

				fal = C_FACE(cl,tl,0);
				tfal = C_FACE_THREAD(cl,tl,0);

			// ======================== (crf,trf) ============================= =

				crf = F_C0(ffr,tffr);
				if(crf == cr)
				{
					crf = F_C1(ffr,tffr);
					trf = F_C1_THREAD(ffr,tffr);
				}
				else
				{
					trf = F_C0_THREAD(ffr,tffr);
				}
	//			Message(" crf = %u \n ", crf);
			// ======================== (cra,tra) ============================= =

				cra = F_C0(far,tfar);
				if(cra == cr)
				{
					cra = F_C1(far,tfar);
					tra = F_C1_THREAD(far,tfar);
				}
				else
				{
					tra = F_C0_THREAD(far,tfar);
				}
	//			Message(" cra = %u \n ", cra);	
			// ======================== (clf,tlf) ============================= =

				clf = F_C0(ffl,tffl);
				if(clf == cl)
				{
					clf = F_C1(ffl,tffl);
					tlf = F_C1_THREAD(ffl,tffl);
				}
				else
				{
					tlf = F_C0_THREAD(ffl,tffl);
				}
	//			Message(" clf = %u \n ", clf);
			// ======================== (cla,tla) ============================= =

				cla = F_C0(fal,tfal);
				if(cla == cl)
				{
					cla = F_C1(fal,tfal);
					tla = F_C1_THREAD(fal,tfal);
				}
				else
				{
					tla = F_C0_THREAD(fal,tfal);
				}
	//			Message(" cla = %u \n ", cla);
		
		}
		else if ( check_f )
		{
			
				frp = C_FACE(cf,tf,3);
				tfrp = C_FACE_THREAD(cf,tf,3);

				flp = C_FACE(cf,tf,1);
				tflp = C_FACE_THREAD(cf,tf,1);

				frm = C_FACE(ca,ta,1);
				tfrm = C_FACE_THREAD(ca,ta,1);

				flm = C_FACE(ca,ta,3);
				tflm = C_FACE_THREAD(ca,ta,3);

			// ======================== (crf,trf) ============================= =

				crf = F_C0(frp,tfrp);
				if(crf == cr)
				{
					crf = F_C1(frp,tfrp);
					trf = F_C1_THREAD(frp,tfrp);
				}
				else
				{
					trf = F_C0_THREAD(frp,tfrp);
				}

			// ======================== (clf,tlf) ============================= =

				clf = F_C0(flp,tflp);
				if(clf == cl)
				{
					clf = F_C1(flp,tflp);
					tlf = F_C1_THREAD(flp,tflp);
				}
				else
				{
					tlf = F_C0_THREAD(flp,tflp);
				}

			// ======================== (cra,tra) ============================= =

				cra = F_C0(frm,tfrm);
				if(cra == cr)
				{
					cra = F_C1(frm,tfrm);
					tra = F_C1_THREAD(frm,tfrm);
				}
				else
				{
					tra = F_C0_THREAD(frm,tfrm);
				}

			// ======================== (cla,tla) ============================= =

				cla = F_C0(flm,tflm);
				if(cla == cl)
				{
					cla = F_C1(flm,tflm);
					tla = F_C1_THREAD(flm,tflm);
				}
				else
				{
					tla = F_C0_THREAD(flm,tflm);
				}
			
		}
		else if ( check_l ) 
		{
			
				ffl = C_FACE(cl,tl,3);
				tffl = C_FACE_THREAD(cl,tl,3);

				fal = C_FACE(cl,tl,1);
				tfal = C_FACE_THREAD(cl,tl,1);

				ffr = C_FACE(cr,tr,2);
				tffr = C_FACE_THREAD(cr,tr,2);

				far = C_FACE(cr,tr,0);
				tfar = C_FACE_THREAD(cr,tr,0);

			// ======================== (crf,trf) ============================= =

				crf = F_C0(ffr,tffr);
				if(crf == cr)
				{
					crf = F_C1(ffr,tffr);
					trf = F_C1_THREAD(ffr,tffr);
				}
				else
				{
					trf = F_C0_THREAD(ffr,tffr);
				}
	//			Message(" crf = %u \n ", crf);
			// ======================== (cra,tra) ============================= =

				cra = F_C0(far,tfar);
				if(cra == cr)
				{
					cra = F_C1(far,tfar);
					tra = F_C1_THREAD(far,tfar);
				}
				else
				{
					tra = F_C0_THREAD(far,tfar);
				}
	//			Message(" cra = %u \n ", cra);	
			// ======================== (clf,tlf) ============================= =

				clf = F_C0(ffl,tffl);
				if(clf == cl)
				{
					clf = F_C1(ffl,tffl);
					tlf = F_C1_THREAD(ffl,tffl);
				}
				else
				{
					tlf = F_C0_THREAD(ffl,tffl);
				}
	//			Message(" clf = %u \n ", clf);
			// ======================== (cla,tla) ============================= =

				cla = F_C0(fal,tfal);
				if(cla == cl)
				{
					cla = F_C1(fal,tfal);
					tla = F_C1_THREAD(fal,tfal);
				}
				else
				{
					tla = F_C0_THREAD(fal,tfal);
				}
	//			Message(" cla = %u \n ", cla);
		
			
		}
		else if ( check_a )
		{
			
				frm = C_FACE(ca,ta,1);
				tfrm = C_FACE_THREAD(ca,ta,1);

				flm = C_FACE(ca,ta,3);
				tflm = C_FACE_THREAD(ca,ta,3);

				frp = C_FACE(cf,tf,1);
				tfrp = C_FACE_THREAD(cf,tf,1);

				flp = C_FACE(cf,tf,3);
				tflp = C_FACE_THREAD(cf,tf,3);
			
			// ======================== (crf,trf) ============================= =

				crf = F_C0(frp,tfrp);
				if(crf == cr)
				{
					crf = F_C1(frp,tfrp);
					trf = F_C1_THREAD(frp,tfrp);
				}
				else
				{
					trf = F_C0_THREAD(frp,tfrp);
				}

			// ======================== (clf,tlf) ============================= =
				clf = F_C0(flp,tflp);
				if(clf == cl)
				{
					clf = F_C1(flp,tflp);
					tlf = F_C1_THREAD(flp,tflp);
				}
				else
				{
					tlf = F_C0_THREAD(flp,tflp);
				}

			// ======================== (cra,tra) ============================= =

				cra = F_C0(frm,tfrm);
				if(cra == cr)
				{
					cra = F_C1(frm,tfrm);
					tra = F_C1_THREAD(frm,tfrm);
				}
				else
				{
					tra = F_C0_THREAD(frm,tfrm);
				}

			// ======================== (cla,tla) ============================= =

				cla = F_C0(flm,tflm);
				if(cla == cl)
				{
					cla = F_C1(flm,tflm);
					tla = F_C1_THREAD(flm,tflm);
				}
				else
				{
					tla = F_C0_THREAD(flm,tflm);
				}
		}
		else
		{
		// ============== DEFINITION OF SECONDARY NEIGHBOURS ============== =

 
			ffr = C_FACE(cr,tr,2);
			tffr = C_FACE_THREAD(cr,tr,2);

			far = C_FACE(cr,tr,0);
			tfar = C_FACE_THREAD(cr,tr,0);

			ffl = C_FACE(cl,tl,2);
			tffl = C_FACE_THREAD(cl,tl,2);

			fal = C_FACE(cl,tl,0);
			tfal = C_FACE_THREAD(cl,tl,0);

//		Message("  far, tfar, ffl, tffl, fal, tfal =  %u %u %u %u %u %u  \n ", far, tfar, ffl, tffl, fal, tfal); 



		// ======================== (crf,trf) ============================= =

			crf = F_C0(ffr,tffr);
			if(crf == cr)
			{
				crf = F_C1(ffr,tffr);
				trf = F_C1_THREAD(ffr,tffr);
			}
			else
			{
				trf = F_C0_THREAD(ffr,tffr);
			}
//			Message(" crf = %u \n ", crf);
		// ======================== (cra,tra) ============================= =

		cra = F_C0(far,tfar);
			if(cra == cr)
			{
				cra = F_C1(far,tfar);
				tra = F_C1_THREAD(far,tfar);
			}
			else
			{
				tra = F_C0_THREAD(far,tfar);
			}
//			Message(" cra = %u \n ", cra);	
		// ======================== (clf,tlf) ============================= =

			clf = F_C0(ffl,tffl);
			if(clf == cl)
			{
				clf = F_C1(ffl,tffl);
				tlf = F_C1_THREAD(ffl,tffl);
			}
			else
			{
				tlf = F_C0_THREAD(ffl,tffl);
			}
//			Message(" clf = %u \n ", clf);
		// ======================== (cla,tla) ============================= =

			cla = F_C0(fal,tfal);
			if(cla == cl)
			{
				cla = F_C1(fal,tfal);
				tla = F_C1_THREAD(fal,tfal);
			}
			else
			{
				tla = F_C0_THREAD(fal,tfal);
			}
//			Message(" cla = %u \n ", cla);
			
			}

//	Message(" clf = %u \t cf = %u \t crf = %u \n ", clf, cf, crf);		
//	Message(" cl = %u  \t c  = %u \t cr  = %u \n ", cl, c, cr   );	
//	Message(" cla = %u \t ca = %u \t cra = %u \n ", cla, ca, cra);
//	Message(" tlf = %u \t tf = %u \t trf = %u \n ", tlf, tf, trf);		
//	Message(" tl = %u  \t t  = %u \t tr  = %u \n ", tl, t, tr   );	
//	Message(" tla = %u \t ta = %u \t tra = %u \n ", tla, ta, tra);
					

		}
			

		


	
			//	Message(" X[ND_ND] , Xr[ND_ND] = \n %g %g \n %g %g \n ", xi, X[1], Xr[0], Xr[1]);

		

										t_f = C_FACE_THREAD(c,t,0);

  										C_CENTROID(XC,c,t);
	

										if(BOUNDARY_FACE_THREAD_P(t_f))
										{


											    if( fequal(XC[0], 0.00001135) && (XC[1] > 0.00003405) && (XC[1] < 0.0022473)  )			// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to left boundary.)
												{
													C_CENTROID(X,c,t);
													C_CENTROID(Xr,cr,tr);
													C_CENTROID(Xf,cf,tf);
													C_CENTROID(Xa,ca,ta);
													C_CENTROID(Xrf,crf,trf);		
													C_CENTROID(Xra,cra,tra);

													NV_D(S11 , = , (Xf[0] - xi) , (Xf[1] - yi) , 0.0 );
													NV_D(S12 , = , (Xrf[0]  - xi) , (Xrf[1]  - yi) , 0.0 );
													NV_D(S21 , = , (X[0]  - xi) , (X[1]  - yi) , 0.0 );
													NV_D(S22 , = , (Xr[0]   - xi) , (Xr[1]   - yi) , 0.0 );
													NV_D(S31 , = , (Xa[0] - xi) , (Xa[1] - yi) , 0.0 );
													NV_D(S32 , = , (Xra[0]  - xi) , (Xra[1]  - yi) , 0.0 );
		
													SX[1][1] = (Xf[0] - xi);
													SX[1][2] = (Xrf[0]  - xi);
													SX[2][1] = (X[0]  - xi);
													SX[2][2] = (Xr[0]   - xi);
													SX[3][1] = (Xa[0] - xi);
													SX[3][2] = (Xra[0]  - xi);
	
													SY[1][1] = (Xf[1] - yi);
													SY[1][2] = (Xrf[1]  - yi);
													SY[2][1] = (X[1]  - yi);
													SY[2][2] = (Xr[1]   - yi);
													SY[3][1] = (Xa[1] - yi);
													SY[3][2] = (Xra[1]  - yi);

													DS[1][1] = sqrt(SX[1][1]*SX[1][1] + SY[1][1]*SY[1][1]) ;
													DS[1][2] = sqrt(SX[1][2]*SX[1][2] + SY[1][2]*SY[1][2]) ;
												//	DS[1][3] = sqrt(SX[1][3]*SX[1][3] + SY[1][3]*SY[1][3]) ;
													DS[2][1] = sqrt(SX[2][1]*SX[2][1] + SY[2][1]*SY[2][1]) ;
													DS[2][2] = sqrt(SX[2][2]*SX[2][2] + SY[2][2]*SY[2][2]) ;
												//	DS[2][3] = sqrt(SX[2][3]*SX[2][3] + SY[2][3]*SY[2][3]) ;
													DS[3][1] = sqrt(SX[3][1]*SX[3][1] + SY[3][1]*SY[3][1]) ;
													DS[3][2] = sqrt(SX[3][2]*SX[3][2] + SY[3][2]*SY[3][2]) ;
												//	DS[3][3] = sqrt(SX[3][3]*SX[3][3] + SY[3][3]*SY[3][3]) ;

													SX[1][1] /= DS[1][1];
													SX[1][2] /= DS[1][2];
													SX[2][1] /= DS[2][1];
													SX[2][2] /= DS[2][2];
													SX[3][1] /= DS[3][1];
													SX[3][2] /= DS[3][2];
	
													SY[1][1] /= DS[1][1];
													SY[1][2] /= DS[1][2];
													SY[2][1] /= DS[2][1];
													SY[2][2] /= DS[2][2];
													SY[3][1] /= DS[3][1];
													SY[3][2] /= DS[3][2];

													dot_prod[1][1] = -( SX[1][1]*n[0] + SY[1][1]*n[1] ) ;//NV_DOT( S[1][1] , n );
													dot_prod[1][2] = -( SX[1][2]*n[0] + SY[1][2]*n[1] ) ;//NV_DOT( S[1][2] , n );
													dot_prod[2][1] = -( SX[2][1]*n[0] + SY[2][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[2][2] = -( SX[2][2]*n[0] + SY[2][2]*n[1] ) ;//NV_DOT( S[2][2] , n );
													dot_prod[3][1] = -( SX[3][1]*n[0] + SY[3][1]*n[1] ) ;//NV_DOT( S[3][1] , n );
													dot_prod[3][2] = -( SX[3][2]*n[0] + SY[3][2]*n[1] ) ;//NV_DOT( S[3][2] , n );

													big = -1.0;
																for( rr = 1; rr <= 3; rr++)
																	for( cc = 1; cc <= 2; cc++)
																	{
																		if (dot_prod[rr][cc] > dot_prod[rr + 1][cc + 1])
																		{
																			big = dot_prod[rr][cc] *100000.0 ;
																			n_row = rr;
																			n_col = cc;
						
																			if(big != 0)
																			{
																	//			Message( " big, rr, cc = %g %d %d \n ", big, rr, cc);
																			}

																			if(rr == 1 && cc == 1)
																			{
																				cs = cf;
																				ts = tf;
																			}
																			else if(rr == 1 && cc == 2)
																			{
																				cs = crf;
																				ts = trf;
																			}
																			else if(rr == 2 && cc == 1)
																			{
																				cs = c;
																				ts = t;
																			}
																			else if(rr == 2 && cc == 2)
																			{
																				cs = cr;
																				ts = tr;
																			}
																			else if(rr == 3 && cc == 1)
																			{
																				cs = ca;
																				ts = ta;
																			}
																			else if(rr == 3 && cc == 2)
																			{
																				cs = cra;
																				ts = tra;
																			}

																		}
																		else
																		{
																			big = big;
																			n_row = n_row ;
																			n_col = n_col ;
																			cs = cs;
																			ts = ts;


																		}
																	}
														Message(" LHS n_row, n_col = %d %d \n ", n_row, n_col );
												}
												else if( fequal(XC[0], 0.00112365) && (XC[1] > 0.00003405) && (XC[1] < 0.0022473)  )			// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to right boundary.)
												{
													C_CENTROID(X,c,t);
													C_CENTROID(Xf,cf,tf);
													C_CENTROID(Xl,cl,tl);		 
													C_CENTROID(Xa,ca,ta);
													C_CENTROID(Xlf,clf,tlf);
													C_CENTROID(Xla,cla,tla);		

													SX[1][1] = (X[0] - xi);
													SX[1][2] = (Xf[0]  - xi);
													SX[2][1] = (Xl[0]  - xi);
													SX[2][2] = (Xa[0]   - xi);
													SX[3][1] = (Xlf[0] - xi);
													SX[3][2] = (Xla[0]  - xi);
	
													SY[1][1] = (X[1] - yi);
													SY[1][2] = (Xf[1]  - yi);
													SY[2][1] = (Xl[1]  - yi);
													SY[2][2] = (Xa[1]   - yi);
													SY[3][1] = (Xlf[1] - yi);
													SY[3][2] = (Xla[1]  - yi);

													DS[1][1] = sqrt(SX[1][1]*SX[1][1] + SY[1][1]*SY[1][1]) ;
													DS[1][2] = sqrt(SX[1][2]*SX[1][2] + SY[1][2]*SY[1][2]) ;
												//	DS[1][3] = sqrt(SX[1][3]*SX[1][3] + SY[1][3]*SY[1][3]) ;
													DS[2][1] = sqrt(SX[2][1]*SX[2][1] + SY[2][1]*SY[2][1]) ;
													DS[2][2] = sqrt(SX[2][2]*SX[2][2] + SY[2][2]*SY[2][2]) ;
												//	DS[2][3] = sqrt(SX[2][3]*SX[2][3] + SY[2][3]*SY[2][3]) ;
													DS[3][1] = sqrt(SX[3][1]*SX[3][1] + SY[3][1]*SY[3][1]) ;
													DS[3][2] = sqrt(SX[3][2]*SX[3][2] + SY[3][2]*SY[3][2]) ;
												//	DS[3][3] = sqrt(SX[3][3]*SX[3][3] + SY[3][3]*SY[3][3]) ;

													SX[1][1] /= DS[1][1];
													SX[1][2] /= DS[1][2];
													SX[2][1] /= DS[2][1];
													SX[2][2] /= DS[2][2];
													SX[3][1] /= DS[3][1];
													SX[3][2] /= DS[3][2];
	
													SY[1][1] /= DS[1][1];
													SY[1][2] /= DS[1][2];
													SY[2][1] /= DS[2][1];
													SY[2][2] /= DS[2][2];
													SY[3][1] /= DS[3][1];
													SY[3][2] /= DS[3][2];

													dot_prod[1][1] = -( SX[1][1]*n[0] + SY[1][1]*n[1] ) ;//NV_DOT( S[1][1] , n );
													dot_prod[1][2] = -( SX[1][2]*n[0] + SY[1][2]*n[1] ) ;//NV_DOT( S[1][2] , n );
													dot_prod[2][1] = -( SX[2][1]*n[0] + SY[2][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[2][2] = -( SX[2][2]*n[0] + SY[2][2]*n[1] ) ;//NV_DOT( S[2][2] , n );
													dot_prod[3][1] = -( SX[3][1]*n[0] + SY[3][1]*n[1] ) ;//NV_DOT( S[3][1] , n );
													dot_prod[3][2] = -( SX[3][2]*n[0] + SY[3][2]*n[1] ) ;//NV_DOT( S[3][2] , n );

													big = 0.0;

																for( rr = 1; rr <= 3; rr++)
																	for( cc = 1; cc <= 2; cc++)
																	{
																		if (dot_prod[rr][cc] > big )
																		{
																			big = dot_prod[rr][cc] ;
																			n_row = rr;
																			n_col = cc;
						
																			if(big != 0)
																			{
																	//			Message( " big, rr, cc = %g %d %d \n ", big, rr, cc);
																			}

																			if(rr == 1 && cc == 1)
																			{
																				cs = clf;
																				ts = tlf;
																			}
																			else if(rr == 1 && cc == 2)
																			{
																				cs = cf;
																				ts = tf;
																			}
																			else if(rr == 2 && cc == 1)
																			{
																				cs = cl;
																				ts = tl;
																			}
																			else if(rr == 2 && cc == 2)
																			{
																				cs = c;
																				ts = t;
																			}
																			else if(rr == 3 && cc == 1)
																			{
																				cs = cla;
																				ts = tla;
																			}
																			else if(rr == 3 && cc == 2)
																			{
																				cs = ca;
																				ts = ta;
																			}

																		}
																		else
																		{
																			big = big;
																			n_row = n_row ;
																			n_col = n_col ;
																			cs = cs;
																			ts = ts;


																		}
																	}
														Message(" RHS n_row, n_col = %d %d \n ", n_row, n_col );

												}
												else if( fequal(XC[1], 0.00001135) && (XC[0] > 0.0000227) && (XC[0] < 0.00112365) )// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to bottom boundary.)
												{
													C_CENTROID(X,c,t);
													C_CENTROID(Xr,cr,tr);
													C_CENTROID(Xf,cf,tf);
													C_CENTROID(Xl,cl,tl);
													C_CENTROID(Xrf,crf,trf);
													C_CENTROID(Xlf,clf,tlf);
								
													SX[1][1] = (Xlf[0] - xi);
													SX[1][2] = (Xf[0]  - xi);
													SX[1][3] = (Xrf[0] - xi);
													SX[2][1] = (Xl[0]  - xi);
													SX[2][2] = (X[0]   - xi);
													SX[2][3] = (Xr[0]  - xi);
	
													SY[1][1] = (Xlf[1] - yi);
													SY[1][2] = (Xf[1]  - yi);
													SY[1][3] = (Xrf[1] - yi);
													SY[2][1] = (Xl[1]  - yi);
													SY[2][2] = (X[1]   - yi);
													SY[2][3] = (Xr[1]  - yi);


													DS[1][1] = sqrt(SX[1][1]*SX[1][1] + SY[1][1]*SY[1][1]) ;
													DS[1][2] = sqrt(SX[1][2]*SX[1][2] + SY[1][2]*SY[1][2]) ;
													DS[1][3] = sqrt(SX[1][3]*SX[1][3] + SY[1][3]*SY[1][3]) ;
													DS[2][1] = sqrt(SX[2][1]*SX[2][1] + SY[2][1]*SY[2][1]) ;
													DS[2][2] = sqrt(SX[2][2]*SX[2][2] + SY[2][2]*SY[2][2]) ;
													DS[2][3] = sqrt(SX[2][3]*SX[2][3] + SY[2][3]*SY[2][3]) ;
												//	DS[3][1] = sqrt(SX[3][1]*SX[3][1] + SY[3][1]*SY[3][1]) ;
												//	DS[3][2] = sqrt(SX[3][2]*SX[3][2] + SY[3][2]*SY[3][2]) ;
												//	DS[3][3] = sqrt(SX[3][3]*SX[3][3] + SY[3][3]*SY[3][3]) ;

													SX[1][1] /= DS[1][1];
													SX[1][2] /= DS[1][2];
													SX[1][3] /= DS[1][3];
													SX[2][1] /= DS[2][1];
													SX[2][2] /= DS[2][2];
													SX[2][3] /= DS[2][3];											
											
	
													SY[1][1] /= DS[1][1];
													SY[1][2] /= DS[1][2];
													SY[1][3] /= DS[1][3];
													SY[2][1] /= DS[2][1];
													SY[2][2] /= DS[2][2];
													SY[2][3] /= DS[2][3];											

													dot_prod[1][1] = -( SX[1][1]*n[0] + SY[1][1]*n[1] ) ;//NV_DOT( S[1][1] , n );
													dot_prod[1][2] = -( SX[1][2]*n[0] + SY[1][2]*n[1] ) ;//NV_DOT( S[1][2] , n );
													dot_prod[1][3] = -( SX[1][3]*n[0] + SY[1][3]*n[1] ) ;//NV_DOT( S[3][1] , n );
													dot_prod[2][1] = -( SX[2][1]*n[0] + SY[2][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[2][2] = -( SX[2][2]*n[0] + SY[2][2]*n[1] ) ;//NV_DOT( S[2][2] , n );
													dot_prod[2][3] = -( SX[2][3]*n[0] + SY[2][3]*n[1] ) ;//NV_DOT( S[3][2] , n );	

													

													big = -1.0;
													for( rr = 1; rr <= 2; rr++)
														for( cc = 1; cc <= 3; cc++)
														{
															if (dot_prod[rr][cc] > big)
															{
																big = dot_prod[rr][cc]  ;
																n_row = rr;
																n_col = cc;
						
																if(big != 0)
																{
														//			Message( " big, rr, cc = %g %d %d \n ", big, rr, cc);
																}

																if(rr == 1 && cc == 1)
																{
																	cs = clf;
																	ts = tlf;
																}
																else if(rr == 1 && cc == 2)
																{
																	cs = cf;
																	ts = tf;
																}
																else if(rr == 1 && cc == 3)
																{
																	cs = crf;
																	ts = trf;
																}
																else if(rr == 2 && cc == 1)
																{
																	cs = cl;
																	ts = tl;
																}
																else if(rr == 2 && cc == 2)
																{
																	cs = c;
																	ts = t;
																}
																else if(rr == 2 && cc == 3)
																{
																	cs = cr;
																	ts = tr;
																}

															}
															else
															{
																big = big;
																n_row = n_row;
																n_col = n_col;
																cs = cs;
																ts = ts;
										
															}
														}
													Message(" B.B n_row, n_col = %d %d \n ", n_row, n_col );
												}
												else if( fequal(XC[1], 0.00225865) && (XC[0] > 0.0000227) && (XC[0] < 0.00112365) )					// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to top boundary.)
												{
													C_CENTROID(X,c,t);
													C_CENTROID(Xr,cr,tr);
													C_CENTROID(Xl,cl,tl);		 
													C_CENTROID(Xa,ca,ta);
													C_CENTROID(Xla,cla,tla);				
													C_CENTROID(Xra,cra,tra);
											
													SX[1][1] = (Xl[0] - xi);
													SX[1][2] = (X[0]  - xi);
													SX[1][3] = (Xr[0] - xi);
													SX[2][1] = (Xla[0]  - xi);
													SX[2][2] = (Xa[0]   - xi);
													SX[2][3] = (Xra[0]  - xi);
	
													SY[1][1] = (Xl[1] - yi);
													SY[1][2] = (X[1]  - yi);
													SY[1][3] = (Xr[1] - yi);
													SY[2][1] = (Xla[1]  - yi);
													SY[2][2] = (Xa[1]   - yi);
													SY[2][3] = (Xra[1]  - yi);


													DS[1][1] = sqrt(SX[1][1]*SX[1][1] + SY[1][1]*SY[1][1]) ;
													DS[1][2] = sqrt(SX[1][2]*SX[1][2] + SY[1][2]*SY[1][2]) ;
													DS[1][3] = sqrt(SX[1][3]*SX[1][3] + SY[1][3]*SY[1][3]) ;
													DS[2][1] = sqrt(SX[2][1]*SX[2][1] + SY[2][1]*SY[2][1]) ;
													DS[2][2] = sqrt(SX[2][2]*SX[2][2] + SY[2][2]*SY[2][2]) ;
													DS[2][3] = sqrt(SX[2][3]*SX[2][3] + SY[2][3]*SY[2][3]) ;
												//	DS[3][1] = sqrt(SX[3][1]*SX[3][1] + SY[3][1]*SY[3][1]) ;
												//	DS[3][2] = sqrt(SX[3][2]*SX[3][2] + SY[3][2]*SY[3][2]) ;
												//	DS[3][3] = sqrt(SX[3][3]*SX[3][3] + SY[3][3]*SY[3][3]) ;

													SX[1][1] /= DS[1][1];
													SX[1][2] /= DS[1][2];
													SX[1][3] /= DS[1][3];
													SX[2][1] /= DS[2][1];
													SX[2][2] /= DS[2][2];
													SX[2][3] /= DS[2][3];											
											
	
													SY[1][1] /= DS[1][1];
													SY[1][2] /= DS[1][2];
													SY[1][3] /= DS[1][3];
													SY[2][1] /= DS[2][1];
													SY[2][2] /= DS[2][2];
													SY[2][3] /= DS[2][3];											

													dot_prod[1][1] = -( SX[1][1]*n[0] + SY[1][1]*n[1] ) ;//NV_DOT( S[1][1] , n );
													dot_prod[1][2] = -( SX[1][2]*n[0] + SY[1][2]*n[1] ) ;//NV_DOT( S[1][2] , n );
													dot_prod[1][3] = -( SX[1][3]*n[0] + SY[1][3]*n[1] ) ;//NV_DOT( S[3][1] , n );
													dot_prod[2][1] = -( SX[2][1]*n[0] + SY[2][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[2][2] = -( SX[2][2]*n[0] + SY[2][2]*n[1] ) ;//NV_DOT( S[2][2] , n );
													dot_prod[2][3] = -( SX[2][3]*n[0] + SY[2][3]*n[1] ) ;//NV_DOT( S[3][2] , n );	

													big = -1.0;

													for( rr = 1; rr <= 2; rr++)
														for( cc = 1; cc <= 3; cc++)
														{
															if (dot_prod[rr][cc] > big)
															{
																big = dot_prod[rr][cc]  ;
																n_row = rr;
																n_col = cc;
						
																if(big != 0)
																{
														//			Message( " big, rr, cc = %g %d %d \n ", big, rr, cc);
																}

																if(rr == 1 && cc == 1)
																{
																	cs = cl;
																	ts = tl;
																}
																else if(rr == 1 && cc == 2)
																{
																	cs = c;
																	ts = t;
																}
																else if(rr == 1 && cc == 3)
																{
																	cs = cr;
																	ts = tr;
																}
																else if(rr == 2 && cc == 1)
																{
																	cs = cla;
																	ts = tla;
																}
																else if(rr == 2 && cc == 2)
																{
																	cs = ca;
																	ts = ta;
																}
																else if(rr == 2 && cc == 3)
																{
																	cs = cra;
																	ts = tra;
																}

															}
															else
															{
																big = big ;
																n_row = n_row;
																n_col = n_col;
																cs = cs;
																ts = ts;
										
															}
														}
													Message(" T.B n_row, n_col = %d %d \n ", n_row, n_col );
												}	
										//		else
										//		{
										//			return 0.0;
										//		}

												
										}
										else								// PLEASE NOTE : THIS WILL REMAIN SAME FOR ALL GEOMETRIES. This part is for interior cells other than cells at boundaries.
										{		
														C_CENTROID(X,c,t);
														C_CENTROID(Xr,cr,tr);
														C_CENTROID(Xf,cf,tf);
														C_CENTROID(Xl,cl,tl);		 
														C_CENTROID(Xa,ca,ta);
														C_CENTROID(Xrf,crf,trf);		
														C_CENTROID(Xlf,clf,tlf);
														C_CENTROID(Xla,cla,tla);				
														C_CENTROID(Xra,cra,tra);

//														Message(" X (clf, cf, crf, cl, c, cr, cla, ca, cra) =  %.10f %.10f %.10f \n %.10f %.10f %.10f \n %.10f %.10f %.10f \n ", Xlf[0], Xf[0], Xrf[0], Xl[0], X[0], Xr[0], Xla[0], Xa[0], Xra[0]);
//														Message(" Y (clf, cf, crf, cl, c, cr, cla, ca, cra) =  %.10f %.10f %.10f \n %.10f %.10f %.10f \n %.10f %.10f %.10f \n ", Xlf[1], Xf[1], Xrf[1], Xl[1], X[1], Xr[1], Xla[1], Xa[1], Xra[1]);
//														Message(" xi, yi = %.10f %.10f \n ", xi, yi );
//														Message(" iphase = \n %f %f %f \n %f %f %f \n %f %f %f \n ", C_UDMI(clf,tlf,1),C_UDMI(cf,tf,1),C_UDMI(crf,trf,1),C_UDMI(cl,tl,1),C_UDMI(c,t,1),C_UDMI(cr,tr,1),C_UDMI(cla,tla,1),C_UDMI(ca,ta,1),C_UDMI(cra,tra,1));

														SX[1][1] = (Xlf[0] - xi);
														SX[1][2] = (Xf[0]  - xi);
														SX[1][3] = (Xrf[0] - xi);
														SX[2][1] = (Xl[0]  - xi);
														SX[2][2] = 0.0 ; // (X[0] -xi); // 0.0;
														SX[2][3] = (Xr[0]  - xi);
														SX[3][1] = (Xla[0] - xi);
														SX[3][2] = (Xa[0]  - xi);
														SX[3][3] = (Xra[0] - xi);

//														Message(" SX Matrix = \n %g %g %g \n %g %g %g \n %g %g %g \n ", SX[1][1],SX[1][2],SX[1][3],SX[2][1],SX[2][2],SX[2][3],SX[3][1],SX[3][2],SX[3][3]);

														SY[1][1] = (Xlf[1] - yi);
														SY[1][2] = (Xf[1]  - yi);
														SY[1][3] = (Xrf[1] - yi);
														SY[2][1] = (Xl[1]  - yi);
														SY[2][2] = 0.0; // (X[1] - yi); // 0.0;
														SY[2][3] = (Xr[1]  - yi);
														SY[3][1] = (Xla[1] - yi);
														SY[3][2] = (Xa[1]  - yi);
														SY[3][3] = (Xra[1] - yi);

//														Message(" SY Matrix = \n %g %g %g \n %g %g %g \n %g %g %g \n ", SY[1][1],SY[1][2],SY[1][3],SY[2][1],SY[2][2],SY[2][3],SY[3][1],SY[3][2],SY[3][3]);

													DS[1][1] = sqrt(SX[1][1]*SX[1][1] + SY[1][1]*SY[1][1]) ;
													DS[1][2] = sqrt(SX[1][2]*SX[1][2] + SY[1][2]*SY[1][2]) ;
													DS[1][3] = sqrt(SX[1][3]*SX[1][3] + SY[1][3]*SY[1][3]) ;
													DS[2][1] = sqrt(SX[2][1]*SX[2][1] + SY[2][1]*SY[2][1]) ;
													DS[2][2] = 0.0 ; // sqrt(SX[2][2]*SX[2][2] + SY[2][2]*SY[2][2]) ; 
													DS[2][3] = sqrt(SX[2][3]*SX[2][3] + SY[2][3]*SY[2][3]) ;
													DS[3][1] = sqrt(SX[3][1]*SX[3][1] + SY[3][1]*SY[3][1]) ;
													DS[3][2] = sqrt(SX[3][2]*SX[3][2] + SY[3][2]*SY[3][2]) ;
													DS[3][3] = sqrt(SX[3][3]*SX[3][3] + SY[3][3]*SY[3][3]) ;

													SX[1][1] /= DS[1][1];
													SX[1][2] /= DS[1][2];
													SX[1][3] /= DS[1][3];
													SX[2][1] /= DS[2][1];
													SX[2][2] = 0.0; 
													SX[2][3] /= DS[2][3];											
													SX[3][1] /= DS[3][1];
													SX[3][2] /= DS[3][2];
													SX[3][3] /= DS[3][3];												
	
													SY[1][1] /= DS[1][1];
													SY[1][2] /= DS[1][2];
													SY[1][3] /= DS[1][3];
													SY[2][1] /= DS[2][1];
													SY[2][2] = 0.0; 
													SY[2][3] /= DS[2][3];
													SY[3][1] /= DS[3][1];
													SY[3][2] /= DS[3][2];
													SY[3][3] /= DS[3][3];												

										

													dot_prod[1][1] = -( SX[1][1]*n[0] + SY[1][1]*n[1] ) ;//NV_DOT( S[1][1] , n );
													dot_prod[1][2] = -( SX[1][2]*n[0] + SY[1][2]*n[1] ) ;//NV_DOT( S[1][2] , n );
													dot_prod[1][3] = -( SX[1][3]*n[0] + SY[1][3]*n[1] ) ;//NV_DOT( S[3][1] , n );
													dot_prod[2][1] = -( SX[2][1]*n[0] + SY[2][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[2][2] = 0.0; //-( SX[2][2]*n[0] + SY[2][2]*n[1] ) ;//NV_DOT( S[2][2] , n );
													dot_prod[2][3] = -( SX[2][3]*n[0] + SY[2][3]*n[1] ) ;//NV_DOT( S[3][2] , n );	
													dot_prod[3][1] = -( SX[3][1]*n[0] + SY[3][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[3][2] = -( SX[3][2]*n[0] + SY[3][2]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[3][3] = -( SX[3][3]*n[0] + SY[3][3]*n[1] ) ;//NV_DOT( S[2][1] , n );
		
//			Message(" c, C_UDMI(c,t,1), n[0], n[1], DOT PROD = %u %f %.15f %.15f \n %g %g %g \n %g %g %g \n %g %g %g \n ", c, C_UDMI(c,t,1), n[0], n[1], dot_prod[1][1],dot_prod[1][2],dot_prod[1][3],dot_prod[2][1],dot_prod[2][2],dot_prod[2][3],dot_prod[3][1],dot_prod[3][2],dot_prod[3][3]);

	
													//	big = 0.0;
	
														big = -1.0;
	
														for( rr = 1; rr <= 3; rr++)
															for( cc = 1; cc <= 3; cc++)
															{
													//			Message("rr,cc= %d %d \n", rr, cc);

																if (dot_prod[rr][cc] > big)
																{
																	big = dot_prod[rr][cc] ;
																	n_row = rr;
																	n_col = cc;
						
																	if(big != 0.0)
																	{
															//			Message( " big, rr, cc = %g %d %d \n ", big, rr, cc);
																	}

																	if(rr == 1 && cc == 1)
																	{
																		cs = clf;
																		ts = tlf;
																	}
																	else if(rr == 1 && cc == 2)
																	{
																		cs = cf;
																		ts = tf;
																	}
																	else if(rr == 1 && cc == 3)
																	{
																		cs = crf;
																		ts = trf;
																	}
																	else if(rr == 2 && cc == 1)
																	{
																		cs = cl;
																		ts = tl;
																	}
																	else if(rr == 2 && cc == 2)
																	{
																		cs = c;
																		ts = t;
																	}
																	else if(rr == 2 && cc == 3)
																	{
																		cs = cr;
																		ts = tr;
																	}
																	else if(rr == 3 && cc == 1)
																	{
																		cs = cla;
																		ts = tla;
																	}
																	else if(rr == 3 && cc == 2)
																	{
																		cs = ca;
																		ts = ta;
																	}
																	else if(rr == 3 && cc == 3)
																	{
																		cs = cra;
																		ts = tra;
																	}
																}
																else
																{
																	big = big;
																	n_row = n_row;
																	n_col = n_col;
																	cs = cs;
																	ts = ts;

																}


															}
										//		Message(" c, n_row, n_col = %u %d %d \n ", c, n_row, n_col );

									}

//								Message(" c, n_row, n_col = %u %d %d \n ", c, n_row, n_col );

		if( n_row == 0 || n_col == 0 || n_row > 3 || n_col > 3 )
		{
			return  0.0;
		}
		else
		{
									sx = SX[n_row][n_col];
									sy = SY[n_row][n_col];
									ds = DS[n_row][n_col];	// sqrt(sx*sx + sy*sy); 
								//	sx = sx/ds;
								//	sy = sy/ds;

//			NV_D(s , = , SX[n_row][n_col] , SY[n_row][n_col] , 0.0 );

			kl = 0.5454;
			kg = 0.5383;
			keff = kl*C_VOF(c,t_liquid) + kg*C_VOF(c,t_vapour);

			latent_heat = 276400.0;

//			ds = NV_MAG(s);
			


			if ( fequal(ds , 0.0) )
			{
				source = 0.0;
			}
			else
			{
//				NV_VS(q_s, = , s , * , (kl*(TSAT - C_T(cs,ts))/ds) );

//				q_n = NV_DOT(q_s , n);
//			C_CENTROID(XCS, cs, ts);
//			C_CENTROID(XC,c,t);
//			Message(" c, cs, C_UDMI(cs,ts,1) , C_UDMI(c,t,1) = %u %u %f %f \n ", c, cs, C_UDMI(cs,t,1) , C_UDMI(c,t,1) );
				q_n = sx*(kl*(TSAT - C_T(cs,t))/ds)*C_VOF_RG(c,t_liquid)[0] + sy*(kl*(TSAT - C_T(cs,t))/ds)*C_VOF_RG(c,t_liquid)[1] ; 
				source =  fabs(q_n / latent_heat ) ; 
//			Message("c, ds, C_T(cs,t), source  = %u %f %f %g \n ", c, ds, C_T(cs,t), source );
//				C_UDMI(c,t,6) = source;
			}			

			dS[eqn] = 0.0;
	//		Message(" c, source = %u %g  \n ", c, source );
	//		Message("last = %f %f %g %g %g %.20f \n ", SX[n_row][n_col], SY[n_row][n_col] , q_n, ((kl*(TSAT - C_T(cs,ts))/ds)/latent_heat) , ds , source );
			return    source;		
		}
		
			
	
	}
	else
	{
		return 0.0;
	}
}

DEFINE_SOURCE(energy_source, c, t, dS, eqn)
{
	Thread *t_liquid = THREAD_SUB_THREAD(t,0);
	Thread *t_vapour = THREAD_SUB_THREAD(t,1);
	cell_t cs; 
	Thread *ts;
	
	/* =============== DECLARATION OF NEIGHBOURING CELL ID'S AND THREAD'S ================= */
	cell_t cr, cf, cl, ca, crf, cra, clf, cla ;
	Thread *tf, *ta, *tr, *tl, *trf, *tra, *tlf, *tla ;

	face_t fr,ff,fl,fa,ffr,far,ffl,fal,frp,flp,frm,flm;
	Thread *tfr, *tff, *tfl, *tfa, *tffr, *tfar, *tffl, *tfal, *tfrp, *tflp, *tfrm, *tflm;

	face_t f;
	Thread *t_f;
	Thread *t_fr, *t_ff, *t_fl, *t_fa;
	Node *node;
	int a;
	/* ------------------------------------------------------------------------------------ */
	cell_t CELL[3][3];
	Thread *THREAD[3][3];
	float NV_VEC(S11), NV_VEC(S12), NV_VEC(S13), NV_VEC(S21), NV_VEC(S22), NV_VEC(S23), NV_VEC(S31), NV_VEC(S32), NV_VEC(S33);
	
	float SX[3][3], SY[3][3], DS[3][3];

	float source;

	float NV_VEC(n), NV_VEC(s), NV_VEC(sr), NV_VEC(sf), NV_VEC(sl), NV_VEC(sa), NV_VEC(srf), NV_VEC(slf), NV_VEC(sla), NV_VEC(sra), sx , sy ;
	real  xl , xr , ya , yf; 
	float XR[ND_ND], XF[ND_ND], XL[ND_ND], XA[ND_ND] , xi , yi , xis , yis;
	real nx,ny,xint1, xint2 , yint1, yint2;
	float X[ND_ND], Xr[ND_ND], Xf[ND_ND], Xl[ND_ND], Xa[ND_ND], Xrf[ND_ND], Xlf[ND_ND], Xla[ND_ND], Xra[ND_ND], XC[ND_ND], XCS[ND_ND];
	real xcf[ND_ND],xca[ND_ND], xcr[ND_ND], xcl[ND_ND] ;
	real *ptl, *ptr, *pta, *ptf ;
	real xci[ND_ND];
	int N;
	int iface_int1, iface_int2;
	int iphs;
	float NV_VEC(q_s), q_n , ds , kl , kg, keff, latent_heat;
	float XS[ND_ND];
	int ii,jj;
	int rr, cc, n_row, n_col ;
	float dot_prod[3][3] , S[3][3]  ;
	float big;
	real ax, ay, bx, by;
	FILE *fp;
	char name[50];

	real dx,dy;
	real len, voll ;
	real sourcl, sourcv, tempn;
	
	real distance;
	
	cxboolean check_r ;
	cxboolean check_f ;
	cxboolean check_l ;
	cxboolean check_a ;
	cxboolean boundary;

	check_r = FALSE;
	check_f = FALSE;
	check_l = FALSE;
	check_a = FALSE;
	
	iphs = C_UDMI(c,t,1); //iphase[c];
	n[0] = C_UDMI(c,t,2); //nx;
	n[1] = C_UDMI(c,t,3); //ny;	

//	

if (iphs == 2 )
{

	t_f = C_FACE_THREAD(c,t,0);

  		C_CENTROID(XC,c,t);
//	Message(" iphs, n[0], n[1] = %d %f %f \n ", iphs, n[0], n[1] );

	if(BOUNDARY_FACE_THREAD_P(t_f))
	{													


					// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to left boundary.)
					if( fequal(XC[0], 0.00001135) && (XC[1] > 0.00003405) && (XC[1] < 0.0022473)  )
					{
						ff = C_FACE(c,t,3);					
						tff = C_FACE_THREAD(c,t,3);
						fa = C_FACE(c,t,1);
						tfa = C_FACE_THREAD(c,t,1);
							fr = C_FACE(c,t,2);
							tfr = C_FACE_THREAD(c,t,2);	
							fl = C_FACE(c,t,0);
							tfl = C_FACE_THREAD(c,t,0);	
							
//=====================================================================================================================================
							F_CENTROID(XR,fr,tfr);
							F_CENTROID(XF,ff,tff);
							F_CENTROID(XL,fl,tfl);
							F_CENTROID(XA,fa,tfa);

							xr = XR[0] ;
							yf = XF[1] ;
							xl = XL[0] ;
							ya = XA[1] ;

						// ================ GTM FUNCTION CALL =================== 

							delta(c,t, &dx, &dy); 
							nx = C_UDMI(c,t,2);
							ny = C_UDMI(c,t,3);
	
							linseg(c, t_liquid, xl, xr, ya, yf, &xint1, &xint2, &yint1, &yint2, &iface_int1, &iface_int2);
							lgvol( c, t_liquid, xl, xr, ya, yf, &voll );

						// =============== DEFINITION OF N-VECTOR ================ 

				//			n[0]  =  nx; 
				//			n[1]  =  ny;

						// =============== MODIFIED DEFINITION OF S-VECTOR ================ 


						if(xint1 > xint2)
						{
							xi = xint2 + fabs((xint1 - xint2)/2.0) ;
						}
						else
						{
							xi = xint1 + fabs((xint1 - xint2)/2.0) ;
						}

						if(yint1 > yint2)
						{
							yi = yint2 + fabs((yint1 - yint2)/2.0) ;								
						}
						else
						{
							yi = yint1 + fabs((yint1 - yint2)/2.0) ;								
						}							

//============================================================================================================================================						


					// ----------- FRONT FACE ------------ 

						cf = F_C0(ff,tff);
						if(cf == c)
						{
							cf = F_C1(ff,tff);
							tf = F_C1_THREAD(ff,tff);
						}
						else
						{
							tf = F_C0_THREAD(ff,tff);
						}
						
						// ----------- RIGHT FACE ----------- 

							cr = F_C0(fr,tfr);
							if(cr == c)
							{
								cr = F_C1(fr,tfr);
								tr = F_C1_THREAD(fr,tfr);
							}
							else
							{
								tr = F_C0_THREAD(fr,tfr);
							}   

					// ------------ AFTER FACE ------------ 

						ca = F_C0(fa,tfa);
						if(ca == c)
						{
							ca = F_C1(fa,tfa);
							ta = F_C1_THREAD(fa,tfa);
						}
						else
						{
							ta = F_C0_THREAD(fa,tfa);
						}

						C_CENTROID(xcf,cf,tf);
						C_CENTROID(xca,ca,ta);

							if ( fequal( xcf[1], 0.00225865 ) )
							{
								return 0.0;							
							}
							else if ( fequal(xca[1],0.00001135) )
							{
								return 0.0;
							}
							else
							{
									frm = C_FACE(ca,ta,2);
									tfrm = C_FACE_THREAD(ca,ta,2);

									frp = C_FACE(cf,tf,2);
									tfrp = C_FACE_THREAD(cf,tf,2);
			
								// ======================== (crf,trf) ============================= 

									crf = F_C0(frp,tfrp);
									if(crf == cr)
									{
										crf = F_C1(frp,tfrp);
										trf = F_C1_THREAD(frp,tfrp);
									}
									else
									{
										trf = F_C0_THREAD(frp,tfrp);
									}


								// ======================== (cra,tra) ============================= 

									cra = F_C0(frm,tfrm);
									if(cra == cr)
									{
										cra = F_C1(frm,tfrm);
										tra = F_C1_THREAD(frm,tfrm);
									}
									else
									{
										tra = F_C0_THREAD(frm,tfrm);
									}
							}
//			Message(" cf = %u \t crf = %u \n ", cf, crf);		
//			Message(" c  = %u \t cr  = %u \n ", c, cr   );	
//			Message(" ca = %u \t cra = %u \n ", ca, cra);

					}

					// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to right boundary.)
				    else if( fequal(XC[0], 0.00112365) && (XC[1] > 0.00003405) && (XC[1] < 0.0022473)  )
					{
						ff = C_FACE(c,t,1);					
						tff = C_FACE_THREAD(c,t,1);
						fa = C_FACE(c,t,3);
						tfa = C_FACE_THREAD(c,t,3);
						fl = C_FACE(c,t,2);
						tfl = C_FACE_THREAD(c,t,2);	
						fr = C_FACE(c,t,0);
						tfr = C_FACE_THREAD(c,t,0);	
					
			//			Message(" HI I am Right \n");

//=========================================================================================================================================
							F_CENTROID(XR,fr,tfr);
							F_CENTROID(XF,ff,tff);
							F_CENTROID(XL,fl,tfl);
							F_CENTROID(XA,fa,tfa);

							xr = XR[0] ;
							yf = XF[1] ;
							xl = XL[0] ;
							ya = XA[1] ;

						// ================ GTM FUNCTION CALL =================== 

							delta(c,t, &dx, &dy); 
							nx = C_UDMI(c,t,2);
							ny = C_UDMI(c,t,3);
	
							linseg(c, t_liquid, xl, xr, ya, yf, &xint1, &xint2, &yint1, &yint2, &iface_int1, &iface_int2);
							lgvol( c, t_liquid, xl, xr, ya, yf, &voll );

						// =============== DEFINITION OF N-VECTOR ================ 

				//			n[0]  =  nx; 
				//			n[1]  =  ny;

						// =============== MODIFIED DEFINITION OF S-VECTOR ================ 


						if(xint1 > xint2)
						{
							xi = xint2 + fabs((xint1 - xint2)/2.0) ;
						}
						else
						{
							xi = xint1 + fabs((xint1 - xint2)/2.0) ;
						}

						if(yint1 > yint2)
						{
							yi = yint2 + fabs((yint1 - yint2)/2.0) ;								
						}
						else
						{
							yi = yint1 + fabs((yint1 - yint2)/2.0) ;								
						}			

//============================================================================================================================================

							// ----------- FRONT FACE ------------ 

								cf = F_C0(ff,tff);
								if(cf == c)
								{
									cf = F_C1(ff,tff);
									tf = F_C1_THREAD(ff,tff);
								}
								else
								{
									tf = F_C0_THREAD(ff,tff);
								}

					// ----------- LEFT FACE ------------ 

							cl = F_C0(fl,tfl);
							if(cl == c)
							{
								cl = F_C1(fl,tfl);
								tl = F_C1_THREAD(fl,tfl);
							}
							else
							{
								tl = F_C0_THREAD(fl,tfl);
							}


							// ------------ AFTER FACE ------------ 

								ca = F_C0(fa,tfa);
								if(ca == c)
								{
									ca = F_C1(fa,tfa);
									ta = F_C1_THREAD(fa,tfa);
								}
								else
								{
									ta = F_C0_THREAD(fa,tfa);
								}

						C_CENTROID(xcf,cf,tf);
						C_CENTROID(xca,ca,ta);

							if ( fequal( xcf[1], 0.00225865 ) )
							{
								return 0.0;			
							}
							else if ( fequal(xca[1],0.00001135) )
							{
								return 0.0;
							}
							else
							{
									flp = C_FACE(cf,tf,2);
									tflp = C_FACE_THREAD(cf,tf,2);

									flm = C_FACE(ca,ta,2);
									tflm = C_FACE_THREAD(ca,ta,2);


								// ======================== (crf,trf) ============================= 

									clf = F_C0(flp,tflp);
									if(clf == cl)
									{
										clf = F_C1(flp,tflp);
										tlf = F_C1_THREAD(flp,tflp);
									}
									else
									{
										tlf = F_C0_THREAD(flp,tflp);
									}


								// ======================== (cra,tra) ============================= 

									cla = F_C0(flm,tflm);
									if(cla == cl)
									{
										cla = F_C1(flm,tflm);
										tla = F_C1_THREAD(flm,tflm);
									}
									else
									{
										tla = F_C0_THREAD(flm,tflm);
									}
							}
//			Message(" clf = %u \t cf = %u \n ", clf, cf);		
//			Message(" cl = %u  \t c  = %u \n ", cl, c   );	
//			Message(" cla = %u \t ca = %u \n ", cla, ca);




					}

					// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to bottom boundary.)
					else if( fequal(XC[1], 0.00001135) && (XC[0] > 0.0000227) && (XC[0] < 0.00112365) )
					{
						ff = C_FACE(c,t,2);					
						tff = C_FACE_THREAD(c,t,2);
						fr = C_FACE(c,t,1);
						tfr = C_FACE_THREAD(c,t,1);			
						fl = C_FACE(c,t,3);
						tfl = C_FACE_THREAD(c,t,3);
						fa = C_FACE(c,t,0);
						tfa = C_FACE_THREAD(c,t,0);


//=========================================================================================================================================
						F_CENTROID(XR,fr,tfr);
						F_CENTROID(XF,ff,tff);
						F_CENTROID(XL,fl,tfl);
						F_CENTROID(XA,fa,tfa);

						xr = XR[0] ;
						yf = XF[1] ;
						xl = XL[0] ;
						ya = XA[1] ;

					// ================ GTM FUNCTION CALL =================== 

						delta(c,t, &dx, &dy); 
						nx = C_UDMI(c,t,2);
						ny = C_UDMI(c,t,3);
	
						linseg(c, t_liquid, xl, xr, ya, yf, &xint1, &xint2, &yint1, &yint2, &iface_int1, &iface_int2);
						lgvol( c, t_liquid, xl, xr, ya, yf, &voll );

					// =============== DEFINITION OF N-VECTOR ================ 

			//				n[0]  =  nx; 
			//				n[1]  =  ny;

					// =============== MODIFIED DEFINITION OF S-VECTOR ================ 


						if(xint1 > xint2)
						{
							xi = xint2 + fabs((xint1 - xint2)/2.0) ;
						}
						else
						{
							xi = xint1 + fabs((xint1 - xint2)/2.0) ;
						}

						if(yint1 > yint2)
						{
							yi = yint2 + fabs((yint1 - yint2)/2.0) ;								
						}
						else
						{
							yi = yint1 + fabs((yint1 - yint2)/2.0) ;								
						}			

//============================================================================================================================================


						// ----------- RIGHT FACE ----------- 

							cr = F_C0(fr,tfr);
							if(cr == c)
							{
								cr = F_C1(fr,tfr);
								tr = F_C1_THREAD(fr,tfr);
							}
							else
							{
								tr = F_C0_THREAD(fr,tfr);
							}   

						// ----------- LEFT FACE ------------ =

							cl = F_C0(fl,tfl);
							if(cl == c)
							{
								cl = F_C1(fl,tfl);
								tl = F_C1_THREAD(fl,tfl);
							}
							else
							{
								tl = F_C0_THREAD(fl,tfl);
							}

						// ----------- FRONT FACE ------------ =

							cf = F_C0(ff,tff);
							if(cf == c)
							{
								cf = F_C1(ff,tff);
								tf = F_C1_THREAD(ff,tff);
							}
							else
							{
								tf = F_C0_THREAD(ff,tff);
							}

						c_face_loop(cr,tr,N)
						{
							t_fr = C_FACE_THREAD(cr,tr,N);
							if( BOUNDARY_FACE_THREAD_P(t_fr) )
							{
								check_r = TRUE;
							}
						}

					C_CENTROID(xcr, cr, tr);
					C_CENTROID(xcl, cl, tl);

							if (fequal(xcr[0], 0.00112365) )
							{
								return 0.0 ;

							}
							else if(fequal(xcl[0], 0.000011365) )
							{
								return 0.0 ;
							}
							else
							{

									ffr = C_FACE(cr,tr,2);
									tffr = C_FACE_THREAD(cr,tr,2);

									ffl = C_FACE(cl,tl,2);
									tffl = C_FACE_THREAD(cl,tl,2);

								// ======================== (crf,trf) ============================= 

									crf = F_C0(ffr,tffr);
									if(crf == cr)
									{
										crf = F_C1(ffr,tffr);
										trf = F_C1_THREAD(ffr,tffr);
									}
									else
									{
										trf = F_C0_THREAD(ffr,tffr);
									}
						//			Message(" crf = %u \n ", crf);

								// ======================== (clf,tlf) ============================= 

									clf = F_C0(ffl,tffl);
									if(clf == cl)
									{
										clf = F_C1(ffl,tffl);
										tlf = F_C1_THREAD(ffl,tffl);
									}
									else
									{
										tlf = F_C0_THREAD(ffl,tffl);
									}
						//			Message(" clf = %u \n ", clf);
							
							}

//								Message(" clf = %u \t cf = %u \t crf = %u \n ", clf, cf, crf);		
//								Message(" cl = %u  \t c  = %u \t cr  = %u \n ", cl, c, cr   );									

					}
					
					// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to top boundary.)
					else if( fequal(XC[1], 0.00225865) && (XC[0] > 0.0000227) && (XC[0] < 0.00112365) )
					{
						fa = C_FACE(c,t,2);
						tfa = C_FACE_THREAD(c,t,2);
						fr = C_FACE(c,t,3);
						tfr = C_FACE_THREAD(c,t,3);			
						fl = C_FACE(c,t,1);
						tfl = C_FACE_THREAD(c,t,1);
						ff = C_FACE(c,t,0);
						tff = C_FACE_THREAD(c,t,0);

	//					Message(" HI I am TOP \n");
					
//=========================================================================================================================================
						F_CENTROID(XR,fr,tfr);
						F_CENTROID(XF,ff,tff);
						F_CENTROID(XL,fl,tfl);
						F_CENTROID(XA,fa,tfa);

						xr = XR[0] ;
						yf = XF[1] ;
						xl = XL[0] ;
						ya = XA[1] ;

					// ================ GTM FUNCTION CALL =================== 

						delta(c,t, &dx, &dy); 
						nx = C_UDMI(c,t,2);
						ny = C_UDMI(c,t,3);
	
						linseg(c, t_liquid, xl, xr, ya, yf, &xint1, &xint2, &yint1, &yint2, &iface_int1, &iface_int2);
						lgvol( c, t_liquid, xl, xr, ya, yf, &voll );

					// =============== DEFINITION OF N-VECTOR ================ 

			//				n[0]  =  nx; 
			//				n[1]  =  ny;

					// =============== MODIFIED DEFINITION OF S-VECTOR ================ 


						if(xint1 > xint2)
						{
							xi = xint2 + fabs((xint1 - xint2)/2.0) ;
						}
						else
						{
							xi = xint1 + fabs((xint1 - xint2)/2.0) ;
						}

						if(yint1 > yint2)
						{
							yi = yint2 + fabs((yint1 - yint2)/2.0) ;								
						}
						else
						{
							yi = yint1 + fabs((yint1 - yint2)/2.0) ;								
						}			

//============================================================================================================================================

						// ----------- RIGHT FACE ----------- 

							cr = F_C0(fr,tfr);
							if(cr == c)
							{
								cr = F_C1(fr,tfr);
								tr = F_C1_THREAD(fr,tfr);
							}
							else
							{
								tr = F_C0_THREAD(fr,tfr);
							}   

						// ----------- LEFT FACE ------------ 

							cl = F_C0(fl,tfl);
							if(cl == c)
							{
								cl = F_C1(fl,tfl);
								tl = F_C1_THREAD(fl,tfl);
							}
							else
							{
								tl = F_C0_THREAD(fl,tfl);
							}

						// ----------- AFTER FACE ------------ 

							ca = F_C0(fa,tfa);
							if(ca == c)
							{
								ca = F_C1(fa,tfa);
								ta = F_C1_THREAD(fa,tfa);
							}
							else
							{
								ta = F_C0_THREAD(fa,tfa);
							}



							C_CENTROID(xcr,cr,tr);
							C_CENTROID(xcl,cl,tl);

							if (fequal(xcr[0] , 0.00112365))
							{
								return 0.0 ;
							}
							else if(fequal(xcl[0], 0.00001135))
							{
								return 0.0 ;
							}
							else
							{
									far = C_FACE(cr,tr,2);
									tfar = C_FACE_THREAD(cr,tr,2);

									fal = C_FACE(cl,tl,2);
									tfal = C_FACE_THREAD(cl,tl,2);

								// ======================== (cra,tra) ============================= 

									cra = F_C0(far,tfar);
									if(cra == cr)
									{
										cra = F_C1(far,tfar);
										tra = F_C1_THREAD(far,tfar);
									}
									else
									{
										tra = F_C0_THREAD(far,tfar);
									}
						//			Message(" crf = %u \n ", crf);

								// ======================== (cla,tla) ============================= 

									cla = F_C0(fal,tfal);
									if(cla == cl)
									{
										cla = F_C1(fal,tfal);
										tla = F_C1_THREAD(fal,tfal);
									}
									else
									{
										tla = F_C0_THREAD(fal,tfal);
									}
						//			Message(" clf = %u \n ", clf);

							}
//									Message(" cl = %u  \t c  = %u \t cr  = %u \n ", cl, c, cr   );
//									Message(" cla = %u \t ca = %u \t cra = %u \n ", cla, ca, cra);
					}				
					else
					{
						return 0.0;

						}
			
	}
	else
	{
	
		fr = C_FACE(c,t,1);
		tfr = C_FACE_THREAD(c,t,1);
		fl = C_FACE(c,t,3);					
		tfl = C_FACE_THREAD(c,t,3);			
		ff = C_FACE(c,t,2);					
		tff = C_FACE_THREAD(c,t,2);
		fa = C_FACE(c,t,0);
		tfa = C_FACE_THREAD(c,t,0);
	



	// ----------- RIGHT FACE ----------- =

		cr = F_C0(fr,tfr);
		if(cr == c)
		{
			cr = F_C1(fr,tfr);
			tr = F_C1_THREAD(fr,tfr);
		}
		else
		{
			tr = F_C0_THREAD(fr,tfr);
		}   

	// ----------- LEFT FACE ------------ =

		cl = F_C0(fl,tfl);
		if(cl == c)
		{
			cl = F_C1(fl,tfl);
			tl = F_C1_THREAD(fl,tfl);
		}
		else
		{
			tl = F_C0_THREAD(fl,tfl);
		}

	// ----------- FRONT FACE ------------ =

		cf = F_C0(ff,tff);
		if(cf == c)
		{
			cf = F_C1(ff,tff);
			tf = F_C1_THREAD(ff,tff);
		}
		else
		{
			tf = F_C0_THREAD(ff,tff);
		}

	// ------------ AFTER FACE ------------ =

		ca = F_C0(fa,tfa);
		if(ca == c)
		{
			ca = F_C1(fa,tfa);
			ta = F_C1_THREAD(fa,tfa);
		}
		else
		{
			ta = F_C0_THREAD(fa,tfa);
		}
//	Message("      cf    = \t \t %u \t \t  \n ", cf );
//	Message(" cl , c, cr = %u \t %u \t %u \n ", cl, c, cr );
//	Message("      ca    = \t \t %u \t \t  \n ", ca );

//=========================================================================================================================================
						F_CENTROID(XR,fr,tfr);
						F_CENTROID(XF,ff,tff);
						F_CENTROID(XL,fl,tfl);
						F_CENTROID(XA,fa,tfa);

						xr = XR[0] ;
						yf = XF[1] ;
						xl = XL[0] ;
						ya = XA[1] ;

					// ================ GTM FUNCTION CALL =================== 

						delta(c,t, &dx, &dy); 
						nx = C_UDMI(c,t,2);
						ny = C_UDMI(c,t,3);
	
						linseg(c, t_liquid, xl, xr, ya, yf, &xint1, &xint2, &yint1, &yint2, &iface_int1, &iface_int2);
						lgvol( c, t_liquid, xl, xr, ya, yf, &voll );

					// =============== DEFINITION OF N-VECTOR ================ 

		//					n[0]  =  nx; 
		//					n[1]  =  ny;

					// =============== MODIFIED DEFINITION OF S-VECTOR ================ 


						if(xint1 > xint2)
						{
							xi = xint2 + fabs((xint1 - xint2)/2.0) ;
						}
						else
						{
							xi = xint1 + fabs((xint1 - xint2)/2.0) ;
						}

						if(yint1 > yint2)
						{
							yi = yint2 + fabs((yint1 - yint2)/2.0) ;								
						}
						else
						{
							yi = yint1 + fabs((yint1 - yint2)/2.0) ;								
						}			

//============================================================================================================================================


		c_face_loop(cr,tr,N)
		{
			t_fr = C_FACE_THREAD(cr,tr,N);
			if( BOUNDARY_FACE_THREAD_P(t_fr) )
			{
				check_r = TRUE;
			}
		}

		c_face_loop(cf,tf,N)
		{
			t_ff = C_FACE_THREAD(cf,tf,N);
			if( BOUNDARY_FACE_THREAD_P(t_ff) )
			{
				check_f = TRUE;
			}
		}

		c_face_loop(cl,tl,N)
		{
			t_fl = C_FACE_THREAD(cl,tl,N);
			if( BOUNDARY_FACE_THREAD_P(t_fl) )
			{
				check_l = TRUE;
			}
		}

		c_face_loop(ca,ta,N)
		{
			t_fa = C_FACE_THREAD(ca,ta,N);
			if( BOUNDARY_FACE_THREAD_P(t_fa) )
			{
				check_a = TRUE;
			}
		}				

		if( check_r )
		{
//			Message(" BOUNDARY CELL ENCOUNTERED \n ");
			

				ffr = C_FACE(cr,tr,1);
				tffr = C_FACE_THREAD(cr,tr,1);

				far = C_FACE(cr,tr,3);
				tfar = C_FACE_THREAD(cr,tr,3);

				ffl = C_FACE(cl,tl,2);
				tffl = C_FACE_THREAD(cl,tl,2);

				fal = C_FACE(cl,tl,0);
				tfal = C_FACE_THREAD(cl,tl,0);

			// ======================== (crf,trf) ============================= =

				crf = F_C0(ffr,tffr);
				if(crf == cr)
				{
					crf = F_C1(ffr,tffr);
					trf = F_C1_THREAD(ffr,tffr);
				}
				else
				{
					trf = F_C0_THREAD(ffr,tffr);
				}
	//			Message(" crf = %u \n ", crf);
			// ======================== (cra,tra) ============================= =

				cra = F_C0(far,tfar);
				if(cra == cr)
				{
					cra = F_C1(far,tfar);
					tra = F_C1_THREAD(far,tfar);
				}
				else
				{
					tra = F_C0_THREAD(far,tfar);
				}
	//			Message(" cra = %u \n ", cra);	
			// ======================== (clf,tlf) ============================= =

				clf = F_C0(ffl,tffl);
				if(clf == cl)
				{
					clf = F_C1(ffl,tffl);
					tlf = F_C1_THREAD(ffl,tffl);
				}
				else
				{
					tlf = F_C0_THREAD(ffl,tffl);
				}
	//			Message(" clf = %u \n ", clf);
			// ======================== (cla,tla) ============================= =

				cla = F_C0(fal,tfal);
				if(cla == cl)
				{
					cla = F_C1(fal,tfal);
					tla = F_C1_THREAD(fal,tfal);
				}
				else
				{
					tla = F_C0_THREAD(fal,tfal);
				}
	//			Message(" cla = %u \n ", cla);
		
		}
		else if ( check_f )
		{
			
				frp = C_FACE(cf,tf,3);
				tfrp = C_FACE_THREAD(cf,tf,3);

				flp = C_FACE(cf,tf,1);
				tflp = C_FACE_THREAD(cf,tf,1);

				frm = C_FACE(ca,ta,1);
				tfrm = C_FACE_THREAD(ca,ta,1);

				flm = C_FACE(ca,ta,3);
				tflm = C_FACE_THREAD(ca,ta,3);

			// ======================== (crf,trf) ============================= =

				crf = F_C0(frp,tfrp);
				if(crf == cr)
				{
					crf = F_C1(frp,tfrp);
					trf = F_C1_THREAD(frp,tfrp);
				}
				else
				{
					trf = F_C0_THREAD(frp,tfrp);
				}

			// ======================== (clf,tlf) ============================= =

				clf = F_C0(flp,tflp);
				if(clf == cl)
				{
					clf = F_C1(flp,tflp);
					tlf = F_C1_THREAD(flp,tflp);
				}
				else
				{
					tlf = F_C0_THREAD(flp,tflp);
				}

			// ======================== (cra,tra) ============================= =

				cra = F_C0(frm,tfrm);
				if(cra == cr)
				{
					cra = F_C1(frm,tfrm);
					tra = F_C1_THREAD(frm,tfrm);
				}
				else
				{
					tra = F_C0_THREAD(frm,tfrm);
				}

			// ======================== (cla,tla) ============================= =

				cla = F_C0(flm,tflm);
				if(cla == cl)
				{
					cla = F_C1(flm,tflm);
					tla = F_C1_THREAD(flm,tflm);
				}
				else
				{
					tla = F_C0_THREAD(flm,tflm);
				}
			
		}
		else if ( check_l ) 
		{
			
				ffl = C_FACE(cl,tl,3);
				tffl = C_FACE_THREAD(cl,tl,3);

				fal = C_FACE(cl,tl,1);
				tfal = C_FACE_THREAD(cl,tl,1);

				ffr = C_FACE(cr,tr,2);
				tffr = C_FACE_THREAD(cr,tr,2);

				far = C_FACE(cr,tr,0);
				tfar = C_FACE_THREAD(cr,tr,0);

			// ======================== (crf,trf) ============================= =

				crf = F_C0(ffr,tffr);
				if(crf == cr)
				{
					crf = F_C1(ffr,tffr);
					trf = F_C1_THREAD(ffr,tffr);
				}
				else
				{
					trf = F_C0_THREAD(ffr,tffr);
				}
	//			Message(" crf = %u \n ", crf);
			// ======================== (cra,tra) ============================= =

				cra = F_C0(far,tfar);
				if(cra == cr)
				{
					cra = F_C1(far,tfar);
					tra = F_C1_THREAD(far,tfar);
				}
				else
				{
					tra = F_C0_THREAD(far,tfar);
				}
	//			Message(" cra = %u \n ", cra);	
			// ======================== (clf,tlf) ============================= =

				clf = F_C0(ffl,tffl);
				if(clf == cl)
				{
					clf = F_C1(ffl,tffl);
					tlf = F_C1_THREAD(ffl,tffl);
				}
				else
				{
					tlf = F_C0_THREAD(ffl,tffl);
				}
	//			Message(" clf = %u \n ", clf);
			// ======================== (cla,tla) ============================= =

				cla = F_C0(fal,tfal);
				if(cla == cl)
				{
					cla = F_C1(fal,tfal);
					tla = F_C1_THREAD(fal,tfal);
				}
				else
				{
					tla = F_C0_THREAD(fal,tfal);
				}
	//			Message(" cla = %u \n ", cla);
		
			
		}
		else if ( check_a )
		{
			
				frm = C_FACE(ca,ta,1);
				tfrm = C_FACE_THREAD(ca,ta,1);

				flm = C_FACE(ca,ta,3);
				tflm = C_FACE_THREAD(ca,ta,3);

				frp = C_FACE(cf,tf,1);
				tfrp = C_FACE_THREAD(cf,tf,1);

				flp = C_FACE(cf,tf,3);
				tflp = C_FACE_THREAD(cf,tf,3);
			
			// ======================== (crf,trf) ============================= =

				crf = F_C0(frp,tfrp);
				if(crf == cr)
				{
					crf = F_C1(frp,tfrp);
					trf = F_C1_THREAD(frp,tfrp);
				}
				else
				{
					trf = F_C0_THREAD(frp,tfrp);
				}

			// ======================== (clf,tlf) ============================= =
				clf = F_C0(flp,tflp);
				if(clf == cl)
				{
					clf = F_C1(flp,tflp);
					tlf = F_C1_THREAD(flp,tflp);
				}
				else
				{
					tlf = F_C0_THREAD(flp,tflp);
				}

			// ======================== (cra,tra) ============================= =

				cra = F_C0(frm,tfrm);
				if(cra == cr)
				{
					cra = F_C1(frm,tfrm);
					tra = F_C1_THREAD(frm,tfrm);
				}
				else
				{
					tra = F_C0_THREAD(frm,tfrm);
				}

			// ======================== (cla,tla) ============================= =

				cla = F_C0(flm,tflm);
				if(cla == cl)
				{
					cla = F_C1(flm,tflm);
					tla = F_C1_THREAD(flm,tflm);
				}
				else
				{
					tla = F_C0_THREAD(flm,tflm);
				}
		}
		else
		{
		// ============== DEFINITION OF SECONDARY NEIGHBOURS ============== =

 
			ffr = C_FACE(cr,tr,2);
			tffr = C_FACE_THREAD(cr,tr,2);

			far = C_FACE(cr,tr,0);
			tfar = C_FACE_THREAD(cr,tr,0);

			ffl = C_FACE(cl,tl,2);
			tffl = C_FACE_THREAD(cl,tl,2);

			fal = C_FACE(cl,tl,0);
			tfal = C_FACE_THREAD(cl,tl,0);

//		Message("  far, tfar, ffl, tffl, fal, tfal =  %u %u %u %u %u %u  \n ", far, tfar, ffl, tffl, fal, tfal); 



		// ======================== (crf,trf) ============================= =

			crf = F_C0(ffr,tffr);
			if(crf == cr)
			{
				crf = F_C1(ffr,tffr);
				trf = F_C1_THREAD(ffr,tffr);
			}
			else
			{
				trf = F_C0_THREAD(ffr,tffr);
			}
//			Message(" crf = %u \n ", crf);
		// ======================== (cra,tra) ============================= =

		cra = F_C0(far,tfar);
			if(cra == cr)
			{
				cra = F_C1(far,tfar);
				tra = F_C1_THREAD(far,tfar);
			}
			else
			{
				tra = F_C0_THREAD(far,tfar);
			}
//			Message(" cra = %u \n ", cra);	
		// ======================== (clf,tlf) ============================= =

			clf = F_C0(ffl,tffl);
			if(clf == cl)
			{
				clf = F_C1(ffl,tffl);
				tlf = F_C1_THREAD(ffl,tffl);
			}
			else
			{
				tlf = F_C0_THREAD(ffl,tffl);
			}
//			Message(" clf = %u \n ", clf);
		// ======================== (cla,tla) ============================= =

			cla = F_C0(fal,tfal);
			if(cla == cl)
			{
				cla = F_C1(fal,tfal);
				tla = F_C1_THREAD(fal,tfal);
			}
			else
			{
				tla = F_C0_THREAD(fal,tfal);
			}
//			Message(" cla = %u \n ", cla);
			
			}

//	Message(" clf = %u \t cf = %u \t crf = %u \n ", clf, cf, crf);		
//	Message(" cl = %u  \t c  = %u \t cr  = %u \n ", cl, c, cr   );	
//	Message(" cla = %u \t ca = %u \t cra = %u \n ", cla, ca, cra);
//	Message(" tlf = %u \t tf = %u \t trf = %u \n ", tlf, tf, trf);		
//	Message(" tl = %u  \t t  = %u \t tr  = %u \n ", tl, t, tr   );	
//	Message(" tla = %u \t ta = %u \t tra = %u \n ", tla, ta, tra);
					

		}
			

		


	
			//	Message(" X[ND_ND] , Xr[ND_ND] = \n %g %g \n %g %g \n ", xi, X[1], Xr[0], Xr[1]);

		

										t_f = C_FACE_THREAD(c,t,0);

  										C_CENTROID(XC,c,t);
	

										if(BOUNDARY_FACE_THREAD_P(t_f))
										{


											    if( fequal(XC[0], 0.00001135) && (XC[1] > 0.00003405) && (XC[1] < 0.0022473)  )			// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to left boundary.)
												{
													C_CENTROID(X,c,t);
													C_CENTROID(Xr,cr,tr);
													C_CENTROID(Xf,cf,tf);
													C_CENTROID(Xa,ca,ta);
													C_CENTROID(Xrf,crf,trf);		
													C_CENTROID(Xra,cra,tra);

													NV_D(S11 , = , (Xf[0] - xi) , (Xf[1] - yi) , 0.0 );
													NV_D(S12 , = , (Xrf[0]  - xi) , (Xrf[1]  - yi) , 0.0 );
													NV_D(S21 , = , (X[0]  - xi) , (X[1]  - yi) , 0.0 );
													NV_D(S22 , = , (Xr[0]   - xi) , (Xr[1]   - yi) , 0.0 );
													NV_D(S31 , = , (Xa[0] - xi) , (Xa[1] - yi) , 0.0 );
													NV_D(S32 , = , (Xra[0]  - xi) , (Xra[1]  - yi) , 0.0 );
		
													SX[1][1] = (Xf[0] - xi);
													SX[1][2] = (Xrf[0]  - xi);
													SX[2][1] = (X[0]  - xi);
													SX[2][2] = (Xr[0]   - xi);
													SX[3][1] = (Xa[0] - xi);
													SX[3][2] = (Xra[0]  - xi);
	
													SY[1][1] = (Xf[1] - yi);
													SY[1][2] = (Xrf[1]  - yi);
													SY[2][1] = (X[1]  - yi);
													SY[2][2] = (Xr[1]   - yi);
													SY[3][1] = (Xa[1] - yi);
													SY[3][2] = (Xra[1]  - yi);

													DS[1][1] = sqrt(SX[1][1]*SX[1][1] + SY[1][1]*SY[1][1]) ;
													DS[1][2] = sqrt(SX[1][2]*SX[1][2] + SY[1][2]*SY[1][2]) ;
												//	DS[1][3] = sqrt(SX[1][3]*SX[1][3] + SY[1][3]*SY[1][3]) ;
													DS[2][1] = sqrt(SX[2][1]*SX[2][1] + SY[2][1]*SY[2][1]) ;
													DS[2][2] = sqrt(SX[2][2]*SX[2][2] + SY[2][2]*SY[2][2]) ;
												//	DS[2][3] = sqrt(SX[2][3]*SX[2][3] + SY[2][3]*SY[2][3]) ;
													DS[3][1] = sqrt(SX[3][1]*SX[3][1] + SY[3][1]*SY[3][1]) ;
													DS[3][2] = sqrt(SX[3][2]*SX[3][2] + SY[3][2]*SY[3][2]) ;
												//	DS[3][3] = sqrt(SX[3][3]*SX[3][3] + SY[3][3]*SY[3][3]) ;

													SX[1][1] /= DS[1][1];
													SX[1][2] /= DS[1][2];
													SX[2][1] /= DS[2][1];
													SX[2][2] /= DS[2][2];
													SX[3][1] /= DS[3][1];
													SX[3][2] /= DS[3][2];
	
													SY[1][1] /= DS[1][1];
													SY[1][2] /= DS[1][2];
													SY[2][1] /= DS[2][1];
													SY[2][2] /= DS[2][2];
													SY[3][1] /= DS[3][1];
													SY[3][2] /= DS[3][2];

													dot_prod[1][1] = -( SX[1][1]*n[0] + SY[1][1]*n[1] ) ;//NV_DOT( S[1][1] , n );
													dot_prod[1][2] = -( SX[1][2]*n[0] + SY[1][2]*n[1] ) ;//NV_DOT( S[1][2] , n );
													dot_prod[2][1] = -( SX[2][1]*n[0] + SY[2][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[2][2] = -( SX[2][2]*n[0] + SY[2][2]*n[1] ) ;//NV_DOT( S[2][2] , n );
													dot_prod[3][1] = -( SX[3][1]*n[0] + SY[3][1]*n[1] ) ;//NV_DOT( S[3][1] , n );
													dot_prod[3][2] = -( SX[3][2]*n[0] + SY[3][2]*n[1] ) ;//NV_DOT( S[3][2] , n );

													big = -1.0;
																for( rr = 1; rr <= 3; rr++)
																	for( cc = 1; cc <= 2; cc++)
																	{
																		if (dot_prod[rr][cc] > dot_prod[rr + 1][cc + 1])
																		{
																			big = dot_prod[rr][cc] *100000.0 ;
																			n_row = rr;
																			n_col = cc;
						
																			if(big != 0)
																			{
																	//			Message( " big, rr, cc = %g %d %d \n ", big, rr, cc);
																			}

																			if(rr == 1 && cc == 1)
																			{
																				cs = cf;
																				ts = tf;
																			}
																			else if(rr == 1 && cc == 2)
																			{
																				cs = crf;
																				ts = trf;
																			}
																			else if(rr == 2 && cc == 1)
																			{
																				cs = c;
																				ts = t;
																			}
																			else if(rr == 2 && cc == 2)
																			{
																				cs = cr;
																				ts = tr;
																			}
																			else if(rr == 3 && cc == 1)
																			{
																				cs = ca;
																				ts = ta;
																			}
																			else if(rr == 3 && cc == 2)
																			{
																				cs = cra;
																				ts = tra;
																			}

																		}
																		else
																		{
																			big = big;
																			n_row = n_row ;
																			n_col = n_col ;
																			cs = cs;
																			ts = ts;


																		}
																	}
														Message(" LHS n_row, n_col = %d %d \n ", n_row, n_col );
												}
												else if( fequal(XC[0], 0.00112365) && (XC[1] > 0.00003405) && (XC[1] < 0.0022473)  )			// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to right boundary.)
												{
													C_CENTROID(X,c,t);
													C_CENTROID(Xf,cf,tf);
													C_CENTROID(Xl,cl,tl);		 
													C_CENTROID(Xa,ca,ta);
													C_CENTROID(Xlf,clf,tlf);
													C_CENTROID(Xla,cla,tla);		

													SX[1][1] = (X[0] - xi);
													SX[1][2] = (Xf[0]  - xi);
													SX[2][1] = (Xl[0]  - xi);
													SX[2][2] = (Xa[0]   - xi);
													SX[3][1] = (Xlf[0] - xi);
													SX[3][2] = (Xla[0]  - xi);
	
													SY[1][1] = (X[1] - yi);
													SY[1][2] = (Xf[1]  - yi);
													SY[2][1] = (Xl[1]  - yi);
													SY[2][2] = (Xa[1]   - yi);
													SY[3][1] = (Xlf[1] - yi);
													SY[3][2] = (Xla[1]  - yi);

													DS[1][1] = sqrt(SX[1][1]*SX[1][1] + SY[1][1]*SY[1][1]) ;
													DS[1][2] = sqrt(SX[1][2]*SX[1][2] + SY[1][2]*SY[1][2]) ;
												//	DS[1][3] = sqrt(SX[1][3]*SX[1][3] + SY[1][3]*SY[1][3]) ;
													DS[2][1] = sqrt(SX[2][1]*SX[2][1] + SY[2][1]*SY[2][1]) ;
													DS[2][2] = sqrt(SX[2][2]*SX[2][2] + SY[2][2]*SY[2][2]) ;
												//	DS[2][3] = sqrt(SX[2][3]*SX[2][3] + SY[2][3]*SY[2][3]) ;
													DS[3][1] = sqrt(SX[3][1]*SX[3][1] + SY[3][1]*SY[3][1]) ;
													DS[3][2] = sqrt(SX[3][2]*SX[3][2] + SY[3][2]*SY[3][2]) ;
												//	DS[3][3] = sqrt(SX[3][3]*SX[3][3] + SY[3][3]*SY[3][3]) ;

													SX[1][1] /= DS[1][1];
													SX[1][2] /= DS[1][2];
													SX[2][1] /= DS[2][1];
													SX[2][2] /= DS[2][2];
													SX[3][1] /= DS[3][1];
													SX[3][2] /= DS[3][2];
	
													SY[1][1] /= DS[1][1];
													SY[1][2] /= DS[1][2];
													SY[2][1] /= DS[2][1];
													SY[2][2] /= DS[2][2];
													SY[3][1] /= DS[3][1];
													SY[3][2] /= DS[3][2];

													dot_prod[1][1] = -( SX[1][1]*n[0] + SY[1][1]*n[1] ) ;//NV_DOT( S[1][1] , n );
													dot_prod[1][2] = -( SX[1][2]*n[0] + SY[1][2]*n[1] ) ;//NV_DOT( S[1][2] , n );
													dot_prod[2][1] = -( SX[2][1]*n[0] + SY[2][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[2][2] = -( SX[2][2]*n[0] + SY[2][2]*n[1] ) ;//NV_DOT( S[2][2] , n );
													dot_prod[3][1] = -( SX[3][1]*n[0] + SY[3][1]*n[1] ) ;//NV_DOT( S[3][1] , n );
													dot_prod[3][2] = -( SX[3][2]*n[0] + SY[3][2]*n[1] ) ;//NV_DOT( S[3][2] , n );

													big = 0.0;

																for( rr = 1; rr <= 3; rr++)
																	for( cc = 1; cc <= 2; cc++)
																	{
																		if (dot_prod[rr][cc] > big )
																		{
																			big = dot_prod[rr][cc] ;
																			n_row = rr;
																			n_col = cc;
						
																			if(big != 0)
																			{
																	//			Message( " big, rr, cc = %g %d %d \n ", big, rr, cc);
																			}

																			if(rr == 1 && cc == 1)
																			{
																				cs = clf;
																				ts = tlf;
																			}
																			else if(rr == 1 && cc == 2)
																			{
																				cs = cf;
																				ts = tf;
																			}
																			else if(rr == 2 && cc == 1)
																			{
																				cs = cl;
																				ts = tl;
																			}
																			else if(rr == 2 && cc == 2)
																			{
																				cs = c;
																				ts = t;
																			}
																			else if(rr == 3 && cc == 1)
																			{
																				cs = cla;
																				ts = tla;
																			}
																			else if(rr == 3 && cc == 2)
																			{
																				cs = ca;
																				ts = ta;
																			}

																		}
																		else
																		{
																			big = big;
																			n_row = n_row ;
																			n_col = n_col ;
																			cs = cs;
																			ts = ts;


																		}
																	}
														Message(" RHS n_row, n_col = %d %d \n ", n_row, n_col );

												}
												else if( fequal(XC[1], 0.00001135) && (XC[0] > 0.0000227) && (XC[0] < 0.00112365) )// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to bottom boundary.)
												{
													C_CENTROID(X,c,t);
													C_CENTROID(Xr,cr,tr);
													C_CENTROID(Xf,cf,tf);
													C_CENTROID(Xl,cl,tl);
													C_CENTROID(Xrf,crf,trf);
													C_CENTROID(Xlf,clf,tlf);
								
													SX[1][1] = (Xlf[0] - xi);
													SX[1][2] = (Xf[0]  - xi);
													SX[1][3] = (Xrf[0] - xi);
													SX[2][1] = (Xl[0]  - xi);
													SX[2][2] = (X[0]   - xi);
													SX[2][3] = (Xr[0]  - xi);
	
													SY[1][1] = (Xlf[1] - yi);
													SY[1][2] = (Xf[1]  - yi);
													SY[1][3] = (Xrf[1] - yi);
													SY[2][1] = (Xl[1]  - yi);
													SY[2][2] = (X[1]   - yi);
													SY[2][3] = (Xr[1]  - yi);


													DS[1][1] = sqrt(SX[1][1]*SX[1][1] + SY[1][1]*SY[1][1]) ;
													DS[1][2] = sqrt(SX[1][2]*SX[1][2] + SY[1][2]*SY[1][2]) ;
													DS[1][3] = sqrt(SX[1][3]*SX[1][3] + SY[1][3]*SY[1][3]) ;
													DS[2][1] = sqrt(SX[2][1]*SX[2][1] + SY[2][1]*SY[2][1]) ;
													DS[2][2] = sqrt(SX[2][2]*SX[2][2] + SY[2][2]*SY[2][2]) ;
													DS[2][3] = sqrt(SX[2][3]*SX[2][3] + SY[2][3]*SY[2][3]) ;
												//	DS[3][1] = sqrt(SX[3][1]*SX[3][1] + SY[3][1]*SY[3][1]) ;
												//	DS[3][2] = sqrt(SX[3][2]*SX[3][2] + SY[3][2]*SY[3][2]) ;
												//	DS[3][3] = sqrt(SX[3][3]*SX[3][3] + SY[3][3]*SY[3][3]) ;

													SX[1][1] /= DS[1][1];
													SX[1][2] /= DS[1][2];
													SX[1][3] /= DS[1][3];
													SX[2][1] /= DS[2][1];
													SX[2][2] /= DS[2][2];
													SX[2][3] /= DS[2][3];											
											
	
													SY[1][1] /= DS[1][1];
													SY[1][2] /= DS[1][2];
													SY[1][3] /= DS[1][3];
													SY[2][1] /= DS[2][1];
													SY[2][2] /= DS[2][2];
													SY[2][3] /= DS[2][3];											

													dot_prod[1][1] = -( SX[1][1]*n[0] + SY[1][1]*n[1] ) ;//NV_DOT( S[1][1] , n );
													dot_prod[1][2] = -( SX[1][2]*n[0] + SY[1][2]*n[1] ) ;//NV_DOT( S[1][2] , n );
													dot_prod[1][3] = -( SX[1][3]*n[0] + SY[1][3]*n[1] ) ;//NV_DOT( S[3][1] , n );
													dot_prod[2][1] = -( SX[2][1]*n[0] + SY[2][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[2][2] = -( SX[2][2]*n[0] + SY[2][2]*n[1] ) ;//NV_DOT( S[2][2] , n );
													dot_prod[2][3] = -( SX[2][3]*n[0] + SY[2][3]*n[1] ) ;//NV_DOT( S[3][2] , n );	

													

													big = -1.0;
													for( rr = 1; rr <= 2; rr++)
														for( cc = 1; cc <= 3; cc++)
														{
															if (dot_prod[rr][cc] > big)
															{
																big = dot_prod[rr][cc]  ;
																n_row = rr;
																n_col = cc;
						
																if(big != 0)
																{
														//			Message( " big, rr, cc = %g %d %d \n ", big, rr, cc);
																}

																if(rr == 1 && cc == 1)
																{
																	cs = clf;
																	ts = tlf;
																}
																else if(rr == 1 && cc == 2)
																{
																	cs = cf;
																	ts = tf;
																}
																else if(rr == 1 && cc == 3)
																{
																	cs = crf;
																	ts = trf;
																}
																else if(rr == 2 && cc == 1)
																{
																	cs = cl;
																	ts = tl;
																}
																else if(rr == 2 && cc == 2)
																{
																	cs = c;
																	ts = t;
																}
																else if(rr == 2 && cc == 3)
																{
																	cs = cr;
																	ts = tr;
																}

															}
															else
															{
																big = big;
																n_row = n_row;
																n_col = n_col;
																cs = cs;
																ts = ts;
										
															}
														}
													Message(" B.B n_row, n_col = %d %d \n ", n_row, n_col );
												}
												else if( fequal(XC[1], 0.00225865) && (XC[0] > 0.0000227) && (XC[0] < 0.00112365) )					// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to top boundary.)
												{
													C_CENTROID(X,c,t);
													C_CENTROID(Xr,cr,tr);
													C_CENTROID(Xl,cl,tl);		 
													C_CENTROID(Xa,ca,ta);
													C_CENTROID(Xla,cla,tla);				
													C_CENTROID(Xra,cra,tra);
											
													SX[1][1] = (Xl[0] - xi);
													SX[1][2] = (X[0]  - xi);
													SX[1][3] = (Xr[0] - xi);
													SX[2][1] = (Xla[0]  - xi);
													SX[2][2] = (Xa[0]   - xi);
													SX[2][3] = (Xra[0]  - xi);
	
													SY[1][1] = (Xl[1] - yi);
													SY[1][2] = (X[1]  - yi);
													SY[1][3] = (Xr[1] - yi);
													SY[2][1] = (Xla[1]  - yi);
													SY[2][2] = (Xa[1]   - yi);
													SY[2][3] = (Xra[1]  - yi);


													DS[1][1] = sqrt(SX[1][1]*SX[1][1] + SY[1][1]*SY[1][1]) ;
													DS[1][2] = sqrt(SX[1][2]*SX[1][2] + SY[1][2]*SY[1][2]) ;
													DS[1][3] = sqrt(SX[1][3]*SX[1][3] + SY[1][3]*SY[1][3]) ;
													DS[2][1] = sqrt(SX[2][1]*SX[2][1] + SY[2][1]*SY[2][1]) ;
													DS[2][2] = sqrt(SX[2][2]*SX[2][2] + SY[2][2]*SY[2][2]) ;
													DS[2][3] = sqrt(SX[2][3]*SX[2][3] + SY[2][3]*SY[2][3]) ;
												//	DS[3][1] = sqrt(SX[3][1]*SX[3][1] + SY[3][1]*SY[3][1]) ;
												//	DS[3][2] = sqrt(SX[3][2]*SX[3][2] + SY[3][2]*SY[3][2]) ;
												//	DS[3][3] = sqrt(SX[3][3]*SX[3][3] + SY[3][3]*SY[3][3]) ;

													SX[1][1] /= DS[1][1];
													SX[1][2] /= DS[1][2];
													SX[1][3] /= DS[1][3];
													SX[2][1] /= DS[2][1];
													SX[2][2] /= DS[2][2];
													SX[2][3] /= DS[2][3];											
											
	
													SY[1][1] /= DS[1][1];
													SY[1][2] /= DS[1][2];
													SY[1][3] /= DS[1][3];
													SY[2][1] /= DS[2][1];
													SY[2][2] /= DS[2][2];
													SY[2][3] /= DS[2][3];											

													dot_prod[1][1] = -( SX[1][1]*n[0] + SY[1][1]*n[1] ) ;//NV_DOT( S[1][1] , n );
													dot_prod[1][2] = -( SX[1][2]*n[0] + SY[1][2]*n[1] ) ;//NV_DOT( S[1][2] , n );
													dot_prod[1][3] = -( SX[1][3]*n[0] + SY[1][3]*n[1] ) ;//NV_DOT( S[3][1] , n );
													dot_prod[2][1] = -( SX[2][1]*n[0] + SY[2][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[2][2] = -( SX[2][2]*n[0] + SY[2][2]*n[1] ) ;//NV_DOT( S[2][2] , n );
													dot_prod[2][3] = -( SX[2][3]*n[0] + SY[2][3]*n[1] ) ;//NV_DOT( S[3][2] , n );	

													big = -1.0;

													for( rr = 1; rr <= 2; rr++)
														for( cc = 1; cc <= 3; cc++)
														{
															if (dot_prod[rr][cc] > big)
															{
																big = dot_prod[rr][cc]  ;
																n_row = rr;
																n_col = cc;
						
																if(big != 0)
																{
														//			Message( " big, rr, cc = %g %d %d \n ", big, rr, cc);
																}

																if(rr == 1 && cc == 1)
																{
																	cs = cl;
																	ts = tl;
																}
																else if(rr == 1 && cc == 2)
																{
																	cs = c;
																	ts = t;
																}
																else if(rr == 1 && cc == 3)
																{
																	cs = cr;
																	ts = tr;
																}
																else if(rr == 2 && cc == 1)
																{
																	cs = cla;
																	ts = tla;
																}
																else if(rr == 2 && cc == 2)
																{
																	cs = ca;
																	ts = ta;
																}
																else if(rr == 2 && cc == 3)
																{
																	cs = cra;
																	ts = tra;
																}

															}
															else
															{
																big = big ;
																n_row = n_row;
																n_col = n_col;
																cs = cs;
																ts = ts;
										
															}
														}
													Message(" T.B n_row, n_col = %d %d \n ", n_row, n_col );
												}	
										//		else
										//		{
										//			return 0.0;
										//		}

												
										}
										else								// PLEASE NOTE : THIS WILL REMAIN SAME FOR ALL GEOMETRIES. This part is for interior cells other than cells at boundaries.
										{		
														C_CENTROID(X,c,t);
														C_CENTROID(Xr,cr,tr);
														C_CENTROID(Xf,cf,tf);
														C_CENTROID(Xl,cl,tl);		 
														C_CENTROID(Xa,ca,ta);
														C_CENTROID(Xrf,crf,trf);		
														C_CENTROID(Xlf,clf,tlf);
														C_CENTROID(Xla,cla,tla);				
														C_CENTROID(Xra,cra,tra);

//														Message(" X (clf, cf, crf, cl, c, cr, cla, ca, cra) =  %.10f %.10f %.10f \n %.10f %.10f %.10f \n %.10f %.10f %.10f \n ", Xlf[0], Xf[0], Xrf[0], Xl[0], X[0], Xr[0], Xla[0], Xa[0], Xra[0]);
//														Message(" Y (clf, cf, crf, cl, c, cr, cla, ca, cra) =  %.10f %.10f %.10f \n %.10f %.10f %.10f \n %.10f %.10f %.10f \n ", Xlf[1], Xf[1], Xrf[1], Xl[1], X[1], Xr[1], Xla[1], Xa[1], Xra[1]);
//														Message(" xi, yi = %.10f %.10f \n ", xi, yi );
//														Message(" iphase = \n %f %f %f \n %f %f %f \n %f %f %f \n ", C_UDMI(clf,tlf,1),C_UDMI(cf,tf,1),C_UDMI(crf,trf,1),C_UDMI(cl,tl,1),C_UDMI(c,t,1),C_UDMI(cr,tr,1),C_UDMI(cla,tla,1),C_UDMI(ca,ta,1),C_UDMI(cra,tra,1));

														SX[1][1] = (Xlf[0] - xi);
														SX[1][2] = (Xf[0]  - xi);
														SX[1][3] = (Xrf[0] - xi);
														SX[2][1] = (Xl[0]  - xi);
														SX[2][2] = 0.0 ; // (X[0] -xi); // 0.0;
														SX[2][3] = (Xr[0]  - xi);
														SX[3][1] = (Xla[0] - xi);
														SX[3][2] = (Xa[0]  - xi);
														SX[3][3] = (Xra[0] - xi);

//														Message(" SX Matrix = \n %g %g %g \n %g %g %g \n %g %g %g \n ", SX[1][1],SX[1][2],SX[1][3],SX[2][1],SX[2][2],SX[2][3],SX[3][1],SX[3][2],SX[3][3]);

														SY[1][1] = (Xlf[1] - yi);
														SY[1][2] = (Xf[1]  - yi);
														SY[1][3] = (Xrf[1] - yi);
														SY[2][1] = (Xl[1]  - yi);
														SY[2][2] = 0.0; // (X[1] - yi); // 0.0;
														SY[2][3] = (Xr[1]  - yi);
														SY[3][1] = (Xla[1] - yi);
														SY[3][2] = (Xa[1]  - yi);
														SY[3][3] = (Xra[1] - yi);

//														Message(" SY Matrix = \n %g %g %g \n %g %g %g \n %g %g %g \n ", SY[1][1],SY[1][2],SY[1][3],SY[2][1],SY[2][2],SY[2][3],SY[3][1],SY[3][2],SY[3][3]);

													DS[1][1] = sqrt(SX[1][1]*SX[1][1] + SY[1][1]*SY[1][1]) ;
													DS[1][2] = sqrt(SX[1][2]*SX[1][2] + SY[1][2]*SY[1][2]) ;
													DS[1][3] = sqrt(SX[1][3]*SX[1][3] + SY[1][3]*SY[1][3]) ;
													DS[2][1] = sqrt(SX[2][1]*SX[2][1] + SY[2][1]*SY[2][1]) ;
													DS[2][2] = 0.0 ; // sqrt(SX[2][2]*SX[2][2] + SY[2][2]*SY[2][2]) ; 
													DS[2][3] = sqrt(SX[2][3]*SX[2][3] + SY[2][3]*SY[2][3]) ;
													DS[3][1] = sqrt(SX[3][1]*SX[3][1] + SY[3][1]*SY[3][1]) ;
													DS[3][2] = sqrt(SX[3][2]*SX[3][2] + SY[3][2]*SY[3][2]) ;
													DS[3][3] = sqrt(SX[3][3]*SX[3][3] + SY[3][3]*SY[3][3]) ;

													SX[1][1] /= DS[1][1];
													SX[1][2] /= DS[1][2];
													SX[1][3] /= DS[1][3];
													SX[2][1] /= DS[2][1];
													SX[2][2] = 0.0; 
													SX[2][3] /= DS[2][3];											
													SX[3][1] /= DS[3][1];
													SX[3][2] /= DS[3][2];
													SX[3][3] /= DS[3][3];												
	
													SY[1][1] /= DS[1][1];
													SY[1][2] /= DS[1][2];
													SY[1][3] /= DS[1][3];
													SY[2][1] /= DS[2][1];
													SY[2][2] = 0.0; 
													SY[2][3] /= DS[2][3];
													SY[3][1] /= DS[3][1];
													SY[3][2] /= DS[3][2];
													SY[3][3] /= DS[3][3];												

										

													dot_prod[1][1] = -( SX[1][1]*n[0] + SY[1][1]*n[1] ) ;//NV_DOT( S[1][1] , n );
													dot_prod[1][2] = -( SX[1][2]*n[0] + SY[1][2]*n[1] ) ;//NV_DOT( S[1][2] , n );
													dot_prod[1][3] = -( SX[1][3]*n[0] + SY[1][3]*n[1] ) ;//NV_DOT( S[3][1] , n );
													dot_prod[2][1] = -( SX[2][1]*n[0] + SY[2][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[2][2] = 0.0; //-( SX[2][2]*n[0] + SY[2][2]*n[1] ) ;//NV_DOT( S[2][2] , n );
													dot_prod[2][3] = -( SX[2][3]*n[0] + SY[2][3]*n[1] ) ;//NV_DOT( S[3][2] , n );	
													dot_prod[3][1] = -( SX[3][1]*n[0] + SY[3][1]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[3][2] = -( SX[3][2]*n[0] + SY[3][2]*n[1] ) ;//NV_DOT( S[2][1] , n );
													dot_prod[3][3] = -( SX[3][3]*n[0] + SY[3][3]*n[1] ) ;//NV_DOT( S[2][1] , n );
		
//			Message(" c, C_UDMI(c,t,1), n[0], n[1], DOT PROD = %u %f %.15f %.15f \n %g %g %g \n %g %g %g \n %g %g %g \n ", c, C_UDMI(c,t,1), n[0], n[1], dot_prod[1][1],dot_prod[1][2],dot_prod[1][3],dot_prod[2][1],dot_prod[2][2],dot_prod[2][3],dot_prod[3][1],dot_prod[3][2],dot_prod[3][3]);

	
													//	big = 0.0;
	
														big = -1.0;
	
														for( rr = 1; rr <= 3; rr++)
															for( cc = 1; cc <= 3; cc++)
															{
													//			Message("rr,cc= %d %d \n", rr, cc);

																if (dot_prod[rr][cc] > big)
																{
																	big = dot_prod[rr][cc] ;
																	n_row = rr;
																	n_col = cc;
						
																	if(big != 0.0)
																	{
															//			Message( " big, rr, cc = %g %d %d \n ", big, rr, cc);
																	}

																	if(rr == 1 && cc == 1)
																	{
																		cs = clf;
																		ts = tlf;
																	}
																	else if(rr == 1 && cc == 2)
																	{
																		cs = cf;
																		ts = tf;
																	}
																	else if(rr == 1 && cc == 3)
																	{
																		cs = crf;
																		ts = trf;
																	}
																	else if(rr == 2 && cc == 1)
																	{
																		cs = cl;
																		ts = tl;
																	}
																	else if(rr == 2 && cc == 2)
																	{
																		cs = c;
																		ts = t;
																	}
																	else if(rr == 2 && cc == 3)
																	{
																		cs = cr;
																		ts = tr;
																	}
																	else if(rr == 3 && cc == 1)
																	{
																		cs = cla;
																		ts = tla;
																	}
																	else if(rr == 3 && cc == 2)
																	{
																		cs = ca;
																		ts = ta;
																	}
																	else if(rr == 3 && cc == 3)
																	{
																		cs = cra;
																		ts = tra;
																	}
																}
																else
																{
																	big = big;
																	n_row = n_row;
																	n_col = n_col;
																	cs = cs;
																	ts = ts;

																}


															}
										//		Message(" c, n_row, n_col = %u %d %d \n ", c, n_row, n_col );

									}

//								Message(" c, n_row, n_col = %u %d %d \n ", c, n_row, n_col );

		if( n_row == 0 || n_col == 0 || n_row > 3 || n_col > 3 )
		{
			return  0.0;
		}
		else
		{
									sx = SX[n_row][n_col];
									sy = SY[n_row][n_col];
									ds = DS[n_row][n_col];	// sqrt(sx*sx + sy*sy); 
								//	sx = sx/ds;
								//	sy = sy/ds;

//			NV_D(s , = , SX[n_row][n_col] , SY[n_row][n_col] , 0.0 );

			kl = 0.5454;
			kg = 0.5383;
			keff = kl*C_VOF(c,t_liquid) + kg*C_VOF(c,t_vapour);
			latent_heat = 276400.0;

//			ds = NV_MAG(s);
			


			if ( fequal(ds , 0.0) )
			{
				source = 0.0;
			}
			else
			{
//				NV_VS(q_s, = , s , * , (kl*(TSAT - C_T(cs,ts))/ds) );

//				q_n = NV_DOT(q_s , n);
//			C_CENTROID(XCS, cs, ts);
//			C_CENTROID(XC,c,t);
//			Message(" c, cs, C_UDMI(cs,ts,1) , C_UDMI(c,t,1) = %u %u %f %f \n ", c, cs, C_UDMI(cs,t,1) , C_UDMI(c,t,1) );
				q_n = sx*(kl*(TSAT - C_T(cs,t))/ds)*C_VOF_RG(c,t_liquid)[0] + sy*(kl*(TSAT - C_T(cs,t))/ds)*C_VOF_RG(c,t_liquid)[1] ; 
				source = - q_n  ; 
//			Message("c, ds, C_T(cs,t), source  = %u %f %f %g \n ", c, ds, C_T(cs,t), source );
				C_UDMI(c,t,7) = source;
			}			

			dS[eqn] = 0.0;
	//		Message(" c, source = %u %g  \n ", c, source );
	//		Message("last = %f %f %g %g %g %.20f \n ", SX[n_row][n_col], SY[n_row][n_col] , q_n, ((kl*(TSAT - C_T(cs,ts))/ds)/latent_heat) , ds , source );
			return    source;		
		}
		
			
	
	}
	else
	{
		return 0.0;
	}
}
/* This part is used for initialising vapour profile as is done in FORTRAN code. */

// IMPORTANT NOTE: 

//   THIS PART DEPENDS ON GRID GEOMETRY. This code is written for Rectangular grid of size 1.135mm width and 2.27 mm height.
//   Please change it if you wish to alter geometry.
DEFINE_INIT(iterface_profile1,d)
{
  cell_t c;
  Thread *t, *t_liquid, *t_vapour,*tf, *tff, *tfa, *t_f;
  face_t ff,fa;
  real x;
  real xc[ND_ND], xf[ND_ND],  xa[ND_ND] ;
  real wavc, yif, ytop, ybot;
  Node *node;
  int i,n, iphs;
  real t_sup = 15.0;
  real twall ;
  real dx, dy;
  real voidf;
  real nx, ny;
  double theta;
  float time;
  FILE *fp;
  char name[50];
  


  /* loop over all cell threads in the domain  */
  thread_loop_c(t,d)
    {
		if( FLUID_THREAD_P(t) )
		{
      /* loop over all cells  */
      begin_c_loop_all(c,t)
        {
		  t_liquid = THREAD_SUB_THREAD(t,0);
          t_vapour = THREAD_SUB_THREAD(t,1);
          
		           
		  wavc = (SIGMA)/(M_G*(ROL - ROG));		//(3.0*SIGMA)/(M_G*(ROL - ROG));
		  wavc = 2.0*M_PI*sqrt(wavc)*sqrt(3.0);
		  delta(c, t, &dx, &dy);
		  C_CENTROID(xc,c,t);

		//  node = C_NODE(c,t,0);
		  
		//  t_f = C_FACE_THREAD(c,t,0);

		  if( fequal(xc[1], 0.001135/360.0 ) )		//	( NODE_Y(node) == 0 )
		  {
			  			  
			  
			  x = xc[0]; // - 0.001135 ;
			
			 // Message(" x = %f \n ", x);
			  theta = (2.0*M_PI*x/wavc);
			  yif =   (wavc/128.0)*(2.0 + cos(theta));		// film thickness is doubled as that used in fortran code....// 25.09.2013
		//	  Message(" c, yif = %u %f \n ", c, yif );

		  }
		
		  

		  tf = C_FACE_THREAD(c,t,0);

		  if(BOUNDARY_FACE_THREAD_P(tf))
		  {
			  c_node_loop(c,t,n)
				{
					  node = C_NODE(c,t,n);

					if( fequal(NODE_X(node), 0.0 ) )			// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to left boundary.)
					{  
					
				//		Message(" 1 \t " );
						if(fequal(NODE_Y(node) , 0.0 ) ) // && NODE_Y(node)*10000000 == 454)				// Bottom Most Left Hand Corner.
						{	
				//			Message(" 2 \t " );
							ff = C_FACE(c,t,2);
							tff = C_FACE_THREAD(c,t,2);
							fa = C_FACE(c,t,0);
							tfa = C_FACE_THREAD(c,t,0);
						}
						else																	// From 0 < y < Ymax
						{	
				//			Message(" 3 \t " );
							ff = C_FACE(c,t,3);					
							tff = C_FACE_THREAD(c,t,3);
							fa = C_FACE(c,t,1);
							tfa = C_FACE_THREAD(c,t,1);
						}
						
					
					}
					if( NODE_X(node)*1000000 ==   1135 )	// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to Right boundary.)	
					{
						if( fequal(NODE_Y(node), 0.0 ) ) 						// Bottom Most Right Hand Corner.
						{
							ff = C_FACE(c,t,2);					
							tff = C_FACE_THREAD(c,t,2);
							fa = C_FACE(c,t,0);
							tfa = C_FACE_THREAD(c,t,0);
						}
						else
						{
							ff = C_FACE(c,t,1);					
							tff = C_FACE_THREAD(c,t,1);
							fa = C_FACE(c,t,3);
							tfa = C_FACE_THREAD(c,t,3);
						}
			//			Message(" HI I am Right \n");
					}			
					if( fequal(NODE_Y(node), 0.0 ) )			// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to Bottom boundary.)
					{
						if( fequal(NODE_X(node), 0.0 ) )						// Bottom Most Left Hand Corner.
						{
							ff = C_FACE(c,t,3);					
							tff = C_FACE_THREAD(c,t,3);
							fa = C_FACE(c,t,1);
							tfa = C_FACE_THREAD(c,t,1);
						}
						else
						{
							ff = C_FACE(c,t,2);					
							tff = C_FACE_THREAD(c,t,2);
							fa = C_FACE(c,t,0);
							tfa = C_FACE_THREAD(c,t,0);
						}
			//				Message(" ff, fa, tff, tfa = %u %u %u %u  \n", ff, fa, tff, tfa );
	//					Message(" HI I am Bottom \n");
					}
					if( NODE_Y(node)*100000 == 227 )			// PLEASE NOTE : THIS WILL CHANGE IN CASE GEOMETRY OF DOMAIN IS DIFFERENT FROM RECTANGULAR ONE(This refers to Top boundary.)
					{
						ff = C_FACE(c,t,0);					
						tff = C_FACE_THREAD(c,t,0);
						fa = C_FACE(c,t,2);
						tfa = C_FACE_THREAD(c,t,2);
	//					Message(" HI I am TOP \n");
					}		

				 }
		  }
		  else
		  {
			  ff  = C_FACE(c,t,2);
			  tff = C_FACE_THREAD(c,t,2);

			  fa  = C_FACE(c,t,0);
			  tfa = C_FACE_THREAD(c,t,0);
		  }
			  F_CENTROID(xf,ff,tff);
			  F_CENTROID(xa,fa,tfa);

			  ytop = xf[1];
			  ybot = xa[1];
		//	  Message(" yif, ybot = %g %g \n ", yif, ybot);
			  

			  if (yif > ytop)
			  {
				//  Message(" Vapour Cell \n ");
				//  Message(" Vapour Centroid = %g %g \n ", xc[0], xc[1]);
				  C_VOF(c,t_liquid) = 0.0;
				  C_VOF(c,t_vapour) = 1.0 ;
				  C_P(c,t) = PSAT;
				  twall = TSAT + t_sup;
				  C_T(c,t) = twall - (ytop - 0.0 - 0.5*dy)*t_sup/yif ;
			//	 iphase[c] = 3; // C_UDSI(c,t,0) = 3.;		// Phase = Vapour
				 C_UDMI(c,t,1) = 3;
			  }
			  else if (yif < ybot)
			  {
				//  Message(" Liquid Cell \n ");
				//  Message(" Liquid Centroid = %g %g \n ", xc[0], xc[1]);
				  C_VOF(c,t_vapour) = 0.0;
				  C_VOF(c,t_liquid) = 1.0;
				  C_P(c,t) = PSAT - ROL*M_G*(ytop - yif);
				  C_T(c,t) = TSAT;
			//	iphase[c] = 1; // C_UDSI(c,t,0) = 1.;		// Phase = Liquid
				C_UDMI(c,t,1) = 1;
			  }
			  else if (yif > ybot && yif < ytop)
			  {
				//  Message(" Mixture Cell \n ");
				//  Message(" Mixture Centroid = %g %g \n ", xc[0], xc[1]);
				  voidf = ( yif - ybot )/( ytop - ybot ) ;
				  C_VOF(c,t_vapour) = voidf;
				  C_VOF(c,t_liquid) = 1 - voidf;
				  C_R(c,t) = ROG + voidf*(ROL - ROG);
				  C_P(c,t) = PSAT;
				  C_T(c,t) = TSAT;
			//	 iphase[c] = 2; // C_UDSI(c,t,0) = 2.;		// Phase = Mixture
				 C_UDMI(c,t,1) = 2;
		//		 Message(" %u \n ", c);
			  }

	  }
      end_c_loop_all(c,t)
    }
  }
}


//  This function returns True or False depending on whether number 'x' is a Finite or Infinite Number ( For C,C++ it is "#INF" and for FORTRAN it is "NAN"). SIMILAR function can be made for #IND values in C
extern void
IsFiniteNumber(double x, cxboolean *INF) 
{
	*INF = TRUE;
     if (x <= DBL_MAX && x >= -DBL_MAX)
	 {
		 *INF = FALSE;
	 }
	 return;
}    

extern void
IsIndeterminate(double x, cxboolean *IND) 
{
	*IND = FALSE;
     if (x != x)
	 {
		 *IND = TRUE;
	 }
	 return;
}    

extern int 
float_equal(float f1, float f2)
{
  float precision = 0.0000001;
  if (((f1 - precision) < f2) && ((f1 + precision) > f2))
   {
    return 1;
   }
  else
   {
    return 0;
   }
 }

extern cxboolean
fequal(real a, real b)
{
	real epsilon = 0.0000001 ;
	
	if(fabs(a - b) < epsilon )
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}
